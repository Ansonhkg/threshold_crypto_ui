{"message":"unused imports: `Mutex`, `Once`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"/home/azureuser/blst/bindings/rust/src/lib.rs","byte_start":331,"byte_end":336,"line_start":11,"line_end":11,"column_start":48,"column_end":53,"is_primary":true,"text":[{"text":"use std::sync::{atomic::*, mpsc::channel, Arc, Mutex, Once};","highlight_start":48,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/azureuser/blst/bindings/rust/src/lib.rs","byte_start":338,"byte_end":342,"line_start":11,"line_end":11,"column_start":55,"column_end":59,"is_primary":true,"text":[{"text":"use std::sync::{atomic::*, mpsc::channel, Arc, Mutex, Once};","highlight_start":55,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the unused imports","code":null,"level":"help","spans":[{"file_name":"/home/azureuser/blst/bindings/rust/src/lib.rs","byte_start":329,"byte_end":342,"line_start":11,"line_end":11,"column_start":46,"column_end":59,"is_primary":true,"text":[{"text":"use std::sync::{atomic::*, mpsc::channel, Arc, Mutex, Once};","highlight_start":46,"highlight_end":59}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused imports: `Mutex`, `Once`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/azureuser/blst/bindings/rust/src/lib.rs:11:48\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m11\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse std::sync::{atomic::*, mpsc::channel, Arc, Mutex, Once};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                               \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` on by default\u001b[0m\n\n"}
{"message":"variable does not need to be mutable","code":{"code":"unused_mut","explanation":null},"level":"warning","spans":[{"file_name":"/home/azureuser/blst/bindings/rust/src/lib.rs","byte_start":25106,"byte_end":25113,"line_start":779,"line_end":779,"column_start":21,"column_end":28,"is_primary":true,"text":[{"text":"                let mut acc = rx.recv().unwrap();","highlight_start":21,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/azureuser/blst/bindings/rust/src/lib.rs","byte_start":51945,"byte_end":52960,"line_start":1472,"line_end":1510,"column_start":5,"column_end":7,"is_primary":false,"text":[{"text":"    sig_variant_impl!(","highlight_start":5,"highlight_end":23},{"text":"        \"MinPk\",","highlight_start":1,"highlight_end":17},{"text":"        blst_p1,","highlight_start":1,"highlight_end":17},{"text":"        blst_p1_affine,","highlight_start":1,"highlight_end":24},{"text":"        blst_p2,","highlight_start":1,"highlight_end":17},{"text":"        blst_p2_affine,","highlight_start":1,"highlight_end":24},{"text":"        blst_sk_to_pk2_in_g1,","highlight_start":1,"highlight_end":30},{"text":"        true,","highlight_start":1,"highlight_end":14},{"text":"        blst_hash_to_g2,","highlight_start":1,"highlight_end":25},{"text":"        blst_sign_pk2_in_g1,","highlight_start":1,"highlight_end":29},{"text":"        blst_p1_affine_is_equal,","highlight_start":1,"highlight_end":33},{"text":"        blst_p2_affine_is_equal,","highlight_start":1,"highlight_end":33},{"text":"        blst_core_verify_pk_in_g1,","highlight_start":1,"highlight_end":35},{"text":"        blst_p1_affine_in_g1,","highlight_start":1,"highlight_end":30},{"text":"        blst_p1_to_affine,","highlight_start":1,"highlight_end":27},{"text":"        blst_p1_from_affine,","highlight_start":1,"highlight_end":29},{"text":"        blst_p1_affine_serialize,","highlight_start":1,"highlight_end":34},{"text":"        blst_p1_affine_compress,","highlight_start":1,"highlight_end":33},{"text":"        blst_p1_deserialize,","highlight_start":1,"highlight_end":29},{"text":"        blst_p1_uncompress,","highlight_start":1,"highlight_end":28},{"text":"        48,","highlight_start":1,"highlight_end":12},{"text":"        96,","highlight_start":1,"highlight_end":12},{"text":"        blst_p2_affine_in_g2,","highlight_start":1,"highlight_end":30},{"text":"        blst_p2_to_affine,","highlight_start":1,"highlight_end":27},{"text":"        blst_p2_from_affine,","highlight_start":1,"highlight_end":29},{"text":"        blst_p2_affine_serialize,","highlight_start":1,"highlight_end":34},{"text":"        blst_p2_affine_compress,","highlight_start":1,"highlight_end":33},{"text":"        blst_p2_deserialize,","highlight_start":1,"highlight_end":29},{"text":"        blst_p2_uncompress,","highlight_start":1,"highlight_end":28},{"text":"        96,","highlight_start":1,"highlight_end":12},{"text":"        192,","highlight_start":1,"highlight_end":13},{"text":"        blst_p1_add_or_double,","highlight_start":1,"highlight_end":31},{"text":"        blst_p1_add_or_double_affine,","highlight_start":1,"highlight_end":38},{"text":"        blst_p2_add_or_double,","highlight_start":1,"highlight_end":31},{"text":"        blst_p2_add_or_double_affine,","highlight_start":1,"highlight_end":38},{"text":"        blst_p1_affine_is_inf,","highlight_start":1,"highlight_end":31},{"text":"        blst_p2_affine_is_inf,","highlight_start":1,"highlight_end":31},{"text":"        blst_p2_in_g2,","highlight_start":1,"highlight_end":23},{"text":"    );","highlight_start":1,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"sig_variant_impl!","def_site_span":{"file_name":"/home/azureuser/blst/bindings/rust/src/lib.rs","byte_start":7790,"byte_end":51903,"line_start":283,"line_end":1467,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! sig_variant_impl {","highlight_start":1,"highlight_end":32},{"text":"    (","highlight_start":1,"highlight_end":6},{"text":"        $name:expr,","highlight_start":1,"highlight_end":20},{"text":"        $pk:ty,","highlight_start":1,"highlight_end":16},{"text":"        $pk_aff:ty,","highlight_start":1,"highlight_end":20},{"text":"        $sig:ty,","highlight_start":1,"highlight_end":17},{"text":"        $sig_aff:ty,","highlight_start":1,"highlight_end":21},{"text":"        $sk_to_pk:ident,","highlight_start":1,"highlight_end":25},{"text":"        $hash_or_encode:expr,","highlight_start":1,"highlight_end":30},{"text":"        $hash_or_encode_to:ident,","highlight_start":1,"highlight_end":34},{"text":"        $sign:ident,","highlight_start":1,"highlight_end":21},{"text":"        $pk_eq:ident,","highlight_start":1,"highlight_end":22},{"text":"        $sig_eq:ident,","highlight_start":1,"highlight_end":23},{"text":"        $verify:ident,","highlight_start":1,"highlight_end":23},{"text":"        $pk_in_group:ident,","highlight_start":1,"highlight_end":28},{"text":"        $pk_to_aff:ident,","highlight_start":1,"highlight_end":26},{"text":"        $pk_from_aff:ident,","highlight_start":1,"highlight_end":28},{"text":"        $pk_ser:ident,","highlight_start":1,"highlight_end":23},{"text":"        $pk_comp:ident,","highlight_start":1,"highlight_end":24},{"text":"        $pk_deser:ident,","highlight_start":1,"highlight_end":25},{"text":"        $pk_uncomp:ident,","highlight_start":1,"highlight_end":26},{"text":"        $pk_comp_size:expr,","highlight_start":1,"highlight_end":28},{"text":"        $pk_ser_size:expr,","highlight_start":1,"highlight_end":27},{"text":"        $sig_in_group:ident,","highlight_start":1,"highlight_end":29},{"text":"        $sig_to_aff:ident,","highlight_start":1,"highlight_end":27},{"text":"        $sig_from_aff:ident,","highlight_start":1,"highlight_end":29},{"text":"        $sig_ser:ident,","highlight_start":1,"highlight_end":24},{"text":"        $sig_comp:ident,","highlight_start":1,"highlight_end":25},{"text":"        $sig_deser:ident,","highlight_start":1,"highlight_end":26},{"text":"        $sig_uncomp:ident,","highlight_start":1,"highlight_end":27},{"text":"        $sig_comp_size:expr,","highlight_start":1,"highlight_end":29},{"text":"        $sig_ser_size:expr,","highlight_start":1,"highlight_end":28},{"text":"        $pk_add_or_dbl:ident,","highlight_start":1,"highlight_end":30},{"text":"        $pk_add_or_dbl_aff:ident,","highlight_start":1,"highlight_end":34},{"text":"        $sig_add_or_dbl:ident,","highlight_start":1,"highlight_end":31},{"text":"        $sig_add_or_dbl_aff:ident,","highlight_start":1,"highlight_end":35},{"text":"        $pk_is_inf:ident,","highlight_start":1,"highlight_end":26},{"text":"        $sig_is_inf:ident,","highlight_start":1,"highlight_end":27},{"text":"        $sig_aggr_in_group:ident,","highlight_start":1,"highlight_end":34},{"text":"    ) => {","highlight_start":1,"highlight_end":11},{"text":"        /// Secret Key","highlight_start":1,"highlight_end":23},{"text":"        #[derive(Default, Debug, Clone, Zeroize)]","highlight_start":1,"highlight_end":50},{"text":"        #[zeroize(drop)]","highlight_start":1,"highlight_end":25},{"text":"        pub struct SecretKey {","highlight_start":1,"highlight_end":31},{"text":"            value: blst_scalar,","highlight_start":1,"highlight_end":32},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl SecretKey {","highlight_start":1,"highlight_end":25},{"text":"            /// Deterministically generate a secret key from key material","highlight_start":1,"highlight_end":74},{"text":"            pub fn key_gen(","highlight_start":1,"highlight_end":28},{"text":"                ikm: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                key_info: &[u8],","highlight_start":1,"highlight_end":33},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                if ikm.len() < 32 {","highlight_start":1,"highlight_end":36},{"text":"                    return Err(BLST_ERROR::BLST_BAD_ENCODING);","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut sk = SecretKey::default();","highlight_start":1,"highlight_end":51},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    blst_keygen(","highlight_start":1,"highlight_end":33},{"text":"                        &mut sk.value,","highlight_start":1,"highlight_end":39},{"text":"                        ikm.as_ptr(),","highlight_start":1,"highlight_end":38},{"text":"                        ikm.len(),","highlight_start":1,"highlight_end":35},{"text":"                        key_info.as_ptr(),","highlight_start":1,"highlight_end":43},{"text":"                        key_info.len(),","highlight_start":1,"highlight_end":40},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(sk)","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // sk_to_pk","highlight_start":1,"highlight_end":24},{"text":"            pub fn sk_to_pk(&self) -> PublicKey {","highlight_start":1,"highlight_end":50},{"text":"                // TODO - would the user like the serialized/compressed pk as well?","highlight_start":1,"highlight_end":84},{"text":"                let mut pk_aff = PublicKey::default();","highlight_start":1,"highlight_end":55},{"text":"                //let mut pk_ser = [0u8; $pk_ser_size];","highlight_start":1,"highlight_end":56},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sk_to_pk(","highlight_start":1,"highlight_end":31},{"text":"                        //pk_ser.as_mut_ptr(),","highlight_start":1,"highlight_end":47},{"text":"                        ptr::null_mut(),","highlight_start":1,"highlight_end":41},{"text":"                        &mut pk_aff.point,","highlight_start":1,"highlight_end":43},{"text":"                        &self.value,","highlight_start":1,"highlight_end":37},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                pk_aff","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Sign","highlight_start":1,"highlight_end":20},{"text":"            pub fn sign(","highlight_start":1,"highlight_end":25},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                msg: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                aug: &[u8],","highlight_start":1,"highlight_end":28},{"text":"            ) -> Signature {","highlight_start":1,"highlight_end":29},{"text":"                // TODO - would the user like the serialized/compressed sig as well?","highlight_start":1,"highlight_end":85},{"text":"                let mut q = <$sig>::default();","highlight_start":1,"highlight_end":47},{"text":"                let mut sig_aff = <$sig_aff>::default();","highlight_start":1,"highlight_end":57},{"text":"                //let mut sig_ser = [0u8; $sig_ser_size];","highlight_start":1,"highlight_end":58},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $hash_or_encode_to(","highlight_start":1,"highlight_end":40},{"text":"                        &mut q,","highlight_start":1,"highlight_end":32},{"text":"                        msg.as_ptr(),","highlight_start":1,"highlight_end":38},{"text":"                        msg.len(),","highlight_start":1,"highlight_end":35},{"text":"                        dst.as_ptr(),","highlight_start":1,"highlight_end":38},{"text":"                        dst.len(),","highlight_start":1,"highlight_end":35},{"text":"                        aug.as_ptr(),","highlight_start":1,"highlight_end":38},{"text":"                        aug.len(),","highlight_start":1,"highlight_end":35},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                    $sign(ptr::null_mut(), &mut sig_aff, &q, &self.value);","highlight_start":1,"highlight_end":75},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Signature { point: sig_aff }","highlight_start":1,"highlight_end":45},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // TODO - formally speaking application is entitled to have","highlight_start":1,"highlight_end":72},{"text":"            // ultimate control over secret key storage, which means that","highlight_start":1,"highlight_end":74},{"text":"            // corresponding serialization/deserialization subroutines","highlight_start":1,"highlight_end":71},{"text":"            // should accept reference to where to store the result, as","highlight_start":1,"highlight_end":72},{"text":"            // opposite to returning one.","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // serialize","highlight_start":1,"highlight_end":25},{"text":"            pub fn serialize(&self) -> [u8; 32] {","highlight_start":1,"highlight_end":50},{"text":"                let mut sk_out = [0; 32];","highlight_start":1,"highlight_end":42},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    blst_bendian_from_scalar(sk_out.as_mut_ptr(), &self.value);","highlight_start":1,"highlight_end":80},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                sk_out","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // deserialize","highlight_start":1,"highlight_end":27},{"text":"            pub fn deserialize(sk_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":75},{"text":"                let mut sk = blst_scalar::default();","highlight_start":1,"highlight_end":53},{"text":"                if sk_in.len() != 32 {","highlight_start":1,"highlight_end":39},{"text":"                    return Err(BLST_ERROR::BLST_BAD_ENCODING);","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    blst_scalar_from_bendian(&mut sk, sk_in.as_ptr());","highlight_start":1,"highlight_end":71},{"text":"                    if !blst_sk_check(&sk) {","highlight_start":1,"highlight_end":45},{"text":"                        return Err(BLST_ERROR::BLST_BAD_ENCODING);","highlight_start":1,"highlight_end":67},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(Self { value: sk })","highlight_start":1,"highlight_end":39},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_bytes(&self) -> [u8; 32] {","highlight_start":1,"highlight_end":49},{"text":"                SecretKey::serialize(&self)","highlight_start":1,"highlight_end":44},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_bytes(sk_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":74},{"text":"                SecretKey::deserialize(sk_in)","highlight_start":1,"highlight_end":46},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[derive(Default, Debug, Clone, Copy)]","highlight_start":1,"highlight_end":47},{"text":"        pub struct PublicKey {","highlight_start":1,"highlight_end":31},{"text":"            point: $pk_aff,","highlight_start":1,"highlight_end":28},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl PublicKey {","highlight_start":1,"highlight_end":25},{"text":"            // Core operations","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // key_validate","highlight_start":1,"highlight_end":28},{"text":"            pub fn validate(&self) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":63},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    if $pk_is_inf(&self.point) {","highlight_start":1,"highlight_end":49},{"text":"                        return Err(BLST_ERROR::BLST_PK_IS_INFINITY);","highlight_start":1,"highlight_end":69},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    if !$pk_in_group(&self.point) {","highlight_start":1,"highlight_end":52},{"text":"                        return Err(BLST_ERROR::BLST_POINT_NOT_IN_GROUP);","highlight_start":1,"highlight_end":73},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn key_validate(key: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":74},{"text":"                let pk = PublicKey::from_bytes(key)?;","highlight_start":1,"highlight_end":54},{"text":"                pk.validate()?;","highlight_start":1,"highlight_end":32},{"text":"                Ok(pk)","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_aggregate(agg_pk: &AggregatePublicKey) -> Self {","highlight_start":1,"highlight_end":73},{"text":"                let mut pk_aff = <$pk_aff>::default();","highlight_start":1,"highlight_end":55},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_to_aff(&mut pk_aff, &agg_pk.point);","highlight_start":1,"highlight_end":60},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Self { point: pk_aff }","highlight_start":1,"highlight_end":39},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Serdes","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn compress(&self) -> [u8; $pk_comp_size] {","highlight_start":1,"highlight_end":60},{"text":"                let mut pk_comp = [0u8; $pk_comp_size];","highlight_start":1,"highlight_end":56},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_comp(pk_comp.as_mut_ptr(), &self.point);","highlight_start":1,"highlight_end":65},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                pk_comp","highlight_start":1,"highlight_end":24},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn serialize(&self) -> [u8; $pk_ser_size] {","highlight_start":1,"highlight_end":60},{"text":"                let mut pk_out = [0u8; $pk_ser_size];","highlight_start":1,"highlight_end":54},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_ser(pk_out.as_mut_ptr(), &self.point);","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                pk_out","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn uncompress(pk_comp: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":76},{"text":"                if pk_comp.len() == $pk_comp_size && (pk_comp[0] & 0x80) != 0 {","highlight_start":1,"highlight_end":80},{"text":"                    let mut pk = <$pk_aff>::default();","highlight_start":1,"highlight_end":55},{"text":"                    let err = unsafe { $pk_uncomp(&mut pk, pk_comp.as_ptr()) };","highlight_start":1,"highlight_end":80},{"text":"                    if err != BLST_ERROR::BLST_SUCCESS {","highlight_start":1,"highlight_end":57},{"text":"                        return Err(err);","highlight_start":1,"highlight_end":41},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(Self { point: pk })","highlight_start":1,"highlight_end":43},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Err(BLST_ERROR::BLST_BAD_ENCODING)","highlight_start":1,"highlight_end":55},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn deserialize(pk_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":75},{"text":"                if (pk_in.len() == $pk_ser_size && (pk_in[0] & 0x80) == 0)","highlight_start":1,"highlight_end":75},{"text":"                    || (pk_in.len() == $pk_comp_size && (pk_in[0] & 0x80) != 0)","highlight_start":1,"highlight_end":80},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    let mut pk = <$pk_aff>::default();","highlight_start":1,"highlight_end":55},{"text":"                    let err = unsafe { $pk_deser(&mut pk, pk_in.as_ptr()) };","highlight_start":1,"highlight_end":77},{"text":"                    if err != BLST_ERROR::BLST_SUCCESS {","highlight_start":1,"highlight_end":57},{"text":"                        return Err(err);","highlight_start":1,"highlight_end":41},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(Self { point: pk })","highlight_start":1,"highlight_end":43},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Err(BLST_ERROR::BLST_BAD_ENCODING)","highlight_start":1,"highlight_end":55},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_bytes(pk_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":74},{"text":"                PublicKey::deserialize(pk_in)","highlight_start":1,"highlight_end":46},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_bytes(&self) -> [u8; $pk_comp_size] {","highlight_start":1,"highlight_end":60},{"text":"                self.compress()","highlight_start":1,"highlight_end":32},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Trait for equality comparisons which are equivalence relations.","highlight_start":1,"highlight_end":75},{"text":"        //","highlight_start":1,"highlight_end":11},{"text":"        // This means, that in addition to a == b and a != b being strict","highlight_start":1,"highlight_end":74},{"text":"        // inverses, the equality must be reflexive, symmetric and transitive.","highlight_start":1,"highlight_end":79},{"text":"        impl Eq for PublicKey {}","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl PartialEq for PublicKey {","highlight_start":1,"highlight_end":39},{"text":"            fn eq(&self, other: &Self) -> bool {","highlight_start":1,"highlight_end":49},{"text":"                unsafe { $pk_eq(&self.point, &other.point) }","highlight_start":1,"highlight_end":61},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[derive(Debug, Clone, Copy)]","highlight_start":1,"highlight_end":38},{"text":"        pub struct AggregatePublicKey {","highlight_start":1,"highlight_end":40},{"text":"            point: $pk,","highlight_start":1,"highlight_end":24},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl AggregatePublicKey {","highlight_start":1,"highlight_end":34},{"text":"            pub fn from_public_key(pk: &PublicKey) -> Self {","highlight_start":1,"highlight_end":61},{"text":"                let mut agg_pk = <$pk>::default();","highlight_start":1,"highlight_end":51},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_from_aff(&mut agg_pk, &pk.point);","highlight_start":1,"highlight_end":58},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Self { point: agg_pk }","highlight_start":1,"highlight_end":39},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_public_key(&self) -> PublicKey {","highlight_start":1,"highlight_end":55},{"text":"                let mut pk = <$pk_aff>::default();","highlight_start":1,"highlight_end":51},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_to_aff(&mut pk, &self.point);","highlight_start":1,"highlight_end":54},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                PublicKey { point: pk }","highlight_start":1,"highlight_end":40},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Aggregate","highlight_start":1,"highlight_end":25},{"text":"            pub fn aggregate(","highlight_start":1,"highlight_end":30},{"text":"                pks: &[&PublicKey],","highlight_start":1,"highlight_end":36},{"text":"                pks_validate: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                if pks.len() == 0 {","highlight_start":1,"highlight_end":36},{"text":"                    return Err(BLST_ERROR::BLST_AGGR_TYPE_MISMATCH);","highlight_start":1,"highlight_end":69},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if pks_validate {","highlight_start":1,"highlight_end":34},{"text":"                    pks[0].validate()?;","highlight_start":1,"highlight_end":40},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut agg_pk = AggregatePublicKey::from_public_key(pks[0]);","highlight_start":1,"highlight_end":78},{"text":"                for s in pks.iter().skip(1) {","highlight_start":1,"highlight_end":46},{"text":"                    if pks_validate {","highlight_start":1,"highlight_end":38},{"text":"                        s.validate()?;","highlight_start":1,"highlight_end":39},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        $pk_add_or_dbl_aff(","highlight_start":1,"highlight_end":44},{"text":"                            &mut agg_pk.point,","highlight_start":1,"highlight_end":47},{"text":"                            &agg_pk.point,","highlight_start":1,"highlight_end":43},{"text":"                            &s.point,","highlight_start":1,"highlight_end":38},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(agg_pk)","highlight_start":1,"highlight_end":27},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn aggregate_serialized(","highlight_start":1,"highlight_end":41},{"text":"                pks: &[&[u8]],","highlight_start":1,"highlight_end":31},{"text":"                pks_validate: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                // TODO - threading","highlight_start":1,"highlight_end":36},{"text":"                if pks.len() == 0 {","highlight_start":1,"highlight_end":36},{"text":"                    return Err(BLST_ERROR::BLST_AGGR_TYPE_MISMATCH);","highlight_start":1,"highlight_end":69},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut pk = if pks_validate {","highlight_start":1,"highlight_end":47},{"text":"                    PublicKey::key_validate(pks[0])?","highlight_start":1,"highlight_end":53},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    PublicKey::from_bytes(pks[0])?","highlight_start":1,"highlight_end":51},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut agg_pk = AggregatePublicKey::from_public_key(&pk);","highlight_start":1,"highlight_end":75},{"text":"                for s in pks.iter().skip(1) {","highlight_start":1,"highlight_end":46},{"text":"                    pk = if pks_validate {","highlight_start":1,"highlight_end":43},{"text":"                        PublicKey::key_validate(s)?","highlight_start":1,"highlight_end":52},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        PublicKey::from_bytes(s)?","highlight_start":1,"highlight_end":50},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        $pk_add_or_dbl_aff(","highlight_start":1,"highlight_end":44},{"text":"                            &mut agg_pk.point,","highlight_start":1,"highlight_end":47},{"text":"                            &agg_pk.point,","highlight_start":1,"highlight_end":43},{"text":"                            &pk.point,","highlight_start":1,"highlight_end":39},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(agg_pk)","highlight_start":1,"highlight_end":27},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn add_aggregate(&mut self, agg_pk: &AggregatePublicKey) {","highlight_start":1,"highlight_end":75},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_add_or_dbl(&mut self.point, &self.point, &agg_pk.point);","highlight_start":1,"highlight_end":81},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn add_public_key(","highlight_start":1,"highlight_end":35},{"text":"                &mut self,","highlight_start":1,"highlight_end":27},{"text":"                pk: &PublicKey,","highlight_start":1,"highlight_end":32},{"text":"                pk_validate: bool,","highlight_start":1,"highlight_end":35},{"text":"            ) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":42},{"text":"                if pk_validate {","highlight_start":1,"highlight_end":33},{"text":"                    pk.validate()?;","highlight_start":1,"highlight_end":36},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_add_or_dbl_aff(&mut self.point, &self.point, &pk.point);","highlight_start":1,"highlight_end":81},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[derive(Debug, Clone, Copy)]","highlight_start":1,"highlight_end":38},{"text":"        pub struct Signature {","highlight_start":1,"highlight_end":31},{"text":"            point: $sig_aff,","highlight_start":1,"highlight_end":29},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl Signature {","highlight_start":1,"highlight_end":25},{"text":"            // sig_infcheck, check for infinity, is a way to avoid going","highlight_start":1,"highlight_end":73},{"text":"            // into resource-consuming verification. Passing 'false' is","highlight_start":1,"highlight_end":72},{"text":"            // always cryptographically safe, but application might want","highlight_start":1,"highlight_end":73},{"text":"            // to guard against obviously bogus individual[!] signatures.","highlight_start":1,"highlight_end":74},{"text":"            pub fn validate(","highlight_start":1,"highlight_end":29},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_infcheck: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":42},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    if sig_infcheck && $sig_is_inf(&self.point) {","highlight_start":1,"highlight_end":66},{"text":"                        return Err(BLST_ERROR::BLST_PK_IS_INFINITY);","highlight_start":1,"highlight_end":69},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    if !$sig_in_group(&self.point) {","highlight_start":1,"highlight_end":53},{"text":"                        return Err(BLST_ERROR::BLST_POINT_NOT_IN_GROUP);","highlight_start":1,"highlight_end":73},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn sig_validate(","highlight_start":1,"highlight_end":33},{"text":"                sig: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                sig_infcheck: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                let sig = Signature::from_bytes(sig)?;","highlight_start":1,"highlight_end":55},{"text":"                sig.validate(sig_infcheck)?;","highlight_start":1,"highlight_end":45},{"text":"                Ok(sig)","highlight_start":1,"highlight_end":24},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn verify(","highlight_start":1,"highlight_end":27},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"                msg: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                aug: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pk: &PublicKey,","highlight_start":1,"highlight_end":32},{"text":"                pk_validate: bool,","highlight_start":1,"highlight_end":35},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                let aug_msg = [aug, msg].concat();","highlight_start":1,"highlight_end":51},{"text":"                self.aggregate_verify(","highlight_start":1,"highlight_end":39},{"text":"                    sig_groupcheck,","highlight_start":1,"highlight_end":36},{"text":"                    &[aug_msg.as_slice()],","highlight_start":1,"highlight_end":43},{"text":"                    dst,","highlight_start":1,"highlight_end":25},{"text":"                    &[pk],","highlight_start":1,"highlight_end":27},{"text":"                    pk_validate,","highlight_start":1,"highlight_end":33},{"text":"                )","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn aggregate_verify(","highlight_start":1,"highlight_end":37},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"                msgs: &[&[u8]],","highlight_start":1,"highlight_end":32},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pks: &[&PublicKey],","highlight_start":1,"highlight_end":36},{"text":"                pks_validate: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                let n_elems = pks.len();","highlight_start":1,"highlight_end":41},{"text":"                if n_elems == 0 || msgs.len() != n_elems {","highlight_start":1,"highlight_end":59},{"text":"                    return BLST_ERROR::BLST_VERIFY_FAIL;","highlight_start":1,"highlight_end":57},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // TODO - check msg uniqueness?","highlight_start":1,"highlight_end":48},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // let pool = da_pool();","highlight_start":1,"highlight_end":41},{"text":"                let (tx, rx) = channel();","highlight_start":1,"highlight_end":42},{"text":"                let counter = Arc::new(AtomicUsize::new(0));","highlight_start":1,"highlight_end":61},{"text":"                let valid = Arc::new(AtomicBool::new(true));","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Bypass 'lifetime limitations by brute force. It works,","highlight_start":1,"highlight_end":74},{"text":"                // because we explicitly join the threads...","highlight_start":1,"highlight_end":61},{"text":"                let raw_pks = unsafe {","highlight_start":1,"highlight_end":39},{"text":"                    transmute::<*const &PublicKey, usize>(pks.as_ptr())","highlight_start":1,"highlight_end":72},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let raw_msgs =","highlight_start":1,"highlight_end":31},{"text":"                    unsafe { transmute::<*const &[u8], usize>(msgs.as_ptr()) };","highlight_start":1,"highlight_end":80},{"text":"                let dst =","highlight_start":1,"highlight_end":26},{"text":"                    unsafe { slice::from_raw_parts(dst.as_ptr(), dst.len()) };","highlight_start":1,"highlight_end":79},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // let n_workers = std::cmp::min(pool.max_count(), n_elems);","highlight_start":1,"highlight_end":77},{"text":"                // for _ in 0..n_workers {","highlight_start":1,"highlight_end":43},{"text":"                    let tx = tx.clone();","highlight_start":1,"highlight_end":41},{"text":"                    let counter = counter.clone();","highlight_start":1,"highlight_end":51},{"text":"                    let valid = valid.clone();","highlight_start":1,"highlight_end":47},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // pool.execute(move || {","highlight_start":1,"highlight_end":46},{"text":"                        let mut pairing = Pairing::new($hash_or_encode, dst);","highlight_start":1,"highlight_end":78},{"text":"                        // reconstruct input slices...","highlight_start":1,"highlight_end":55},{"text":"                        let msgs = unsafe {","highlight_start":1,"highlight_end":44},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &[u8]>(raw_msgs),","highlight_start":1,"highlight_end":76},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                        let pks = unsafe {","highlight_start":1,"highlight_end":43},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &PublicKey>(raw_pks),","highlight_start":1,"highlight_end":80},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        while valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":62},{"text":"                            let work = counter.fetch_add(1, Ordering::Relaxed);","highlight_start":1,"highlight_end":80},{"text":"                            if work >= n_elems {","highlight_start":1,"highlight_end":49},{"text":"                                break;","highlight_start":1,"highlight_end":39},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                            if pairing.aggregate(","highlight_start":1,"highlight_end":50},{"text":"                                &pks[work].point,","highlight_start":1,"highlight_end":50},{"text":"                                pks_validate,","highlight_start":1,"highlight_end":46},{"text":"                                &unsafe { ptr::null::<$sig_aff>().as_ref() },","highlight_start":1,"highlight_end":78},{"text":"                                false,","highlight_start":1,"highlight_end":39},{"text":"                                &msgs[work],","highlight_start":1,"highlight_end":45},{"text":"                                &[],","highlight_start":1,"highlight_end":37},{"text":"                            ) != BLST_ERROR::BLST_SUCCESS","highlight_start":1,"highlight_end":58},{"text":"                            {","highlight_start":1,"highlight_end":30},{"text":"                                valid.store(false, Ordering::Relaxed);","highlight_start":1,"highlight_end":71},{"text":"                                break;","highlight_start":1,"highlight_end":39},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        if valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":59},{"text":"                            pairing.commit();","highlight_start":1,"highlight_end":46},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        tx.send(pairing).expect(\"disaster\");","highlight_start":1,"highlight_end":61},{"text":"                    // });","highlight_start":1,"highlight_end":27},{"text":"                // }","highlight_start":1,"highlight_end":21},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                if sig_groupcheck && valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":69},{"text":"                    match self.validate(false) {","highlight_start":1,"highlight_end":49},{"text":"                        Err(_err) => valid.store(false, Ordering::Relaxed),","highlight_start":1,"highlight_end":76},{"text":"                        _ => (),","highlight_start":1,"highlight_end":33},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut gtsig = blst_fp12::default();","highlight_start":1,"highlight_end":54},{"text":"                if valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":51},{"text":"                    Pairing::aggregated(&mut gtsig, &self.point);","highlight_start":1,"highlight_end":66},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut acc = rx.recv().unwrap();","highlight_start":1,"highlight_end":50},{"text":"                // for _ in 1..n_workers {","highlight_start":1,"highlight_end":43},{"text":"                    // acc.merge(&rx.recv().unwrap());","highlight_start":1,"highlight_end":55},{"text":"                // }","highlight_start":1,"highlight_end":21},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                if valid.load(Ordering::Relaxed)","highlight_start":1,"highlight_end":49},{"text":"                    && acc.finalverify(Some(&gtsig))","highlight_start":1,"highlight_end":53},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    BLST_ERROR::BLST_SUCCESS","highlight_start":1,"highlight_end":45},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    BLST_ERROR::BLST_VERIFY_FAIL","highlight_start":1,"highlight_end":49},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // pks are assumed to be verified for proof of possession,","highlight_start":1,"highlight_end":71},{"text":"            // which implies that they are already group-checked","highlight_start":1,"highlight_end":65},{"text":"            pub fn fast_aggregate_verify(","highlight_start":1,"highlight_end":42},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"                msg: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pks: &[&PublicKey],","highlight_start":1,"highlight_end":36},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                let agg_pk = match AggregatePublicKey::aggregate(pks, false) {","highlight_start":1,"highlight_end":79},{"text":"                    Ok(agg_sig) => agg_sig,","highlight_start":1,"highlight_end":44},{"text":"                    Err(err) => return err,","highlight_start":1,"highlight_end":44},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let pk = agg_pk.to_public_key();","highlight_start":1,"highlight_end":49},{"text":"                self.aggregate_verify(","highlight_start":1,"highlight_end":39},{"text":"                    sig_groupcheck,","highlight_start":1,"highlight_end":36},{"text":"                    &[msg],","highlight_start":1,"highlight_end":28},{"text":"                    dst,","highlight_start":1,"highlight_end":25},{"text":"                    &[&pk],","highlight_start":1,"highlight_end":28},{"text":"                    false,","highlight_start":1,"highlight_end":27},{"text":"                )","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn fast_aggregate_verify_pre_aggregated(","highlight_start":1,"highlight_end":57},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"                msg: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pk: &PublicKey,","highlight_start":1,"highlight_end":32},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                self.aggregate_verify(sig_groupcheck, &[msg], dst, &[pk], false)","highlight_start":1,"highlight_end":81},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // https://ethresear.ch/t/fast-verification-of-multiple-bls-signatures/5407","highlight_start":1,"highlight_end":88},{"text":"            pub fn verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":57},{"text":"                msgs: &[&[u8]],","highlight_start":1,"highlight_end":32},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pks: &[&PublicKey],","highlight_start":1,"highlight_end":36},{"text":"                pks_validate: bool,","highlight_start":1,"highlight_end":36},{"text":"                sigs: &[&Signature],","highlight_start":1,"highlight_end":37},{"text":"                sigs_groupcheck: bool,","highlight_start":1,"highlight_end":39},{"text":"                rands: &[blst_scalar],","highlight_start":1,"highlight_end":39},{"text":"                rand_bits: usize,","highlight_start":1,"highlight_end":34},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                let n_elems = pks.len();","highlight_start":1,"highlight_end":41},{"text":"                if n_elems == 0","highlight_start":1,"highlight_end":32},{"text":"                    || msgs.len() != n_elems","highlight_start":1,"highlight_end":45},{"text":"                    || sigs.len() != n_elems","highlight_start":1,"highlight_end":45},{"text":"                    || rands.len() != n_elems","highlight_start":1,"highlight_end":46},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    return BLST_ERROR::BLST_VERIFY_FAIL;","highlight_start":1,"highlight_end":57},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // TODO - check msg uniqueness?","highlight_start":1,"highlight_end":48},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // let pool = da_pool();","highlight_start":1,"highlight_end":41},{"text":"                let (tx, rx) = channel();","highlight_start":1,"highlight_end":42},{"text":"                let counter = Arc::new(AtomicUsize::new(0));","highlight_start":1,"highlight_end":61},{"text":"                let valid = Arc::new(AtomicBool::new(true));","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Bypass 'lifetime limitations by brute force. It works,","highlight_start":1,"highlight_end":74},{"text":"                // because we explicitly join the threads...","highlight_start":1,"highlight_end":61},{"text":"                let raw_pks = unsafe {","highlight_start":1,"highlight_end":39},{"text":"                    transmute::<*const &PublicKey, usize>(pks.as_ptr())","highlight_start":1,"highlight_end":72},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let raw_sigs = unsafe {","highlight_start":1,"highlight_end":40},{"text":"                    transmute::<*const &Signature, usize>(sigs.as_ptr())","highlight_start":1,"highlight_end":73},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let raw_rands = unsafe {","highlight_start":1,"highlight_end":41},{"text":"                    transmute::<*const blst_scalar, usize>(rands.as_ptr())","highlight_start":1,"highlight_end":75},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let raw_msgs =","highlight_start":1,"highlight_end":31},{"text":"                    unsafe { transmute::<*const &[u8], usize>(msgs.as_ptr()) };","highlight_start":1,"highlight_end":80},{"text":"                let dst =","highlight_start":1,"highlight_end":26},{"text":"                    unsafe { slice::from_raw_parts(dst.as_ptr(), dst.len()) };","highlight_start":1,"highlight_end":79},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // let n_workers = std::cmp::min(pool.max_count(), n_elems);","highlight_start":1,"highlight_end":77},{"text":"                //for _ in 0..n_workers {","highlight_start":1,"highlight_end":42},{"text":"                    let tx = tx.clone();","highlight_start":1,"highlight_end":41},{"text":"                    let counter = counter.clone();","highlight_start":1,"highlight_end":51},{"text":"                    let valid = valid.clone();","highlight_start":1,"highlight_end":47},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // pool.execute(move || {","highlight_start":1,"highlight_end":46},{"text":"                        let mut pairing = Pairing::new($hash_or_encode, dst);","highlight_start":1,"highlight_end":78},{"text":"                        // reconstruct input slices...","highlight_start":1,"highlight_end":55},{"text":"                        let rands = unsafe {","highlight_start":1,"highlight_end":45},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const blst_scalar>(","highlight_start":1,"highlight_end":72},{"text":"                                    raw_rands,","highlight_start":1,"highlight_end":47},{"text":"                                ),","highlight_start":1,"highlight_end":35},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                        let msgs = unsafe {","highlight_start":1,"highlight_end":44},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &[u8]>(raw_msgs),","highlight_start":1,"highlight_end":76},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                        let sigs = unsafe {","highlight_start":1,"highlight_end":44},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &Signature>(raw_sigs),","highlight_start":1,"highlight_end":81},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                        let pks = unsafe {","highlight_start":1,"highlight_end":43},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &PublicKey>(raw_pks),","highlight_start":1,"highlight_end":80},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        // TODO - engage multi-point mul-n-add for larger","highlight_start":1,"highlight_end":74},{"text":"                        // amount of inputs...","highlight_start":1,"highlight_end":47},{"text":"                        while valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":62},{"text":"                            let work = counter.fetch_add(1, Ordering::Relaxed);","highlight_start":1,"highlight_end":80},{"text":"                            if work >= n_elems {","highlight_start":1,"highlight_end":49},{"text":"                                break;","highlight_start":1,"highlight_end":39},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            if pairing.mul_n_aggregate(","highlight_start":1,"highlight_end":56},{"text":"                                &pks[work].point,","highlight_start":1,"highlight_end":50},{"text":"                                pks_validate,","highlight_start":1,"highlight_end":46},{"text":"                                &sigs[work].point,","highlight_start":1,"highlight_end":51},{"text":"                                sigs_groupcheck,","highlight_start":1,"highlight_end":49},{"text":"                                &rands[work].b,","highlight_start":1,"highlight_end":48},{"text":"                                rand_bits,","highlight_start":1,"highlight_end":43},{"text":"                                msgs[work],","highlight_start":1,"highlight_end":44},{"text":"                                &[],","highlight_start":1,"highlight_end":37},{"text":"                            ) != BLST_ERROR::BLST_SUCCESS","highlight_start":1,"highlight_end":58},{"text":"                            {","highlight_start":1,"highlight_end":30},{"text":"                                valid.store(false, Ordering::Relaxed);","highlight_start":1,"highlight_end":71},{"text":"                                break;","highlight_start":1,"highlight_end":39},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        if valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":59},{"text":"                            pairing.commit();","highlight_start":1,"highlight_end":46},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        tx.send(pairing).expect(\"disaster\");","highlight_start":1,"highlight_end":61},{"text":"                    // });","highlight_start":1,"highlight_end":27},{"text":"                //}","highlight_start":1,"highlight_end":20},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut acc = rx.recv().unwrap();","highlight_start":1,"highlight_end":50},{"text":"                //for _ in 1..n_workers {","highlight_start":1,"highlight_end":42},{"text":"                    // acc.merge(&rx.recv().unwrap());","highlight_start":1,"highlight_end":55},{"text":"                //}","highlight_start":1,"highlight_end":20},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                if valid.load(Ordering::Relaxed) && acc.finalverify(None) {","highlight_start":1,"highlight_end":76},{"text":"                    BLST_ERROR::BLST_SUCCESS","highlight_start":1,"highlight_end":45},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    BLST_ERROR::BLST_VERIFY_FAIL","highlight_start":1,"highlight_end":49},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_aggregate(agg_sig: &AggregateSignature) -> Self {","highlight_start":1,"highlight_end":74},{"text":"                let mut sig_aff = <$sig_aff>::default();","highlight_start":1,"highlight_end":57},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_to_aff(&mut sig_aff, &agg_sig.point);","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Self { point: sig_aff }","highlight_start":1,"highlight_end":40},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn compress(&self) -> [u8; $sig_comp_size] {","highlight_start":1,"highlight_end":61},{"text":"                let mut sig_comp = [0; $sig_comp_size];","highlight_start":1,"highlight_end":56},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_comp(sig_comp.as_mut_ptr(), &self.point);","highlight_start":1,"highlight_end":67},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                sig_comp","highlight_start":1,"highlight_end":25},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn serialize(&self) -> [u8; $sig_ser_size] {","highlight_start":1,"highlight_end":61},{"text":"                let mut sig_out = [0; $sig_ser_size];","highlight_start":1,"highlight_end":54},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_ser(sig_out.as_mut_ptr(), &self.point);","highlight_start":1,"highlight_end":65},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                sig_out","highlight_start":1,"highlight_end":24},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn uncompress(sig_comp: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":77},{"text":"                if sig_comp.len() == $sig_comp_size && (sig_comp[0] & 0x80) != 0","highlight_start":1,"highlight_end":81},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    let mut sig = <$sig_aff>::default();","highlight_start":1,"highlight_end":57},{"text":"                    let err =","highlight_start":1,"highlight_end":30},{"text":"                        unsafe { $sig_uncomp(&mut sig, sig_comp.as_ptr()) };","highlight_start":1,"highlight_end":77},{"text":"                    if err != BLST_ERROR::BLST_SUCCESS {","highlight_start":1,"highlight_end":57},{"text":"                        return Err(err);","highlight_start":1,"highlight_end":41},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(Self { point: sig })","highlight_start":1,"highlight_end":44},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Err(BLST_ERROR::BLST_BAD_ENCODING)","highlight_start":1,"highlight_end":55},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn deserialize(sig_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":76},{"text":"                if (sig_in.len() == $sig_ser_size && (sig_in[0] & 0x80) == 0)","highlight_start":1,"highlight_end":78},{"text":"                    || (sig_in.len() == $sig_comp_size","highlight_start":1,"highlight_end":55},{"text":"                        && (sig_in[0] & 0x80) != 0)","highlight_start":1,"highlight_end":52},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    let mut sig = <$sig_aff>::default();","highlight_start":1,"highlight_end":57},{"text":"                    let err = unsafe { $sig_deser(&mut sig, sig_in.as_ptr()) };","highlight_start":1,"highlight_end":80},{"text":"                    if err != BLST_ERROR::BLST_SUCCESS {","highlight_start":1,"highlight_end":57},{"text":"                        return Err(err);","highlight_start":1,"highlight_end":41},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(Self { point: sig })","highlight_start":1,"highlight_end":44},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Err(BLST_ERROR::BLST_BAD_ENCODING)","highlight_start":1,"highlight_end":55},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_bytes(sig_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":75},{"text":"                Signature::deserialize(sig_in)","highlight_start":1,"highlight_end":47},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_bytes(&self) -> [u8; $sig_comp_size] {","highlight_start":1,"highlight_end":61},{"text":"                self.compress()","highlight_start":1,"highlight_end":32},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn subgroup_check(&self) -> bool {","highlight_start":1,"highlight_end":51},{"text":"                unsafe { $sig_in_group(&self.point) }","highlight_start":1,"highlight_end":54},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Trait for equality comparisons which are equivalence relations.","highlight_start":1,"highlight_end":75},{"text":"        //","highlight_start":1,"highlight_end":11},{"text":"        // This means, that in addition to a == b and a != b being strict","highlight_start":1,"highlight_end":74},{"text":"        // inverses, the equality must be reflexive, symmetric and transitive.","highlight_start":1,"highlight_end":79},{"text":"        impl Eq for Signature {}","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl PartialEq for Signature {","highlight_start":1,"highlight_end":39},{"text":"            fn eq(&self, other: &Self) -> bool {","highlight_start":1,"highlight_end":49},{"text":"                unsafe { $sig_eq(&self.point, &other.point) }","highlight_start":1,"highlight_end":62},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[derive(Debug, Clone, Copy)]","highlight_start":1,"highlight_end":38},{"text":"        pub struct AggregateSignature {","highlight_start":1,"highlight_end":40},{"text":"            point: $sig,","highlight_start":1,"highlight_end":25},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl AggregateSignature {","highlight_start":1,"highlight_end":34},{"text":"            pub fn validate(&self) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":63},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    if !$sig_aggr_in_group(&self.point) {","highlight_start":1,"highlight_end":58},{"text":"                        return Err(BLST_ERROR::BLST_POINT_NOT_IN_GROUP);","highlight_start":1,"highlight_end":73},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_signature(sig: &Signature) -> Self {","highlight_start":1,"highlight_end":61},{"text":"                let mut agg_sig = <$sig>::default();","highlight_start":1,"highlight_end":53},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_from_aff(&mut agg_sig, &sig.point);","highlight_start":1,"highlight_end":61},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Self { point: agg_sig }","highlight_start":1,"highlight_end":40},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_signature(&self) -> Signature {","highlight_start":1,"highlight_end":54},{"text":"                let mut sig = <$sig_aff>::default();","highlight_start":1,"highlight_end":53},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_to_aff(&mut sig, &self.point);","highlight_start":1,"highlight_end":56},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Signature { point: sig }","highlight_start":1,"highlight_end":41},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Aggregate","highlight_start":1,"highlight_end":25},{"text":"            pub fn aggregate(","highlight_start":1,"highlight_end":30},{"text":"                sigs: &[&Signature],","highlight_start":1,"highlight_end":37},{"text":"                sigs_groupcheck: bool,","highlight_start":1,"highlight_end":39},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                if sigs.len() == 0 {","highlight_start":1,"highlight_end":37},{"text":"                    return Err(BLST_ERROR::BLST_AGGR_TYPE_MISMATCH);","highlight_start":1,"highlight_end":69},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if sigs_groupcheck {","highlight_start":1,"highlight_end":37},{"text":"                    // We can't actually judge if input is individual or","highlight_start":1,"highlight_end":73},{"text":"                    // aggregated signature, so we can't enforce infinitiy","highlight_start":1,"highlight_end":75},{"text":"                    // check.","highlight_start":1,"highlight_end":30},{"text":"                    sigs[0].validate(false)?;","highlight_start":1,"highlight_end":46},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut agg_sig = AggregateSignature::from_signature(sigs[0]);","highlight_start":1,"highlight_end":79},{"text":"                for s in sigs.iter().skip(1) {","highlight_start":1,"highlight_end":47},{"text":"                    if sigs_groupcheck {","highlight_start":1,"highlight_end":41},{"text":"                        s.validate(false)?;","highlight_start":1,"highlight_end":44},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        $sig_add_or_dbl_aff(","highlight_start":1,"highlight_end":45},{"text":"                            &mut agg_sig.point,","highlight_start":1,"highlight_end":48},{"text":"                            &agg_sig.point,","highlight_start":1,"highlight_end":44},{"text":"                            &s.point,","highlight_start":1,"highlight_end":38},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(agg_sig)","highlight_start":1,"highlight_end":28},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn aggregate_serialized(","highlight_start":1,"highlight_end":41},{"text":"                sigs: &[&[u8]],","highlight_start":1,"highlight_end":32},{"text":"                sigs_groupcheck: bool,","highlight_start":1,"highlight_end":39},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                // TODO - threading","highlight_start":1,"highlight_end":36},{"text":"                if sigs.len() == 0 {","highlight_start":1,"highlight_end":37},{"text":"                    return Err(BLST_ERROR::BLST_AGGR_TYPE_MISMATCH);","highlight_start":1,"highlight_end":69},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut sig = if sigs_groupcheck {","highlight_start":1,"highlight_end":51},{"text":"                    Signature::sig_validate(sigs[0], false)?","highlight_start":1,"highlight_end":61},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Signature::from_bytes(sigs[0])?","highlight_start":1,"highlight_end":52},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut agg_sig = AggregateSignature::from_signature(&sig);","highlight_start":1,"highlight_end":76},{"text":"                for s in sigs.iter().skip(1) {","highlight_start":1,"highlight_end":47},{"text":"                    sig = if sigs_groupcheck {","highlight_start":1,"highlight_end":47},{"text":"                        Signature::sig_validate(s, false)?","highlight_start":1,"highlight_end":59},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        Signature::from_bytes(s)?","highlight_start":1,"highlight_end":50},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        $sig_add_or_dbl_aff(","highlight_start":1,"highlight_end":45},{"text":"                            &mut agg_sig.point,","highlight_start":1,"highlight_end":48},{"text":"                            &agg_sig.point,","highlight_start":1,"highlight_end":44},{"text":"                            &sig.point,","highlight_start":1,"highlight_end":40},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(agg_sig)","highlight_start":1,"highlight_end":28},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn add_aggregate(&mut self, agg_sig: &AggregateSignature) {","highlight_start":1,"highlight_end":76},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_add_or_dbl(","highlight_start":1,"highlight_end":37},{"text":"                        &mut self.point,","highlight_start":1,"highlight_end":41},{"text":"                        &self.point,","highlight_start":1,"highlight_end":37},{"text":"                        &agg_sig.point,","highlight_start":1,"highlight_end":40},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn add_signature(","highlight_start":1,"highlight_end":34},{"text":"                &mut self,","highlight_start":1,"highlight_end":27},{"text":"                sig: &Signature,","highlight_start":1,"highlight_end":33},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"            ) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":42},{"text":"                if sig_groupcheck {","highlight_start":1,"highlight_end":36},{"text":"                    sig.validate(false)?;","highlight_start":1,"highlight_end":42},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_add_or_dbl_aff(","highlight_start":1,"highlight_end":41},{"text":"                        &mut self.point,","highlight_start":1,"highlight_end":41},{"text":"                        &self.point,","highlight_start":1,"highlight_end":37},{"text":"                        &sig.point,","highlight_start":1,"highlight_end":36},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn subgroup_check(&self) -> bool {","highlight_start":1,"highlight_end":51},{"text":"                unsafe { $sig_aggr_in_group(&self.point) }","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[cfg(test)]","highlight_start":1,"highlight_end":21},{"text":"        mod tests {","highlight_start":1,"highlight_end":20},{"text":"            use super::*;","highlight_start":1,"highlight_end":26},{"text":"            use rand::{RngCore, SeedableRng};","highlight_start":1,"highlight_end":46},{"text":"            use rand_chacha::ChaCha20Rng;","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Testing only - do not use for production","highlight_start":1,"highlight_end":56},{"text":"            pub fn gen_random_key(","highlight_start":1,"highlight_end":35},{"text":"                rng: &mut rand_chacha::ChaCha20Rng,","highlight_start":1,"highlight_end":52},{"text":"            ) -> SecretKey {","highlight_start":1,"highlight_end":29},{"text":"                let mut ikm = [0u8; 32];","highlight_start":1,"highlight_end":41},{"text":"                rng.fill_bytes(&mut ikm);","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut sk = <blst_scalar>::default();","highlight_start":1,"highlight_end":55},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    blst_keygen(&mut sk, ikm.as_ptr(), 32, ptr::null(), 0);","highlight_start":1,"highlight_end":76},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                SecretKey { value: sk }","highlight_start":1,"highlight_end":40},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[test]","highlight_start":1,"highlight_end":20},{"text":"            fn test_sign() {","highlight_start":1,"highlight_end":29},{"text":"                let ikm: [u8; 32] = [","highlight_start":1,"highlight_end":38},{"text":"                    0x93, 0xad, 0x7e, 0x65, 0xde, 0xad, 0x05, 0x2a, 0x08, 0x3a,","highlight_start":1,"highlight_end":80},{"text":"                    0x91, 0x0c, 0x8b, 0x72, 0x85, 0x91, 0x46, 0x4c, 0xca, 0x56,","highlight_start":1,"highlight_end":80},{"text":"                    0x60, 0x5b, 0xb0, 0x56, 0xed, 0xfe, 0x2b, 0x60, 0xa6, 0x3c,","highlight_start":1,"highlight_end":80},{"text":"                    0x48, 0x99,","highlight_start":1,"highlight_end":32},{"text":"                ];","highlight_start":1,"highlight_end":19},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sk = SecretKey::key_gen(&ikm, &[]).unwrap();","highlight_start":1,"highlight_end":65},{"text":"                let pk = sk.sk_to_pk();","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let dst = b\"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_\";","highlight_start":1,"highlight_end":74},{"text":"                let msg = b\"hello foo\";","highlight_start":1,"highlight_end":40},{"text":"                let sig = sk.sign(msg, dst, &[]);","highlight_start":1,"highlight_end":50},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let err = sig.verify(true, msg, dst, &[], &pk, true);","highlight_start":1,"highlight_end":70},{"text":"                assert_eq!(err, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[test]","highlight_start":1,"highlight_end":20},{"text":"            fn test_aggregate() {","highlight_start":1,"highlight_end":34},{"text":"                let num_msgs = 10;","highlight_start":1,"highlight_end":35},{"text":"                let dst = b\"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_\";","highlight_start":1,"highlight_end":74},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let seed = [0u8; 32];","highlight_start":1,"highlight_end":38},{"text":"                let mut rng = ChaCha20Rng::from_seed(seed);","highlight_start":1,"highlight_end":60},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sks: Vec<_> =","highlight_start":1,"highlight_end":34},{"text":"                    (0..num_msgs).map(|_| gen_random_key(&mut rng)).collect();","highlight_start":1,"highlight_end":79},{"text":"                let pks =","highlight_start":1,"highlight_end":26},{"text":"                    sks.iter().map(|sk| sk.sk_to_pk()).collect::<Vec<_>>();","highlight_start":1,"highlight_end":76},{"text":"                let pks_refs: Vec<&PublicKey> =","highlight_start":1,"highlight_end":48},{"text":"                    pks.iter().map(|pk| pk).collect();","highlight_start":1,"highlight_end":55},{"text":"                let pks_rev: Vec<&PublicKey> =","highlight_start":1,"highlight_end":47},{"text":"                    pks.iter().rev().map(|pk| pk).collect();","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_comp = pks[0].compress();","highlight_start":1,"highlight_end":49},{"text":"                let pk_uncomp = PublicKey::uncompress(&pk_comp);","highlight_start":1,"highlight_end":65},{"text":"                assert_eq!(pk_uncomp.is_ok(), true);","highlight_start":1,"highlight_end":53},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut msgs: Vec<Vec<u8>> = vec![vec![]; num_msgs];","highlight_start":1,"highlight_end":69},{"text":"                for i in 0..num_msgs {","highlight_start":1,"highlight_end":39},{"text":"                    let msg_len = (rng.next_u64() & 0x3F) + 1;","highlight_start":1,"highlight_end":63},{"text":"                    msgs[i] = vec![0u8; msg_len as usize];","highlight_start":1,"highlight_end":59},{"text":"                    rng.fill_bytes(&mut msgs[i]);","highlight_start":1,"highlight_end":50},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let msgs_refs: Vec<&[u8]> =","highlight_start":1,"highlight_end":44},{"text":"                    msgs.iter().map(|m| m.as_slice()).collect();","highlight_start":1,"highlight_end":65},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sigs = sks","highlight_start":1,"highlight_end":31},{"text":"                    .iter()","highlight_start":1,"highlight_end":28},{"text":"                    .zip(msgs.iter())","highlight_start":1,"highlight_end":38},{"text":"                    .map(|(sk, m)| (sk.sign(m, dst, &[])))","highlight_start":1,"highlight_end":59},{"text":"                    .collect::<Vec<Signature>>();","highlight_start":1,"highlight_end":50},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut errs = sigs","highlight_start":1,"highlight_end":36},{"text":"                    .iter()","highlight_start":1,"highlight_end":28},{"text":"                    .zip(msgs.iter())","highlight_start":1,"highlight_end":38},{"text":"                    .zip(pks.iter())","highlight_start":1,"highlight_end":37},{"text":"                    .map(|((s, m), pk)| (s.verify(true, m, dst, &[], pk, true)))","highlight_start":1,"highlight_end":81},{"text":"                    .collect::<Vec<BLST_ERROR>>();","highlight_start":1,"highlight_end":51},{"text":"                assert_eq!(errs, vec![BLST_ERROR::BLST_SUCCESS; num_msgs]);","highlight_start":1,"highlight_end":76},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Swap message/public key pairs to create bad signature","highlight_start":1,"highlight_end":73},{"text":"                errs = sigs","highlight_start":1,"highlight_end":28},{"text":"                    .iter()","highlight_start":1,"highlight_end":28},{"text":"                    .zip(msgs.iter())","highlight_start":1,"highlight_end":38},{"text":"                    .zip(pks.iter().rev())","highlight_start":1,"highlight_end":43},{"text":"                    .map(|((s, m), pk)| (s.verify(true, m, dst, &[], pk, true)))","highlight_start":1,"highlight_end":81},{"text":"                    .collect::<Vec<BLST_ERROR>>();","highlight_start":1,"highlight_end":51},{"text":"                assert_ne!(errs, vec![BLST_ERROR::BLST_SUCCESS; num_msgs]);","highlight_start":1,"highlight_end":76},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sig_refs =","highlight_start":1,"highlight_end":31},{"text":"                    sigs.iter().map(|s| s).collect::<Vec<&Signature>>();","highlight_start":1,"highlight_end":73},{"text":"                let agg = match AggregateSignature::aggregate(&sig_refs, true) {","highlight_start":1,"highlight_end":81},{"text":"                    Ok(agg) => agg,","highlight_start":1,"highlight_end":36},{"text":"                    Err(err) => panic!(\"aggregate failure: {:?}\", err),","highlight_start":1,"highlight_end":72},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let agg_sig = agg.to_signature();","highlight_start":1,"highlight_end":50},{"text":"                let mut result = agg_sig","highlight_start":1,"highlight_end":41},{"text":"                    .aggregate_verify(false, &msgs_refs, dst, &pks_refs, false);","highlight_start":1,"highlight_end":81},{"text":"                assert_eq!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Swap message/public key pairs to create bad signature","highlight_start":1,"highlight_end":73},{"text":"                result = agg_sig","highlight_start":1,"highlight_end":33},{"text":"                    .aggregate_verify(false, &msgs_refs, dst, &pks_rev, false);","highlight_start":1,"highlight_end":80},{"text":"                assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[test]","highlight_start":1,"highlight_end":20},{"text":"            fn test_multiple_agg_sigs() {","highlight_start":1,"highlight_end":42},{"text":"                let dst = b\"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_\";","highlight_start":1,"highlight_end":74},{"text":"                let num_pks_per_sig = 10;","highlight_start":1,"highlight_end":42},{"text":"                let num_sigs = 10;","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let seed = [0u8; 32];","highlight_start":1,"highlight_end":38},{"text":"                let mut rng = ChaCha20Rng::from_seed(seed);","highlight_start":1,"highlight_end":60},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut msgs: Vec<Vec<u8>> = vec![vec![]; num_sigs];","highlight_start":1,"highlight_end":69},{"text":"                let mut sigs: Vec<Signature> = Vec::with_capacity(num_sigs);","highlight_start":1,"highlight_end":77},{"text":"                let mut pks: Vec<PublicKey> = Vec::with_capacity(num_sigs);","highlight_start":1,"highlight_end":76},{"text":"                let mut rands: Vec<blst_scalar> = Vec::with_capacity(num_sigs);","highlight_start":1,"highlight_end":80},{"text":"                for i in 0..num_sigs {","highlight_start":1,"highlight_end":39},{"text":"                    // Create public keys","highlight_start":1,"highlight_end":42},{"text":"                    let sks_i: Vec<_> = (0..num_pks_per_sig)","highlight_start":1,"highlight_end":61},{"text":"                        .map(|_| gen_random_key(&mut rng))","highlight_start":1,"highlight_end":59},{"text":"                        .collect();","highlight_start":1,"highlight_end":36},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let pks_i = sks_i","highlight_start":1,"highlight_end":38},{"text":"                        .iter()","highlight_start":1,"highlight_end":32},{"text":"                        .map(|sk| sk.sk_to_pk())","highlight_start":1,"highlight_end":49},{"text":"                        .collect::<Vec<_>>();","highlight_start":1,"highlight_end":46},{"text":"                    let pks_refs_i: Vec<&PublicKey> =","highlight_start":1,"highlight_end":54},{"text":"                        pks_i.iter().map(|pk| pk).collect();","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Create random message for pks to all sign","highlight_start":1,"highlight_end":65},{"text":"                    let msg_len = (rng.next_u64() & 0x3F) + 1;","highlight_start":1,"highlight_end":63},{"text":"                    msgs[i] = vec![0u8; msg_len as usize];","highlight_start":1,"highlight_end":59},{"text":"                    rng.fill_bytes(&mut msgs[i]);","highlight_start":1,"highlight_end":50},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Generate signature for each key pair","highlight_start":1,"highlight_end":60},{"text":"                    let sigs_i = sks_i","highlight_start":1,"highlight_end":39},{"text":"                        .iter()","highlight_start":1,"highlight_end":32},{"text":"                        .map(|sk| sk.sign(&msgs[i], dst, &[]))","highlight_start":1,"highlight_end":63},{"text":"                        .collect::<Vec<Signature>>();","highlight_start":1,"highlight_end":54},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Test each current single signature","highlight_start":1,"highlight_end":58},{"text":"                    let errs = sigs_i","highlight_start":1,"highlight_end":38},{"text":"                        .iter()","highlight_start":1,"highlight_end":32},{"text":"                        .zip(pks_i.iter())","highlight_start":1,"highlight_end":43},{"text":"                        .map(|(s, pk)| {","highlight_start":1,"highlight_end":41},{"text":"                            (s.verify(true, &msgs[i], dst, &[], pk, true))","highlight_start":1,"highlight_end":75},{"text":"                        })","highlight_start":1,"highlight_end":27},{"text":"                        .collect::<Vec<BLST_ERROR>>();","highlight_start":1,"highlight_end":55},{"text":"                    assert_eq!(","highlight_start":1,"highlight_end":32},{"text":"                        errs,","highlight_start":1,"highlight_end":30},{"text":"                        vec![BLST_ERROR::BLST_SUCCESS; num_pks_per_sig]","highlight_start":1,"highlight_end":72},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let sig_refs_i =","highlight_start":1,"highlight_end":37},{"text":"                        sigs_i.iter().map(|s| s).collect::<Vec<&Signature>>();","highlight_start":1,"highlight_end":79},{"text":"                    let agg_i =","highlight_start":1,"highlight_end":32},{"text":"                        match AggregateSignature::aggregate(&sig_refs_i, false)","highlight_start":1,"highlight_end":80},{"text":"                        {","highlight_start":1,"highlight_end":26},{"text":"                            Ok(agg_i) => agg_i,","highlight_start":1,"highlight_end":48},{"text":"                            Err(err) => panic!(\"aggregate failure: {:?}\", err),","highlight_start":1,"highlight_end":80},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Test current aggregate signature","highlight_start":1,"highlight_end":56},{"text":"                    sigs.push(agg_i.to_signature());","highlight_start":1,"highlight_end":53},{"text":"                    let mut result = sigs[i].fast_aggregate_verify(","highlight_start":1,"highlight_end":68},{"text":"                        false,","highlight_start":1,"highlight_end":31},{"text":"                        &msgs[i],","highlight_start":1,"highlight_end":34},{"text":"                        dst,","highlight_start":1,"highlight_end":29},{"text":"                        &pks_refs_i,","highlight_start":1,"highlight_end":37},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                    assert_eq!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":66},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // negative test","highlight_start":1,"highlight_end":37},{"text":"                    if i != 0 {","highlight_start":1,"highlight_end":32},{"text":"                        result = sigs[i - 1].fast_aggregate_verify(","highlight_start":1,"highlight_end":68},{"text":"                            false,","highlight_start":1,"highlight_end":35},{"text":"                            &msgs[i],","highlight_start":1,"highlight_end":38},{"text":"                            dst,","highlight_start":1,"highlight_end":33},{"text":"                            &pks_refs_i,","highlight_start":1,"highlight_end":41},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                        assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":70},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // aggregate public keys and push into vec","highlight_start":1,"highlight_end":63},{"text":"                    let agg_pk_i =","highlight_start":1,"highlight_end":35},{"text":"                        match AggregatePublicKey::aggregate(&pks_refs_i, false)","highlight_start":1,"highlight_end":80},{"text":"                        {","highlight_start":1,"highlight_end":26},{"text":"                            Ok(agg_pk_i) => agg_pk_i,","highlight_start":1,"highlight_end":54},{"text":"                            Err(err) => panic!(\"aggregate failure: {:?}\", err),","highlight_start":1,"highlight_end":80},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                    pks.push(agg_pk_i.to_public_key());","highlight_start":1,"highlight_end":56},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Test current aggregate signature with aggregated pks","highlight_start":1,"highlight_end":76},{"text":"                    result = sigs[i].fast_aggregate_verify_pre_aggregated(","highlight_start":1,"highlight_end":75},{"text":"                        false, &msgs[i], dst, &pks[i],","highlight_start":1,"highlight_end":55},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                    assert_eq!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":66},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // negative test","highlight_start":1,"highlight_end":37},{"text":"                    if i != 0 {","highlight_start":1,"highlight_end":32},{"text":"                        result = sigs[i - 1]","highlight_start":1,"highlight_end":45},{"text":"                            .fast_aggregate_verify_pre_aggregated(","highlight_start":1,"highlight_end":67},{"text":"                                false, &msgs[i], dst, &pks[i],","highlight_start":1,"highlight_end":63},{"text":"                            );","highlight_start":1,"highlight_end":31},{"text":"                        assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":70},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // create random values","highlight_start":1,"highlight_end":44},{"text":"                    let mut vals = [0u64; 4];","highlight_start":1,"highlight_end":46},{"text":"                    vals[0] = rng.next_u64();","highlight_start":1,"highlight_end":46},{"text":"                    while vals[0] == 0 {","highlight_start":1,"highlight_end":41},{"text":"                        // Reject zero as it is used for multiplication.","highlight_start":1,"highlight_end":73},{"text":"                        vals[0] = rng.next_u64();","highlight_start":1,"highlight_end":50},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    let mut rand_i =","highlight_start":1,"highlight_end":37},{"text":"                        std::mem::MaybeUninit::<blst_scalar>::uninit();","highlight_start":1,"highlight_end":72},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        blst_scalar_from_uint64(","highlight_start":1,"highlight_end":49},{"text":"                            rand_i.as_mut_ptr(),","highlight_start":1,"highlight_end":49},{"text":"                            vals.as_ptr(),","highlight_start":1,"highlight_end":43},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                        rands.push(rand_i.assume_init());","highlight_start":1,"highlight_end":58},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let msgs_refs: Vec<&[u8]> =","highlight_start":1,"highlight_end":44},{"text":"                    msgs.iter().map(|m| m.as_slice()).collect();","highlight_start":1,"highlight_end":65},{"text":"                let sig_refs =","highlight_start":1,"highlight_end":31},{"text":"                    sigs.iter().map(|s| s).collect::<Vec<&Signature>>();","highlight_start":1,"highlight_end":73},{"text":"                let pks_refs: Vec<&PublicKey> =","highlight_start":1,"highlight_end":48},{"text":"                    pks.iter().map(|pk| pk).collect();","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let msgs_rev: Vec<&[u8]> =","highlight_start":1,"highlight_end":43},{"text":"                    msgs.iter().rev().map(|m| m.as_slice()).collect();","highlight_start":1,"highlight_end":71},{"text":"                let sig_rev =","highlight_start":1,"highlight_end":30},{"text":"                    sigs.iter().rev().map(|s| s).collect::<Vec<&Signature>>();","highlight_start":1,"highlight_end":79},{"text":"                let pks_rev: Vec<&PublicKey> =","highlight_start":1,"highlight_end":47},{"text":"                    pks.iter().rev().map(|pk| pk).collect();","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut result =","highlight_start":1,"highlight_end":33},{"text":"                    Signature::verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":69},{"text":"                        &msgs_refs, dst, &pks_refs, false, &sig_refs, true,","highlight_start":1,"highlight_end":76},{"text":"                        &rands, 64,","highlight_start":1,"highlight_end":36},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                assert_eq!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // negative tests (use reverse msgs, pks, and sigs)","highlight_start":1,"highlight_end":68},{"text":"                result = Signature::verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":74},{"text":"                    &msgs_rev, dst, &pks_refs, false, &sig_refs, true, &rands,","highlight_start":1,"highlight_end":79},{"text":"                    64,","highlight_start":1,"highlight_end":24},{"text":"                );","highlight_start":1,"highlight_end":19},{"text":"                assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                result = Signature::verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":74},{"text":"                    &msgs_refs, dst, &pks_rev, false, &sig_refs, true, &rands,","highlight_start":1,"highlight_end":79},{"text":"                    64,","highlight_start":1,"highlight_end":24},{"text":"                );","highlight_start":1,"highlight_end":19},{"text":"                assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                result = Signature::verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":74},{"text":"                    &msgs_refs, dst, &pks_refs, false, &sig_rev, true, &rands,","highlight_start":1,"highlight_end":79},{"text":"                    64,","highlight_start":1,"highlight_end":24},{"text":"                );","highlight_start":1,"highlight_end":19},{"text":"                assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[test]","highlight_start":1,"highlight_end":20},{"text":"            fn test_serialization() {","highlight_start":1,"highlight_end":38},{"text":"                let seed = [0u8; 32];","highlight_start":1,"highlight_end":38},{"text":"                let mut rng = ChaCha20Rng::from_seed(seed);","highlight_start":1,"highlight_end":60},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sk = gen_random_key(&mut rng);","highlight_start":1,"highlight_end":51},{"text":"                let sk2 = gen_random_key(&mut rng);","highlight_start":1,"highlight_end":52},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk = sk.sk_to_pk();","highlight_start":1,"highlight_end":40},{"text":"                let pk_comp = pk.compress();","highlight_start":1,"highlight_end":45},{"text":"                let pk_ser = pk.serialize();","highlight_start":1,"highlight_end":45},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_uncomp = PublicKey::uncompress(&pk_comp);","highlight_start":1,"highlight_end":65},{"text":"                assert_eq!(pk_uncomp.is_ok(), true);","highlight_start":1,"highlight_end":53},{"text":"                assert_eq!(pk_uncomp.unwrap(), pk);","highlight_start":1,"highlight_end":52},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_deser = PublicKey::deserialize(&pk_ser);","highlight_start":1,"highlight_end":64},{"text":"                assert_eq!(pk_deser.is_ok(), true);","highlight_start":1,"highlight_end":52},{"text":"                assert_eq!(pk_deser.unwrap(), pk);","highlight_start":1,"highlight_end":51},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk2 = sk2.sk_to_pk();","highlight_start":1,"highlight_end":42},{"text":"                let pk_comp2 = pk2.compress();","highlight_start":1,"highlight_end":47},{"text":"                let pk_ser2 = pk2.serialize();","highlight_start":1,"highlight_end":47},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_uncomp2 = PublicKey::uncompress(&pk_comp2);","highlight_start":1,"highlight_end":67},{"text":"                assert_eq!(pk_uncomp2.is_ok(), true);","highlight_start":1,"highlight_end":54},{"text":"                assert_eq!(pk_uncomp2.unwrap(), pk2);","highlight_start":1,"highlight_end":54},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_deser2 = PublicKey::deserialize(&pk_ser2);","highlight_start":1,"highlight_end":66},{"text":"                assert_eq!(pk_deser2.is_ok(), true);","highlight_start":1,"highlight_end":53},{"text":"                assert_eq!(pk_deser2.unwrap(), pk2);","highlight_start":1,"highlight_end":53},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                assert_ne!(pk, pk2);","highlight_start":1,"highlight_end":37},{"text":"                assert_ne!(pk_uncomp.unwrap(), pk2);","highlight_start":1,"highlight_end":53},{"text":"                assert_ne!(pk_deser.unwrap(), pk2);","highlight_start":1,"highlight_end":52},{"text":"                assert_ne!(pk_uncomp2.unwrap(), pk);","highlight_start":1,"highlight_end":53},{"text":"                assert_ne!(pk_deser2.unwrap(), pk);","highlight_start":1,"highlight_end":52},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"`#[warn(unused_mut)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove this `mut`","code":null,"level":"help","spans":[{"file_name":"/home/azureuser/blst/bindings/rust/src/lib.rs","byte_start":25106,"byte_end":25110,"line_start":779,"line_end":779,"column_start":21,"column_end":25,"is_primary":true,"text":[{"text":"                let mut acc = rx.recv().unwrap();","highlight_start":21,"highlight_end":25}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"/home/azureuser/blst/bindings/rust/src/lib.rs","byte_start":51945,"byte_end":52960,"line_start":1472,"line_end":1510,"column_start":5,"column_end":7,"is_primary":false,"text":[{"text":"    sig_variant_impl!(","highlight_start":5,"highlight_end":23},{"text":"        \"MinPk\",","highlight_start":1,"highlight_end":17},{"text":"        blst_p1,","highlight_start":1,"highlight_end":17},{"text":"        blst_p1_affine,","highlight_start":1,"highlight_end":24},{"text":"        blst_p2,","highlight_start":1,"highlight_end":17},{"text":"        blst_p2_affine,","highlight_start":1,"highlight_end":24},{"text":"        blst_sk_to_pk2_in_g1,","highlight_start":1,"highlight_end":30},{"text":"        true,","highlight_start":1,"highlight_end":14},{"text":"        blst_hash_to_g2,","highlight_start":1,"highlight_end":25},{"text":"        blst_sign_pk2_in_g1,","highlight_start":1,"highlight_end":29},{"text":"        blst_p1_affine_is_equal,","highlight_start":1,"highlight_end":33},{"text":"        blst_p2_affine_is_equal,","highlight_start":1,"highlight_end":33},{"text":"        blst_core_verify_pk_in_g1,","highlight_start":1,"highlight_end":35},{"text":"        blst_p1_affine_in_g1,","highlight_start":1,"highlight_end":30},{"text":"        blst_p1_to_affine,","highlight_start":1,"highlight_end":27},{"text":"        blst_p1_from_affine,","highlight_start":1,"highlight_end":29},{"text":"        blst_p1_affine_serialize,","highlight_start":1,"highlight_end":34},{"text":"        blst_p1_affine_compress,","highlight_start":1,"highlight_end":33},{"text":"        blst_p1_deserialize,","highlight_start":1,"highlight_end":29},{"text":"        blst_p1_uncompress,","highlight_start":1,"highlight_end":28},{"text":"        48,","highlight_start":1,"highlight_end":12},{"text":"        96,","highlight_start":1,"highlight_end":12},{"text":"        blst_p2_affine_in_g2,","highlight_start":1,"highlight_end":30},{"text":"        blst_p2_to_affine,","highlight_start":1,"highlight_end":27},{"text":"        blst_p2_from_affine,","highlight_start":1,"highlight_end":29},{"text":"        blst_p2_affine_serialize,","highlight_start":1,"highlight_end":34},{"text":"        blst_p2_affine_compress,","highlight_start":1,"highlight_end":33},{"text":"        blst_p2_deserialize,","highlight_start":1,"highlight_end":29},{"text":"        blst_p2_uncompress,","highlight_start":1,"highlight_end":28},{"text":"        96,","highlight_start":1,"highlight_end":12},{"text":"        192,","highlight_start":1,"highlight_end":13},{"text":"        blst_p1_add_or_double,","highlight_start":1,"highlight_end":31},{"text":"        blst_p1_add_or_double_affine,","highlight_start":1,"highlight_end":38},{"text":"        blst_p2_add_or_double,","highlight_start":1,"highlight_end":31},{"text":"        blst_p2_add_or_double_affine,","highlight_start":1,"highlight_end":38},{"text":"        blst_p1_affine_is_inf,","highlight_start":1,"highlight_end":31},{"text":"        blst_p2_affine_is_inf,","highlight_start":1,"highlight_end":31},{"text":"        blst_p2_in_g2,","highlight_start":1,"highlight_end":23},{"text":"    );","highlight_start":1,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"sig_variant_impl!","def_site_span":{"file_name":"/home/azureuser/blst/bindings/rust/src/lib.rs","byte_start":7790,"byte_end":51903,"line_start":283,"line_end":1467,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! sig_variant_impl {","highlight_start":1,"highlight_end":32},{"text":"    (","highlight_start":1,"highlight_end":6},{"text":"        $name:expr,","highlight_start":1,"highlight_end":20},{"text":"        $pk:ty,","highlight_start":1,"highlight_end":16},{"text":"        $pk_aff:ty,","highlight_start":1,"highlight_end":20},{"text":"        $sig:ty,","highlight_start":1,"highlight_end":17},{"text":"        $sig_aff:ty,","highlight_start":1,"highlight_end":21},{"text":"        $sk_to_pk:ident,","highlight_start":1,"highlight_end":25},{"text":"        $hash_or_encode:expr,","highlight_start":1,"highlight_end":30},{"text":"        $hash_or_encode_to:ident,","highlight_start":1,"highlight_end":34},{"text":"        $sign:ident,","highlight_start":1,"highlight_end":21},{"text":"        $pk_eq:ident,","highlight_start":1,"highlight_end":22},{"text":"        $sig_eq:ident,","highlight_start":1,"highlight_end":23},{"text":"        $verify:ident,","highlight_start":1,"highlight_end":23},{"text":"        $pk_in_group:ident,","highlight_start":1,"highlight_end":28},{"text":"        $pk_to_aff:ident,","highlight_start":1,"highlight_end":26},{"text":"        $pk_from_aff:ident,","highlight_start":1,"highlight_end":28},{"text":"        $pk_ser:ident,","highlight_start":1,"highlight_end":23},{"text":"        $pk_comp:ident,","highlight_start":1,"highlight_end":24},{"text":"        $pk_deser:ident,","highlight_start":1,"highlight_end":25},{"text":"        $pk_uncomp:ident,","highlight_start":1,"highlight_end":26},{"text":"        $pk_comp_size:expr,","highlight_start":1,"highlight_end":28},{"text":"        $pk_ser_size:expr,","highlight_start":1,"highlight_end":27},{"text":"        $sig_in_group:ident,","highlight_start":1,"highlight_end":29},{"text":"        $sig_to_aff:ident,","highlight_start":1,"highlight_end":27},{"text":"        $sig_from_aff:ident,","highlight_start":1,"highlight_end":29},{"text":"        $sig_ser:ident,","highlight_start":1,"highlight_end":24},{"text":"        $sig_comp:ident,","highlight_start":1,"highlight_end":25},{"text":"        $sig_deser:ident,","highlight_start":1,"highlight_end":26},{"text":"        $sig_uncomp:ident,","highlight_start":1,"highlight_end":27},{"text":"        $sig_comp_size:expr,","highlight_start":1,"highlight_end":29},{"text":"        $sig_ser_size:expr,","highlight_start":1,"highlight_end":28},{"text":"        $pk_add_or_dbl:ident,","highlight_start":1,"highlight_end":30},{"text":"        $pk_add_or_dbl_aff:ident,","highlight_start":1,"highlight_end":34},{"text":"        $sig_add_or_dbl:ident,","highlight_start":1,"highlight_end":31},{"text":"        $sig_add_or_dbl_aff:ident,","highlight_start":1,"highlight_end":35},{"text":"        $pk_is_inf:ident,","highlight_start":1,"highlight_end":26},{"text":"        $sig_is_inf:ident,","highlight_start":1,"highlight_end":27},{"text":"        $sig_aggr_in_group:ident,","highlight_start":1,"highlight_end":34},{"text":"    ) => {","highlight_start":1,"highlight_end":11},{"text":"        /// Secret Key","highlight_start":1,"highlight_end":23},{"text":"        #[derive(Default, Debug, Clone, Zeroize)]","highlight_start":1,"highlight_end":50},{"text":"        #[zeroize(drop)]","highlight_start":1,"highlight_end":25},{"text":"        pub struct SecretKey {","highlight_start":1,"highlight_end":31},{"text":"            value: blst_scalar,","highlight_start":1,"highlight_end":32},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl SecretKey {","highlight_start":1,"highlight_end":25},{"text":"            /// Deterministically generate a secret key from key material","highlight_start":1,"highlight_end":74},{"text":"            pub fn key_gen(","highlight_start":1,"highlight_end":28},{"text":"                ikm: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                key_info: &[u8],","highlight_start":1,"highlight_end":33},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                if ikm.len() < 32 {","highlight_start":1,"highlight_end":36},{"text":"                    return Err(BLST_ERROR::BLST_BAD_ENCODING);","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut sk = SecretKey::default();","highlight_start":1,"highlight_end":51},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    blst_keygen(","highlight_start":1,"highlight_end":33},{"text":"                        &mut sk.value,","highlight_start":1,"highlight_end":39},{"text":"                        ikm.as_ptr(),","highlight_start":1,"highlight_end":38},{"text":"                        ikm.len(),","highlight_start":1,"highlight_end":35},{"text":"                        key_info.as_ptr(),","highlight_start":1,"highlight_end":43},{"text":"                        key_info.len(),","highlight_start":1,"highlight_end":40},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(sk)","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // sk_to_pk","highlight_start":1,"highlight_end":24},{"text":"            pub fn sk_to_pk(&self) -> PublicKey {","highlight_start":1,"highlight_end":50},{"text":"                // TODO - would the user like the serialized/compressed pk as well?","highlight_start":1,"highlight_end":84},{"text":"                let mut pk_aff = PublicKey::default();","highlight_start":1,"highlight_end":55},{"text":"                //let mut pk_ser = [0u8; $pk_ser_size];","highlight_start":1,"highlight_end":56},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sk_to_pk(","highlight_start":1,"highlight_end":31},{"text":"                        //pk_ser.as_mut_ptr(),","highlight_start":1,"highlight_end":47},{"text":"                        ptr::null_mut(),","highlight_start":1,"highlight_end":41},{"text":"                        &mut pk_aff.point,","highlight_start":1,"highlight_end":43},{"text":"                        &self.value,","highlight_start":1,"highlight_end":37},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                pk_aff","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Sign","highlight_start":1,"highlight_end":20},{"text":"            pub fn sign(","highlight_start":1,"highlight_end":25},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                msg: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                aug: &[u8],","highlight_start":1,"highlight_end":28},{"text":"            ) -> Signature {","highlight_start":1,"highlight_end":29},{"text":"                // TODO - would the user like the serialized/compressed sig as well?","highlight_start":1,"highlight_end":85},{"text":"                let mut q = <$sig>::default();","highlight_start":1,"highlight_end":47},{"text":"                let mut sig_aff = <$sig_aff>::default();","highlight_start":1,"highlight_end":57},{"text":"                //let mut sig_ser = [0u8; $sig_ser_size];","highlight_start":1,"highlight_end":58},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $hash_or_encode_to(","highlight_start":1,"highlight_end":40},{"text":"                        &mut q,","highlight_start":1,"highlight_end":32},{"text":"                        msg.as_ptr(),","highlight_start":1,"highlight_end":38},{"text":"                        msg.len(),","highlight_start":1,"highlight_end":35},{"text":"                        dst.as_ptr(),","highlight_start":1,"highlight_end":38},{"text":"                        dst.len(),","highlight_start":1,"highlight_end":35},{"text":"                        aug.as_ptr(),","highlight_start":1,"highlight_end":38},{"text":"                        aug.len(),","highlight_start":1,"highlight_end":35},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                    $sign(ptr::null_mut(), &mut sig_aff, &q, &self.value);","highlight_start":1,"highlight_end":75},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Signature { point: sig_aff }","highlight_start":1,"highlight_end":45},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // TODO - formally speaking application is entitled to have","highlight_start":1,"highlight_end":72},{"text":"            // ultimate control over secret key storage, which means that","highlight_start":1,"highlight_end":74},{"text":"            // corresponding serialization/deserialization subroutines","highlight_start":1,"highlight_end":71},{"text":"            // should accept reference to where to store the result, as","highlight_start":1,"highlight_end":72},{"text":"            // opposite to returning one.","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // serialize","highlight_start":1,"highlight_end":25},{"text":"            pub fn serialize(&self) -> [u8; 32] {","highlight_start":1,"highlight_end":50},{"text":"                let mut sk_out = [0; 32];","highlight_start":1,"highlight_end":42},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    blst_bendian_from_scalar(sk_out.as_mut_ptr(), &self.value);","highlight_start":1,"highlight_end":80},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                sk_out","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // deserialize","highlight_start":1,"highlight_end":27},{"text":"            pub fn deserialize(sk_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":75},{"text":"                let mut sk = blst_scalar::default();","highlight_start":1,"highlight_end":53},{"text":"                if sk_in.len() != 32 {","highlight_start":1,"highlight_end":39},{"text":"                    return Err(BLST_ERROR::BLST_BAD_ENCODING);","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    blst_scalar_from_bendian(&mut sk, sk_in.as_ptr());","highlight_start":1,"highlight_end":71},{"text":"                    if !blst_sk_check(&sk) {","highlight_start":1,"highlight_end":45},{"text":"                        return Err(BLST_ERROR::BLST_BAD_ENCODING);","highlight_start":1,"highlight_end":67},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(Self { value: sk })","highlight_start":1,"highlight_end":39},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_bytes(&self) -> [u8; 32] {","highlight_start":1,"highlight_end":49},{"text":"                SecretKey::serialize(&self)","highlight_start":1,"highlight_end":44},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_bytes(sk_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":74},{"text":"                SecretKey::deserialize(sk_in)","highlight_start":1,"highlight_end":46},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[derive(Default, Debug, Clone, Copy)]","highlight_start":1,"highlight_end":47},{"text":"        pub struct PublicKey {","highlight_start":1,"highlight_end":31},{"text":"            point: $pk_aff,","highlight_start":1,"highlight_end":28},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl PublicKey {","highlight_start":1,"highlight_end":25},{"text":"            // Core operations","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // key_validate","highlight_start":1,"highlight_end":28},{"text":"            pub fn validate(&self) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":63},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    if $pk_is_inf(&self.point) {","highlight_start":1,"highlight_end":49},{"text":"                        return Err(BLST_ERROR::BLST_PK_IS_INFINITY);","highlight_start":1,"highlight_end":69},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    if !$pk_in_group(&self.point) {","highlight_start":1,"highlight_end":52},{"text":"                        return Err(BLST_ERROR::BLST_POINT_NOT_IN_GROUP);","highlight_start":1,"highlight_end":73},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn key_validate(key: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":74},{"text":"                let pk = PublicKey::from_bytes(key)?;","highlight_start":1,"highlight_end":54},{"text":"                pk.validate()?;","highlight_start":1,"highlight_end":32},{"text":"                Ok(pk)","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_aggregate(agg_pk: &AggregatePublicKey) -> Self {","highlight_start":1,"highlight_end":73},{"text":"                let mut pk_aff = <$pk_aff>::default();","highlight_start":1,"highlight_end":55},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_to_aff(&mut pk_aff, &agg_pk.point);","highlight_start":1,"highlight_end":60},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Self { point: pk_aff }","highlight_start":1,"highlight_end":39},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Serdes","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn compress(&self) -> [u8; $pk_comp_size] {","highlight_start":1,"highlight_end":60},{"text":"                let mut pk_comp = [0u8; $pk_comp_size];","highlight_start":1,"highlight_end":56},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_comp(pk_comp.as_mut_ptr(), &self.point);","highlight_start":1,"highlight_end":65},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                pk_comp","highlight_start":1,"highlight_end":24},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn serialize(&self) -> [u8; $pk_ser_size] {","highlight_start":1,"highlight_end":60},{"text":"                let mut pk_out = [0u8; $pk_ser_size];","highlight_start":1,"highlight_end":54},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_ser(pk_out.as_mut_ptr(), &self.point);","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                pk_out","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn uncompress(pk_comp: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":76},{"text":"                if pk_comp.len() == $pk_comp_size && (pk_comp[0] & 0x80) != 0 {","highlight_start":1,"highlight_end":80},{"text":"                    let mut pk = <$pk_aff>::default();","highlight_start":1,"highlight_end":55},{"text":"                    let err = unsafe { $pk_uncomp(&mut pk, pk_comp.as_ptr()) };","highlight_start":1,"highlight_end":80},{"text":"                    if err != BLST_ERROR::BLST_SUCCESS {","highlight_start":1,"highlight_end":57},{"text":"                        return Err(err);","highlight_start":1,"highlight_end":41},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(Self { point: pk })","highlight_start":1,"highlight_end":43},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Err(BLST_ERROR::BLST_BAD_ENCODING)","highlight_start":1,"highlight_end":55},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn deserialize(pk_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":75},{"text":"                if (pk_in.len() == $pk_ser_size && (pk_in[0] & 0x80) == 0)","highlight_start":1,"highlight_end":75},{"text":"                    || (pk_in.len() == $pk_comp_size && (pk_in[0] & 0x80) != 0)","highlight_start":1,"highlight_end":80},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    let mut pk = <$pk_aff>::default();","highlight_start":1,"highlight_end":55},{"text":"                    let err = unsafe { $pk_deser(&mut pk, pk_in.as_ptr()) };","highlight_start":1,"highlight_end":77},{"text":"                    if err != BLST_ERROR::BLST_SUCCESS {","highlight_start":1,"highlight_end":57},{"text":"                        return Err(err);","highlight_start":1,"highlight_end":41},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(Self { point: pk })","highlight_start":1,"highlight_end":43},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Err(BLST_ERROR::BLST_BAD_ENCODING)","highlight_start":1,"highlight_end":55},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_bytes(pk_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":74},{"text":"                PublicKey::deserialize(pk_in)","highlight_start":1,"highlight_end":46},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_bytes(&self) -> [u8; $pk_comp_size] {","highlight_start":1,"highlight_end":60},{"text":"                self.compress()","highlight_start":1,"highlight_end":32},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Trait for equality comparisons which are equivalence relations.","highlight_start":1,"highlight_end":75},{"text":"        //","highlight_start":1,"highlight_end":11},{"text":"        // This means, that in addition to a == b and a != b being strict","highlight_start":1,"highlight_end":74},{"text":"        // inverses, the equality must be reflexive, symmetric and transitive.","highlight_start":1,"highlight_end":79},{"text":"        impl Eq for PublicKey {}","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl PartialEq for PublicKey {","highlight_start":1,"highlight_end":39},{"text":"            fn eq(&self, other: &Self) -> bool {","highlight_start":1,"highlight_end":49},{"text":"                unsafe { $pk_eq(&self.point, &other.point) }","highlight_start":1,"highlight_end":61},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[derive(Debug, Clone, Copy)]","highlight_start":1,"highlight_end":38},{"text":"        pub struct AggregatePublicKey {","highlight_start":1,"highlight_end":40},{"text":"            point: $pk,","highlight_start":1,"highlight_end":24},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl AggregatePublicKey {","highlight_start":1,"highlight_end":34},{"text":"            pub fn from_public_key(pk: &PublicKey) -> Self {","highlight_start":1,"highlight_end":61},{"text":"                let mut agg_pk = <$pk>::default();","highlight_start":1,"highlight_end":51},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_from_aff(&mut agg_pk, &pk.point);","highlight_start":1,"highlight_end":58},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Self { point: agg_pk }","highlight_start":1,"highlight_end":39},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_public_key(&self) -> PublicKey {","highlight_start":1,"highlight_end":55},{"text":"                let mut pk = <$pk_aff>::default();","highlight_start":1,"highlight_end":51},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_to_aff(&mut pk, &self.point);","highlight_start":1,"highlight_end":54},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                PublicKey { point: pk }","highlight_start":1,"highlight_end":40},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Aggregate","highlight_start":1,"highlight_end":25},{"text":"            pub fn aggregate(","highlight_start":1,"highlight_end":30},{"text":"                pks: &[&PublicKey],","highlight_start":1,"highlight_end":36},{"text":"                pks_validate: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                if pks.len() == 0 {","highlight_start":1,"highlight_end":36},{"text":"                    return Err(BLST_ERROR::BLST_AGGR_TYPE_MISMATCH);","highlight_start":1,"highlight_end":69},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if pks_validate {","highlight_start":1,"highlight_end":34},{"text":"                    pks[0].validate()?;","highlight_start":1,"highlight_end":40},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut agg_pk = AggregatePublicKey::from_public_key(pks[0]);","highlight_start":1,"highlight_end":78},{"text":"                for s in pks.iter().skip(1) {","highlight_start":1,"highlight_end":46},{"text":"                    if pks_validate {","highlight_start":1,"highlight_end":38},{"text":"                        s.validate()?;","highlight_start":1,"highlight_end":39},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        $pk_add_or_dbl_aff(","highlight_start":1,"highlight_end":44},{"text":"                            &mut agg_pk.point,","highlight_start":1,"highlight_end":47},{"text":"                            &agg_pk.point,","highlight_start":1,"highlight_end":43},{"text":"                            &s.point,","highlight_start":1,"highlight_end":38},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(agg_pk)","highlight_start":1,"highlight_end":27},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn aggregate_serialized(","highlight_start":1,"highlight_end":41},{"text":"                pks: &[&[u8]],","highlight_start":1,"highlight_end":31},{"text":"                pks_validate: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                // TODO - threading","highlight_start":1,"highlight_end":36},{"text":"                if pks.len() == 0 {","highlight_start":1,"highlight_end":36},{"text":"                    return Err(BLST_ERROR::BLST_AGGR_TYPE_MISMATCH);","highlight_start":1,"highlight_end":69},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut pk = if pks_validate {","highlight_start":1,"highlight_end":47},{"text":"                    PublicKey::key_validate(pks[0])?","highlight_start":1,"highlight_end":53},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    PublicKey::from_bytes(pks[0])?","highlight_start":1,"highlight_end":51},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut agg_pk = AggregatePublicKey::from_public_key(&pk);","highlight_start":1,"highlight_end":75},{"text":"                for s in pks.iter().skip(1) {","highlight_start":1,"highlight_end":46},{"text":"                    pk = if pks_validate {","highlight_start":1,"highlight_end":43},{"text":"                        PublicKey::key_validate(s)?","highlight_start":1,"highlight_end":52},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        PublicKey::from_bytes(s)?","highlight_start":1,"highlight_end":50},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        $pk_add_or_dbl_aff(","highlight_start":1,"highlight_end":44},{"text":"                            &mut agg_pk.point,","highlight_start":1,"highlight_end":47},{"text":"                            &agg_pk.point,","highlight_start":1,"highlight_end":43},{"text":"                            &pk.point,","highlight_start":1,"highlight_end":39},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(agg_pk)","highlight_start":1,"highlight_end":27},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn add_aggregate(&mut self, agg_pk: &AggregatePublicKey) {","highlight_start":1,"highlight_end":75},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_add_or_dbl(&mut self.point, &self.point, &agg_pk.point);","highlight_start":1,"highlight_end":81},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn add_public_key(","highlight_start":1,"highlight_end":35},{"text":"                &mut self,","highlight_start":1,"highlight_end":27},{"text":"                pk: &PublicKey,","highlight_start":1,"highlight_end":32},{"text":"                pk_validate: bool,","highlight_start":1,"highlight_end":35},{"text":"            ) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":42},{"text":"                if pk_validate {","highlight_start":1,"highlight_end":33},{"text":"                    pk.validate()?;","highlight_start":1,"highlight_end":36},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_add_or_dbl_aff(&mut self.point, &self.point, &pk.point);","highlight_start":1,"highlight_end":81},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[derive(Debug, Clone, Copy)]","highlight_start":1,"highlight_end":38},{"text":"        pub struct Signature {","highlight_start":1,"highlight_end":31},{"text":"            point: $sig_aff,","highlight_start":1,"highlight_end":29},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl Signature {","highlight_start":1,"highlight_end":25},{"text":"            // sig_infcheck, check for infinity, is a way to avoid going","highlight_start":1,"highlight_end":73},{"text":"            // into resource-consuming verification. Passing 'false' is","highlight_start":1,"highlight_end":72},{"text":"            // always cryptographically safe, but application might want","highlight_start":1,"highlight_end":73},{"text":"            // to guard against obviously bogus individual[!] signatures.","highlight_start":1,"highlight_end":74},{"text":"            pub fn validate(","highlight_start":1,"highlight_end":29},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_infcheck: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":42},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    if sig_infcheck && $sig_is_inf(&self.point) {","highlight_start":1,"highlight_end":66},{"text":"                        return Err(BLST_ERROR::BLST_PK_IS_INFINITY);","highlight_start":1,"highlight_end":69},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    if !$sig_in_group(&self.point) {","highlight_start":1,"highlight_end":53},{"text":"                        return Err(BLST_ERROR::BLST_POINT_NOT_IN_GROUP);","highlight_start":1,"highlight_end":73},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn sig_validate(","highlight_start":1,"highlight_end":33},{"text":"                sig: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                sig_infcheck: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                let sig = Signature::from_bytes(sig)?;","highlight_start":1,"highlight_end":55},{"text":"                sig.validate(sig_infcheck)?;","highlight_start":1,"highlight_end":45},{"text":"                Ok(sig)","highlight_start":1,"highlight_end":24},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn verify(","highlight_start":1,"highlight_end":27},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"                msg: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                aug: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pk: &PublicKey,","highlight_start":1,"highlight_end":32},{"text":"                pk_validate: bool,","highlight_start":1,"highlight_end":35},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                let aug_msg = [aug, msg].concat();","highlight_start":1,"highlight_end":51},{"text":"                self.aggregate_verify(","highlight_start":1,"highlight_end":39},{"text":"                    sig_groupcheck,","highlight_start":1,"highlight_end":36},{"text":"                    &[aug_msg.as_slice()],","highlight_start":1,"highlight_end":43},{"text":"                    dst,","highlight_start":1,"highlight_end":25},{"text":"                    &[pk],","highlight_start":1,"highlight_end":27},{"text":"                    pk_validate,","highlight_start":1,"highlight_end":33},{"text":"                )","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn aggregate_verify(","highlight_start":1,"highlight_end":37},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"                msgs: &[&[u8]],","highlight_start":1,"highlight_end":32},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pks: &[&PublicKey],","highlight_start":1,"highlight_end":36},{"text":"                pks_validate: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                let n_elems = pks.len();","highlight_start":1,"highlight_end":41},{"text":"                if n_elems == 0 || msgs.len() != n_elems {","highlight_start":1,"highlight_end":59},{"text":"                    return BLST_ERROR::BLST_VERIFY_FAIL;","highlight_start":1,"highlight_end":57},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // TODO - check msg uniqueness?","highlight_start":1,"highlight_end":48},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // let pool = da_pool();","highlight_start":1,"highlight_end":41},{"text":"                let (tx, rx) = channel();","highlight_start":1,"highlight_end":42},{"text":"                let counter = Arc::new(AtomicUsize::new(0));","highlight_start":1,"highlight_end":61},{"text":"                let valid = Arc::new(AtomicBool::new(true));","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Bypass 'lifetime limitations by brute force. It works,","highlight_start":1,"highlight_end":74},{"text":"                // because we explicitly join the threads...","highlight_start":1,"highlight_end":61},{"text":"                let raw_pks = unsafe {","highlight_start":1,"highlight_end":39},{"text":"                    transmute::<*const &PublicKey, usize>(pks.as_ptr())","highlight_start":1,"highlight_end":72},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let raw_msgs =","highlight_start":1,"highlight_end":31},{"text":"                    unsafe { transmute::<*const &[u8], usize>(msgs.as_ptr()) };","highlight_start":1,"highlight_end":80},{"text":"                let dst =","highlight_start":1,"highlight_end":26},{"text":"                    unsafe { slice::from_raw_parts(dst.as_ptr(), dst.len()) };","highlight_start":1,"highlight_end":79},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // let n_workers = std::cmp::min(pool.max_count(), n_elems);","highlight_start":1,"highlight_end":77},{"text":"                // for _ in 0..n_workers {","highlight_start":1,"highlight_end":43},{"text":"                    let tx = tx.clone();","highlight_start":1,"highlight_end":41},{"text":"                    let counter = counter.clone();","highlight_start":1,"highlight_end":51},{"text":"                    let valid = valid.clone();","highlight_start":1,"highlight_end":47},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // pool.execute(move || {","highlight_start":1,"highlight_end":46},{"text":"                        let mut pairing = Pairing::new($hash_or_encode, dst);","highlight_start":1,"highlight_end":78},{"text":"                        // reconstruct input slices...","highlight_start":1,"highlight_end":55},{"text":"                        let msgs = unsafe {","highlight_start":1,"highlight_end":44},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &[u8]>(raw_msgs),","highlight_start":1,"highlight_end":76},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                        let pks = unsafe {","highlight_start":1,"highlight_end":43},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &PublicKey>(raw_pks),","highlight_start":1,"highlight_end":80},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        while valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":62},{"text":"                            let work = counter.fetch_add(1, Ordering::Relaxed);","highlight_start":1,"highlight_end":80},{"text":"                            if work >= n_elems {","highlight_start":1,"highlight_end":49},{"text":"                                break;","highlight_start":1,"highlight_end":39},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                            if pairing.aggregate(","highlight_start":1,"highlight_end":50},{"text":"                                &pks[work].point,","highlight_start":1,"highlight_end":50},{"text":"                                pks_validate,","highlight_start":1,"highlight_end":46},{"text":"                                &unsafe { ptr::null::<$sig_aff>().as_ref() },","highlight_start":1,"highlight_end":78},{"text":"                                false,","highlight_start":1,"highlight_end":39},{"text":"                                &msgs[work],","highlight_start":1,"highlight_end":45},{"text":"                                &[],","highlight_start":1,"highlight_end":37},{"text":"                            ) != BLST_ERROR::BLST_SUCCESS","highlight_start":1,"highlight_end":58},{"text":"                            {","highlight_start":1,"highlight_end":30},{"text":"                                valid.store(false, Ordering::Relaxed);","highlight_start":1,"highlight_end":71},{"text":"                                break;","highlight_start":1,"highlight_end":39},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        if valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":59},{"text":"                            pairing.commit();","highlight_start":1,"highlight_end":46},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        tx.send(pairing).expect(\"disaster\");","highlight_start":1,"highlight_end":61},{"text":"                    // });","highlight_start":1,"highlight_end":27},{"text":"                // }","highlight_start":1,"highlight_end":21},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                if sig_groupcheck && valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":69},{"text":"                    match self.validate(false) {","highlight_start":1,"highlight_end":49},{"text":"                        Err(_err) => valid.store(false, Ordering::Relaxed),","highlight_start":1,"highlight_end":76},{"text":"                        _ => (),","highlight_start":1,"highlight_end":33},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut gtsig = blst_fp12::default();","highlight_start":1,"highlight_end":54},{"text":"                if valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":51},{"text":"                    Pairing::aggregated(&mut gtsig, &self.point);","highlight_start":1,"highlight_end":66},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut acc = rx.recv().unwrap();","highlight_start":1,"highlight_end":50},{"text":"                // for _ in 1..n_workers {","highlight_start":1,"highlight_end":43},{"text":"                    // acc.merge(&rx.recv().unwrap());","highlight_start":1,"highlight_end":55},{"text":"                // }","highlight_start":1,"highlight_end":21},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                if valid.load(Ordering::Relaxed)","highlight_start":1,"highlight_end":49},{"text":"                    && acc.finalverify(Some(&gtsig))","highlight_start":1,"highlight_end":53},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    BLST_ERROR::BLST_SUCCESS","highlight_start":1,"highlight_end":45},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    BLST_ERROR::BLST_VERIFY_FAIL","highlight_start":1,"highlight_end":49},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // pks are assumed to be verified for proof of possession,","highlight_start":1,"highlight_end":71},{"text":"            // which implies that they are already group-checked","highlight_start":1,"highlight_end":65},{"text":"            pub fn fast_aggregate_verify(","highlight_start":1,"highlight_end":42},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"                msg: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pks: &[&PublicKey],","highlight_start":1,"highlight_end":36},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                let agg_pk = match AggregatePublicKey::aggregate(pks, false) {","highlight_start":1,"highlight_end":79},{"text":"                    Ok(agg_sig) => agg_sig,","highlight_start":1,"highlight_end":44},{"text":"                    Err(err) => return err,","highlight_start":1,"highlight_end":44},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let pk = agg_pk.to_public_key();","highlight_start":1,"highlight_end":49},{"text":"                self.aggregate_verify(","highlight_start":1,"highlight_end":39},{"text":"                    sig_groupcheck,","highlight_start":1,"highlight_end":36},{"text":"                    &[msg],","highlight_start":1,"highlight_end":28},{"text":"                    dst,","highlight_start":1,"highlight_end":25},{"text":"                    &[&pk],","highlight_start":1,"highlight_end":28},{"text":"                    false,","highlight_start":1,"highlight_end":27},{"text":"                )","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn fast_aggregate_verify_pre_aggregated(","highlight_start":1,"highlight_end":57},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"                msg: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pk: &PublicKey,","highlight_start":1,"highlight_end":32},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                self.aggregate_verify(sig_groupcheck, &[msg], dst, &[pk], false)","highlight_start":1,"highlight_end":81},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // https://ethresear.ch/t/fast-verification-of-multiple-bls-signatures/5407","highlight_start":1,"highlight_end":88},{"text":"            pub fn verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":57},{"text":"                msgs: &[&[u8]],","highlight_start":1,"highlight_end":32},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pks: &[&PublicKey],","highlight_start":1,"highlight_end":36},{"text":"                pks_validate: bool,","highlight_start":1,"highlight_end":36},{"text":"                sigs: &[&Signature],","highlight_start":1,"highlight_end":37},{"text":"                sigs_groupcheck: bool,","highlight_start":1,"highlight_end":39},{"text":"                rands: &[blst_scalar],","highlight_start":1,"highlight_end":39},{"text":"                rand_bits: usize,","highlight_start":1,"highlight_end":34},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                let n_elems = pks.len();","highlight_start":1,"highlight_end":41},{"text":"                if n_elems == 0","highlight_start":1,"highlight_end":32},{"text":"                    || msgs.len() != n_elems","highlight_start":1,"highlight_end":45},{"text":"                    || sigs.len() != n_elems","highlight_start":1,"highlight_end":45},{"text":"                    || rands.len() != n_elems","highlight_start":1,"highlight_end":46},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    return BLST_ERROR::BLST_VERIFY_FAIL;","highlight_start":1,"highlight_end":57},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // TODO - check msg uniqueness?","highlight_start":1,"highlight_end":48},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // let pool = da_pool();","highlight_start":1,"highlight_end":41},{"text":"                let (tx, rx) = channel();","highlight_start":1,"highlight_end":42},{"text":"                let counter = Arc::new(AtomicUsize::new(0));","highlight_start":1,"highlight_end":61},{"text":"                let valid = Arc::new(AtomicBool::new(true));","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Bypass 'lifetime limitations by brute force. It works,","highlight_start":1,"highlight_end":74},{"text":"                // because we explicitly join the threads...","highlight_start":1,"highlight_end":61},{"text":"                let raw_pks = unsafe {","highlight_start":1,"highlight_end":39},{"text":"                    transmute::<*const &PublicKey, usize>(pks.as_ptr())","highlight_start":1,"highlight_end":72},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let raw_sigs = unsafe {","highlight_start":1,"highlight_end":40},{"text":"                    transmute::<*const &Signature, usize>(sigs.as_ptr())","highlight_start":1,"highlight_end":73},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let raw_rands = unsafe {","highlight_start":1,"highlight_end":41},{"text":"                    transmute::<*const blst_scalar, usize>(rands.as_ptr())","highlight_start":1,"highlight_end":75},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let raw_msgs =","highlight_start":1,"highlight_end":31},{"text":"                    unsafe { transmute::<*const &[u8], usize>(msgs.as_ptr()) };","highlight_start":1,"highlight_end":80},{"text":"                let dst =","highlight_start":1,"highlight_end":26},{"text":"                    unsafe { slice::from_raw_parts(dst.as_ptr(), dst.len()) };","highlight_start":1,"highlight_end":79},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // let n_workers = std::cmp::min(pool.max_count(), n_elems);","highlight_start":1,"highlight_end":77},{"text":"                //for _ in 0..n_workers {","highlight_start":1,"highlight_end":42},{"text":"                    let tx = tx.clone();","highlight_start":1,"highlight_end":41},{"text":"                    let counter = counter.clone();","highlight_start":1,"highlight_end":51},{"text":"                    let valid = valid.clone();","highlight_start":1,"highlight_end":47},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // pool.execute(move || {","highlight_start":1,"highlight_end":46},{"text":"                        let mut pairing = Pairing::new($hash_or_encode, dst);","highlight_start":1,"highlight_end":78},{"text":"                        // reconstruct input slices...","highlight_start":1,"highlight_end":55},{"text":"                        let rands = unsafe {","highlight_start":1,"highlight_end":45},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const blst_scalar>(","highlight_start":1,"highlight_end":72},{"text":"                                    raw_rands,","highlight_start":1,"highlight_end":47},{"text":"                                ),","highlight_start":1,"highlight_end":35},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                        let msgs = unsafe {","highlight_start":1,"highlight_end":44},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &[u8]>(raw_msgs),","highlight_start":1,"highlight_end":76},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                        let sigs = unsafe {","highlight_start":1,"highlight_end":44},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &Signature>(raw_sigs),","highlight_start":1,"highlight_end":81},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                        let pks = unsafe {","highlight_start":1,"highlight_end":43},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &PublicKey>(raw_pks),","highlight_start":1,"highlight_end":80},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        // TODO - engage multi-point mul-n-add for larger","highlight_start":1,"highlight_end":74},{"text":"                        // amount of inputs...","highlight_start":1,"highlight_end":47},{"text":"                        while valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":62},{"text":"                            let work = counter.fetch_add(1, Ordering::Relaxed);","highlight_start":1,"highlight_end":80},{"text":"                            if work >= n_elems {","highlight_start":1,"highlight_end":49},{"text":"                                break;","highlight_start":1,"highlight_end":39},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            if pairing.mul_n_aggregate(","highlight_start":1,"highlight_end":56},{"text":"                                &pks[work].point,","highlight_start":1,"highlight_end":50},{"text":"                                pks_validate,","highlight_start":1,"highlight_end":46},{"text":"                                &sigs[work].point,","highlight_start":1,"highlight_end":51},{"text":"                                sigs_groupcheck,","highlight_start":1,"highlight_end":49},{"text":"                                &rands[work].b,","highlight_start":1,"highlight_end":48},{"text":"                                rand_bits,","highlight_start":1,"highlight_end":43},{"text":"                                msgs[work],","highlight_start":1,"highlight_end":44},{"text":"                                &[],","highlight_start":1,"highlight_end":37},{"text":"                            ) != BLST_ERROR::BLST_SUCCESS","highlight_start":1,"highlight_end":58},{"text":"                            {","highlight_start":1,"highlight_end":30},{"text":"                                valid.store(false, Ordering::Relaxed);","highlight_start":1,"highlight_end":71},{"text":"                                break;","highlight_start":1,"highlight_end":39},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        if valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":59},{"text":"                            pairing.commit();","highlight_start":1,"highlight_end":46},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        tx.send(pairing).expect(\"disaster\");","highlight_start":1,"highlight_end":61},{"text":"                    // });","highlight_start":1,"highlight_end":27},{"text":"                //}","highlight_start":1,"highlight_end":20},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut acc = rx.recv().unwrap();","highlight_start":1,"highlight_end":50},{"text":"                //for _ in 1..n_workers {","highlight_start":1,"highlight_end":42},{"text":"                    // acc.merge(&rx.recv().unwrap());","highlight_start":1,"highlight_end":55},{"text":"                //}","highlight_start":1,"highlight_end":20},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                if valid.load(Ordering::Relaxed) && acc.finalverify(None) {","highlight_start":1,"highlight_end":76},{"text":"                    BLST_ERROR::BLST_SUCCESS","highlight_start":1,"highlight_end":45},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    BLST_ERROR::BLST_VERIFY_FAIL","highlight_start":1,"highlight_end":49},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_aggregate(agg_sig: &AggregateSignature) -> Self {","highlight_start":1,"highlight_end":74},{"text":"                let mut sig_aff = <$sig_aff>::default();","highlight_start":1,"highlight_end":57},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_to_aff(&mut sig_aff, &agg_sig.point);","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Self { point: sig_aff }","highlight_start":1,"highlight_end":40},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn compress(&self) -> [u8; $sig_comp_size] {","highlight_start":1,"highlight_end":61},{"text":"                let mut sig_comp = [0; $sig_comp_size];","highlight_start":1,"highlight_end":56},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_comp(sig_comp.as_mut_ptr(), &self.point);","highlight_start":1,"highlight_end":67},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                sig_comp","highlight_start":1,"highlight_end":25},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn serialize(&self) -> [u8; $sig_ser_size] {","highlight_start":1,"highlight_end":61},{"text":"                let mut sig_out = [0; $sig_ser_size];","highlight_start":1,"highlight_end":54},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_ser(sig_out.as_mut_ptr(), &self.point);","highlight_start":1,"highlight_end":65},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                sig_out","highlight_start":1,"highlight_end":24},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn uncompress(sig_comp: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":77},{"text":"                if sig_comp.len() == $sig_comp_size && (sig_comp[0] & 0x80) != 0","highlight_start":1,"highlight_end":81},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    let mut sig = <$sig_aff>::default();","highlight_start":1,"highlight_end":57},{"text":"                    let err =","highlight_start":1,"highlight_end":30},{"text":"                        unsafe { $sig_uncomp(&mut sig, sig_comp.as_ptr()) };","highlight_start":1,"highlight_end":77},{"text":"                    if err != BLST_ERROR::BLST_SUCCESS {","highlight_start":1,"highlight_end":57},{"text":"                        return Err(err);","highlight_start":1,"highlight_end":41},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(Self { point: sig })","highlight_start":1,"highlight_end":44},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Err(BLST_ERROR::BLST_BAD_ENCODING)","highlight_start":1,"highlight_end":55},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn deserialize(sig_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":76},{"text":"                if (sig_in.len() == $sig_ser_size && (sig_in[0] & 0x80) == 0)","highlight_start":1,"highlight_end":78},{"text":"                    || (sig_in.len() == $sig_comp_size","highlight_start":1,"highlight_end":55},{"text":"                        && (sig_in[0] & 0x80) != 0)","highlight_start":1,"highlight_end":52},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    let mut sig = <$sig_aff>::default();","highlight_start":1,"highlight_end":57},{"text":"                    let err = unsafe { $sig_deser(&mut sig, sig_in.as_ptr()) };","highlight_start":1,"highlight_end":80},{"text":"                    if err != BLST_ERROR::BLST_SUCCESS {","highlight_start":1,"highlight_end":57},{"text":"                        return Err(err);","highlight_start":1,"highlight_end":41},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(Self { point: sig })","highlight_start":1,"highlight_end":44},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Err(BLST_ERROR::BLST_BAD_ENCODING)","highlight_start":1,"highlight_end":55},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_bytes(sig_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":75},{"text":"                Signature::deserialize(sig_in)","highlight_start":1,"highlight_end":47},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_bytes(&self) -> [u8; $sig_comp_size] {","highlight_start":1,"highlight_end":61},{"text":"                self.compress()","highlight_start":1,"highlight_end":32},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn subgroup_check(&self) -> bool {","highlight_start":1,"highlight_end":51},{"text":"                unsafe { $sig_in_group(&self.point) }","highlight_start":1,"highlight_end":54},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Trait for equality comparisons which are equivalence relations.","highlight_start":1,"highlight_end":75},{"text":"        //","highlight_start":1,"highlight_end":11},{"text":"        // This means, that in addition to a == b and a != b being strict","highlight_start":1,"highlight_end":74},{"text":"        // inverses, the equality must be reflexive, symmetric and transitive.","highlight_start":1,"highlight_end":79},{"text":"        impl Eq for Signature {}","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl PartialEq for Signature {","highlight_start":1,"highlight_end":39},{"text":"            fn eq(&self, other: &Self) -> bool {","highlight_start":1,"highlight_end":49},{"text":"                unsafe { $sig_eq(&self.point, &other.point) }","highlight_start":1,"highlight_end":62},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[derive(Debug, Clone, Copy)]","highlight_start":1,"highlight_end":38},{"text":"        pub struct AggregateSignature {","highlight_start":1,"highlight_end":40},{"text":"            point: $sig,","highlight_start":1,"highlight_end":25},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl AggregateSignature {","highlight_start":1,"highlight_end":34},{"text":"            pub fn validate(&self) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":63},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    if !$sig_aggr_in_group(&self.point) {","highlight_start":1,"highlight_end":58},{"text":"                        return Err(BLST_ERROR::BLST_POINT_NOT_IN_GROUP);","highlight_start":1,"highlight_end":73},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_signature(sig: &Signature) -> Self {","highlight_start":1,"highlight_end":61},{"text":"                let mut agg_sig = <$sig>::default();","highlight_start":1,"highlight_end":53},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_from_aff(&mut agg_sig, &sig.point);","highlight_start":1,"highlight_end":61},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Self { point: agg_sig }","highlight_start":1,"highlight_end":40},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_signature(&self) -> Signature {","highlight_start":1,"highlight_end":54},{"text":"                let mut sig = <$sig_aff>::default();","highlight_start":1,"highlight_end":53},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_to_aff(&mut sig, &self.point);","highlight_start":1,"highlight_end":56},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Signature { point: sig }","highlight_start":1,"highlight_end":41},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Aggregate","highlight_start":1,"highlight_end":25},{"text":"            pub fn aggregate(","highlight_start":1,"highlight_end":30},{"text":"                sigs: &[&Signature],","highlight_start":1,"highlight_end":37},{"text":"                sigs_groupcheck: bool,","highlight_start":1,"highlight_end":39},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                if sigs.len() == 0 {","highlight_start":1,"highlight_end":37},{"text":"                    return Err(BLST_ERROR::BLST_AGGR_TYPE_MISMATCH);","highlight_start":1,"highlight_end":69},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if sigs_groupcheck {","highlight_start":1,"highlight_end":37},{"text":"                    // We can't actually judge if input is individual or","highlight_start":1,"highlight_end":73},{"text":"                    // aggregated signature, so we can't enforce infinitiy","highlight_start":1,"highlight_end":75},{"text":"                    // check.","highlight_start":1,"highlight_end":30},{"text":"                    sigs[0].validate(false)?;","highlight_start":1,"highlight_end":46},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut agg_sig = AggregateSignature::from_signature(sigs[0]);","highlight_start":1,"highlight_end":79},{"text":"                for s in sigs.iter().skip(1) {","highlight_start":1,"highlight_end":47},{"text":"                    if sigs_groupcheck {","highlight_start":1,"highlight_end":41},{"text":"                        s.validate(false)?;","highlight_start":1,"highlight_end":44},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        $sig_add_or_dbl_aff(","highlight_start":1,"highlight_end":45},{"text":"                            &mut agg_sig.point,","highlight_start":1,"highlight_end":48},{"text":"                            &agg_sig.point,","highlight_start":1,"highlight_end":44},{"text":"                            &s.point,","highlight_start":1,"highlight_end":38},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(agg_sig)","highlight_start":1,"highlight_end":28},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn aggregate_serialized(","highlight_start":1,"highlight_end":41},{"text":"                sigs: &[&[u8]],","highlight_start":1,"highlight_end":32},{"text":"                sigs_groupcheck: bool,","highlight_start":1,"highlight_end":39},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                // TODO - threading","highlight_start":1,"highlight_end":36},{"text":"                if sigs.len() == 0 {","highlight_start":1,"highlight_end":37},{"text":"                    return Err(BLST_ERROR::BLST_AGGR_TYPE_MISMATCH);","highlight_start":1,"highlight_end":69},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut sig = if sigs_groupcheck {","highlight_start":1,"highlight_end":51},{"text":"                    Signature::sig_validate(sigs[0], false)?","highlight_start":1,"highlight_end":61},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Signature::from_bytes(sigs[0])?","highlight_start":1,"highlight_end":52},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut agg_sig = AggregateSignature::from_signature(&sig);","highlight_start":1,"highlight_end":76},{"text":"                for s in sigs.iter().skip(1) {","highlight_start":1,"highlight_end":47},{"text":"                    sig = if sigs_groupcheck {","highlight_start":1,"highlight_end":47},{"text":"                        Signature::sig_validate(s, false)?","highlight_start":1,"highlight_end":59},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        Signature::from_bytes(s)?","highlight_start":1,"highlight_end":50},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        $sig_add_or_dbl_aff(","highlight_start":1,"highlight_end":45},{"text":"                            &mut agg_sig.point,","highlight_start":1,"highlight_end":48},{"text":"                            &agg_sig.point,","highlight_start":1,"highlight_end":44},{"text":"                            &sig.point,","highlight_start":1,"highlight_end":40},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(agg_sig)","highlight_start":1,"highlight_end":28},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn add_aggregate(&mut self, agg_sig: &AggregateSignature) {","highlight_start":1,"highlight_end":76},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_add_or_dbl(","highlight_start":1,"highlight_end":37},{"text":"                        &mut self.point,","highlight_start":1,"highlight_end":41},{"text":"                        &self.point,","highlight_start":1,"highlight_end":37},{"text":"                        &agg_sig.point,","highlight_start":1,"highlight_end":40},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn add_signature(","highlight_start":1,"highlight_end":34},{"text":"                &mut self,","highlight_start":1,"highlight_end":27},{"text":"                sig: &Signature,","highlight_start":1,"highlight_end":33},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"            ) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":42},{"text":"                if sig_groupcheck {","highlight_start":1,"highlight_end":36},{"text":"                    sig.validate(false)?;","highlight_start":1,"highlight_end":42},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_add_or_dbl_aff(","highlight_start":1,"highlight_end":41},{"text":"                        &mut self.point,","highlight_start":1,"highlight_end":41},{"text":"                        &self.point,","highlight_start":1,"highlight_end":37},{"text":"                        &sig.point,","highlight_start":1,"highlight_end":36},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn subgroup_check(&self) -> bool {","highlight_start":1,"highlight_end":51},{"text":"                unsafe { $sig_aggr_in_group(&self.point) }","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[cfg(test)]","highlight_start":1,"highlight_end":21},{"text":"        mod tests {","highlight_start":1,"highlight_end":20},{"text":"            use super::*;","highlight_start":1,"highlight_end":26},{"text":"            use rand::{RngCore, SeedableRng};","highlight_start":1,"highlight_end":46},{"text":"            use rand_chacha::ChaCha20Rng;","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Testing only - do not use for production","highlight_start":1,"highlight_end":56},{"text":"            pub fn gen_random_key(","highlight_start":1,"highlight_end":35},{"text":"                rng: &mut rand_chacha::ChaCha20Rng,","highlight_start":1,"highlight_end":52},{"text":"            ) -> SecretKey {","highlight_start":1,"highlight_end":29},{"text":"                let mut ikm = [0u8; 32];","highlight_start":1,"highlight_end":41},{"text":"                rng.fill_bytes(&mut ikm);","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut sk = <blst_scalar>::default();","highlight_start":1,"highlight_end":55},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    blst_keygen(&mut sk, ikm.as_ptr(), 32, ptr::null(), 0);","highlight_start":1,"highlight_end":76},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                SecretKey { value: sk }","highlight_start":1,"highlight_end":40},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[test]","highlight_start":1,"highlight_end":20},{"text":"            fn test_sign() {","highlight_start":1,"highlight_end":29},{"text":"                let ikm: [u8; 32] = [","highlight_start":1,"highlight_end":38},{"text":"                    0x93, 0xad, 0x7e, 0x65, 0xde, 0xad, 0x05, 0x2a, 0x08, 0x3a,","highlight_start":1,"highlight_end":80},{"text":"                    0x91, 0x0c, 0x8b, 0x72, 0x85, 0x91, 0x46, 0x4c, 0xca, 0x56,","highlight_start":1,"highlight_end":80},{"text":"                    0x60, 0x5b, 0xb0, 0x56, 0xed, 0xfe, 0x2b, 0x60, 0xa6, 0x3c,","highlight_start":1,"highlight_end":80},{"text":"                    0x48, 0x99,","highlight_start":1,"highlight_end":32},{"text":"                ];","highlight_start":1,"highlight_end":19},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sk = SecretKey::key_gen(&ikm, &[]).unwrap();","highlight_start":1,"highlight_end":65},{"text":"                let pk = sk.sk_to_pk();","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let dst = b\"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_\";","highlight_start":1,"highlight_end":74},{"text":"                let msg = b\"hello foo\";","highlight_start":1,"highlight_end":40},{"text":"                let sig = sk.sign(msg, dst, &[]);","highlight_start":1,"highlight_end":50},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let err = sig.verify(true, msg, dst, &[], &pk, true);","highlight_start":1,"highlight_end":70},{"text":"                assert_eq!(err, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[test]","highlight_start":1,"highlight_end":20},{"text":"            fn test_aggregate() {","highlight_start":1,"highlight_end":34},{"text":"                let num_msgs = 10;","highlight_start":1,"highlight_end":35},{"text":"                let dst = b\"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_\";","highlight_start":1,"highlight_end":74},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let seed = [0u8; 32];","highlight_start":1,"highlight_end":38},{"text":"                let mut rng = ChaCha20Rng::from_seed(seed);","highlight_start":1,"highlight_end":60},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sks: Vec<_> =","highlight_start":1,"highlight_end":34},{"text":"                    (0..num_msgs).map(|_| gen_random_key(&mut rng)).collect();","highlight_start":1,"highlight_end":79},{"text":"                let pks =","highlight_start":1,"highlight_end":26},{"text":"                    sks.iter().map(|sk| sk.sk_to_pk()).collect::<Vec<_>>();","highlight_start":1,"highlight_end":76},{"text":"                let pks_refs: Vec<&PublicKey> =","highlight_start":1,"highlight_end":48},{"text":"                    pks.iter().map(|pk| pk).collect();","highlight_start":1,"highlight_end":55},{"text":"                let pks_rev: Vec<&PublicKey> =","highlight_start":1,"highlight_end":47},{"text":"                    pks.iter().rev().map(|pk| pk).collect();","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_comp = pks[0].compress();","highlight_start":1,"highlight_end":49},{"text":"                let pk_uncomp = PublicKey::uncompress(&pk_comp);","highlight_start":1,"highlight_end":65},{"text":"                assert_eq!(pk_uncomp.is_ok(), true);","highlight_start":1,"highlight_end":53},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut msgs: Vec<Vec<u8>> = vec![vec![]; num_msgs];","highlight_start":1,"highlight_end":69},{"text":"                for i in 0..num_msgs {","highlight_start":1,"highlight_end":39},{"text":"                    let msg_len = (rng.next_u64() & 0x3F) + 1;","highlight_start":1,"highlight_end":63},{"text":"                    msgs[i] = vec![0u8; msg_len as usize];","highlight_start":1,"highlight_end":59},{"text":"                    rng.fill_bytes(&mut msgs[i]);","highlight_start":1,"highlight_end":50},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let msgs_refs: Vec<&[u8]> =","highlight_start":1,"highlight_end":44},{"text":"                    msgs.iter().map(|m| m.as_slice()).collect();","highlight_start":1,"highlight_end":65},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sigs = sks","highlight_start":1,"highlight_end":31},{"text":"                    .iter()","highlight_start":1,"highlight_end":28},{"text":"                    .zip(msgs.iter())","highlight_start":1,"highlight_end":38},{"text":"                    .map(|(sk, m)| (sk.sign(m, dst, &[])))","highlight_start":1,"highlight_end":59},{"text":"                    .collect::<Vec<Signature>>();","highlight_start":1,"highlight_end":50},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut errs = sigs","highlight_start":1,"highlight_end":36},{"text":"                    .iter()","highlight_start":1,"highlight_end":28},{"text":"                    .zip(msgs.iter())","highlight_start":1,"highlight_end":38},{"text":"                    .zip(pks.iter())","highlight_start":1,"highlight_end":37},{"text":"                    .map(|((s, m), pk)| (s.verify(true, m, dst, &[], pk, true)))","highlight_start":1,"highlight_end":81},{"text":"                    .collect::<Vec<BLST_ERROR>>();","highlight_start":1,"highlight_end":51},{"text":"                assert_eq!(errs, vec![BLST_ERROR::BLST_SUCCESS; num_msgs]);","highlight_start":1,"highlight_end":76},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Swap message/public key pairs to create bad signature","highlight_start":1,"highlight_end":73},{"text":"                errs = sigs","highlight_start":1,"highlight_end":28},{"text":"                    .iter()","highlight_start":1,"highlight_end":28},{"text":"                    .zip(msgs.iter())","highlight_start":1,"highlight_end":38},{"text":"                    .zip(pks.iter().rev())","highlight_start":1,"highlight_end":43},{"text":"                    .map(|((s, m), pk)| (s.verify(true, m, dst, &[], pk, true)))","highlight_start":1,"highlight_end":81},{"text":"                    .collect::<Vec<BLST_ERROR>>();","highlight_start":1,"highlight_end":51},{"text":"                assert_ne!(errs, vec![BLST_ERROR::BLST_SUCCESS; num_msgs]);","highlight_start":1,"highlight_end":76},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sig_refs =","highlight_start":1,"highlight_end":31},{"text":"                    sigs.iter().map(|s| s).collect::<Vec<&Signature>>();","highlight_start":1,"highlight_end":73},{"text":"                let agg = match AggregateSignature::aggregate(&sig_refs, true) {","highlight_start":1,"highlight_end":81},{"text":"                    Ok(agg) => agg,","highlight_start":1,"highlight_end":36},{"text":"                    Err(err) => panic!(\"aggregate failure: {:?}\", err),","highlight_start":1,"highlight_end":72},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let agg_sig = agg.to_signature();","highlight_start":1,"highlight_end":50},{"text":"                let mut result = agg_sig","highlight_start":1,"highlight_end":41},{"text":"                    .aggregate_verify(false, &msgs_refs, dst, &pks_refs, false);","highlight_start":1,"highlight_end":81},{"text":"                assert_eq!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Swap message/public key pairs to create bad signature","highlight_start":1,"highlight_end":73},{"text":"                result = agg_sig","highlight_start":1,"highlight_end":33},{"text":"                    .aggregate_verify(false, &msgs_refs, dst, &pks_rev, false);","highlight_start":1,"highlight_end":80},{"text":"                assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[test]","highlight_start":1,"highlight_end":20},{"text":"            fn test_multiple_agg_sigs() {","highlight_start":1,"highlight_end":42},{"text":"                let dst = b\"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_\";","highlight_start":1,"highlight_end":74},{"text":"                let num_pks_per_sig = 10;","highlight_start":1,"highlight_end":42},{"text":"                let num_sigs = 10;","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let seed = [0u8; 32];","highlight_start":1,"highlight_end":38},{"text":"                let mut rng = ChaCha20Rng::from_seed(seed);","highlight_start":1,"highlight_end":60},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut msgs: Vec<Vec<u8>> = vec![vec![]; num_sigs];","highlight_start":1,"highlight_end":69},{"text":"                let mut sigs: Vec<Signature> = Vec::with_capacity(num_sigs);","highlight_start":1,"highlight_end":77},{"text":"                let mut pks: Vec<PublicKey> = Vec::with_capacity(num_sigs);","highlight_start":1,"highlight_end":76},{"text":"                let mut rands: Vec<blst_scalar> = Vec::with_capacity(num_sigs);","highlight_start":1,"highlight_end":80},{"text":"                for i in 0..num_sigs {","highlight_start":1,"highlight_end":39},{"text":"                    // Create public keys","highlight_start":1,"highlight_end":42},{"text":"                    let sks_i: Vec<_> = (0..num_pks_per_sig)","highlight_start":1,"highlight_end":61},{"text":"                        .map(|_| gen_random_key(&mut rng))","highlight_start":1,"highlight_end":59},{"text":"                        .collect();","highlight_start":1,"highlight_end":36},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let pks_i = sks_i","highlight_start":1,"highlight_end":38},{"text":"                        .iter()","highlight_start":1,"highlight_end":32},{"text":"                        .map(|sk| sk.sk_to_pk())","highlight_start":1,"highlight_end":49},{"text":"                        .collect::<Vec<_>>();","highlight_start":1,"highlight_end":46},{"text":"                    let pks_refs_i: Vec<&PublicKey> =","highlight_start":1,"highlight_end":54},{"text":"                        pks_i.iter().map(|pk| pk).collect();","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Create random message for pks to all sign","highlight_start":1,"highlight_end":65},{"text":"                    let msg_len = (rng.next_u64() & 0x3F) + 1;","highlight_start":1,"highlight_end":63},{"text":"                    msgs[i] = vec![0u8; msg_len as usize];","highlight_start":1,"highlight_end":59},{"text":"                    rng.fill_bytes(&mut msgs[i]);","highlight_start":1,"highlight_end":50},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Generate signature for each key pair","highlight_start":1,"highlight_end":60},{"text":"                    let sigs_i = sks_i","highlight_start":1,"highlight_end":39},{"text":"                        .iter()","highlight_start":1,"highlight_end":32},{"text":"                        .map(|sk| sk.sign(&msgs[i], dst, &[]))","highlight_start":1,"highlight_end":63},{"text":"                        .collect::<Vec<Signature>>();","highlight_start":1,"highlight_end":54},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Test each current single signature","highlight_start":1,"highlight_end":58},{"text":"                    let errs = sigs_i","highlight_start":1,"highlight_end":38},{"text":"                        .iter()","highlight_start":1,"highlight_end":32},{"text":"                        .zip(pks_i.iter())","highlight_start":1,"highlight_end":43},{"text":"                        .map(|(s, pk)| {","highlight_start":1,"highlight_end":41},{"text":"                            (s.verify(true, &msgs[i], dst, &[], pk, true))","highlight_start":1,"highlight_end":75},{"text":"                        })","highlight_start":1,"highlight_end":27},{"text":"                        .collect::<Vec<BLST_ERROR>>();","highlight_start":1,"highlight_end":55},{"text":"                    assert_eq!(","highlight_start":1,"highlight_end":32},{"text":"                        errs,","highlight_start":1,"highlight_end":30},{"text":"                        vec![BLST_ERROR::BLST_SUCCESS; num_pks_per_sig]","highlight_start":1,"highlight_end":72},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let sig_refs_i =","highlight_start":1,"highlight_end":37},{"text":"                        sigs_i.iter().map(|s| s).collect::<Vec<&Signature>>();","highlight_start":1,"highlight_end":79},{"text":"                    let agg_i =","highlight_start":1,"highlight_end":32},{"text":"                        match AggregateSignature::aggregate(&sig_refs_i, false)","highlight_start":1,"highlight_end":80},{"text":"                        {","highlight_start":1,"highlight_end":26},{"text":"                            Ok(agg_i) => agg_i,","highlight_start":1,"highlight_end":48},{"text":"                            Err(err) => panic!(\"aggregate failure: {:?}\", err),","highlight_start":1,"highlight_end":80},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Test current aggregate signature","highlight_start":1,"highlight_end":56},{"text":"                    sigs.push(agg_i.to_signature());","highlight_start":1,"highlight_end":53},{"text":"                    let mut result = sigs[i].fast_aggregate_verify(","highlight_start":1,"highlight_end":68},{"text":"                        false,","highlight_start":1,"highlight_end":31},{"text":"                        &msgs[i],","highlight_start":1,"highlight_end":34},{"text":"                        dst,","highlight_start":1,"highlight_end":29},{"text":"                        &pks_refs_i,","highlight_start":1,"highlight_end":37},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                    assert_eq!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":66},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // negative test","highlight_start":1,"highlight_end":37},{"text":"                    if i != 0 {","highlight_start":1,"highlight_end":32},{"text":"                        result = sigs[i - 1].fast_aggregate_verify(","highlight_start":1,"highlight_end":68},{"text":"                            false,","highlight_start":1,"highlight_end":35},{"text":"                            &msgs[i],","highlight_start":1,"highlight_end":38},{"text":"                            dst,","highlight_start":1,"highlight_end":33},{"text":"                            &pks_refs_i,","highlight_start":1,"highlight_end":41},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                        assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":70},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // aggregate public keys and push into vec","highlight_start":1,"highlight_end":63},{"text":"                    let agg_pk_i =","highlight_start":1,"highlight_end":35},{"text":"                        match AggregatePublicKey::aggregate(&pks_refs_i, false)","highlight_start":1,"highlight_end":80},{"text":"                        {","highlight_start":1,"highlight_end":26},{"text":"                            Ok(agg_pk_i) => agg_pk_i,","highlight_start":1,"highlight_end":54},{"text":"                            Err(err) => panic!(\"aggregate failure: {:?}\", err),","highlight_start":1,"highlight_end":80},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                    pks.push(agg_pk_i.to_public_key());","highlight_start":1,"highlight_end":56},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Test current aggregate signature with aggregated pks","highlight_start":1,"highlight_end":76},{"text":"                    result = sigs[i].fast_aggregate_verify_pre_aggregated(","highlight_start":1,"highlight_end":75},{"text":"                        false, &msgs[i], dst, &pks[i],","highlight_start":1,"highlight_end":55},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                    assert_eq!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":66},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // negative test","highlight_start":1,"highlight_end":37},{"text":"                    if i != 0 {","highlight_start":1,"highlight_end":32},{"text":"                        result = sigs[i - 1]","highlight_start":1,"highlight_end":45},{"text":"                            .fast_aggregate_verify_pre_aggregated(","highlight_start":1,"highlight_end":67},{"text":"                                false, &msgs[i], dst, &pks[i],","highlight_start":1,"highlight_end":63},{"text":"                            );","highlight_start":1,"highlight_end":31},{"text":"                        assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":70},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // create random values","highlight_start":1,"highlight_end":44},{"text":"                    let mut vals = [0u64; 4];","highlight_start":1,"highlight_end":46},{"text":"                    vals[0] = rng.next_u64();","highlight_start":1,"highlight_end":46},{"text":"                    while vals[0] == 0 {","highlight_start":1,"highlight_end":41},{"text":"                        // Reject zero as it is used for multiplication.","highlight_start":1,"highlight_end":73},{"text":"                        vals[0] = rng.next_u64();","highlight_start":1,"highlight_end":50},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    let mut rand_i =","highlight_start":1,"highlight_end":37},{"text":"                        std::mem::MaybeUninit::<blst_scalar>::uninit();","highlight_start":1,"highlight_end":72},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        blst_scalar_from_uint64(","highlight_start":1,"highlight_end":49},{"text":"                            rand_i.as_mut_ptr(),","highlight_start":1,"highlight_end":49},{"text":"                            vals.as_ptr(),","highlight_start":1,"highlight_end":43},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                        rands.push(rand_i.assume_init());","highlight_start":1,"highlight_end":58},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let msgs_refs: Vec<&[u8]> =","highlight_start":1,"highlight_end":44},{"text":"                    msgs.iter().map(|m| m.as_slice()).collect();","highlight_start":1,"highlight_end":65},{"text":"                let sig_refs =","highlight_start":1,"highlight_end":31},{"text":"                    sigs.iter().map(|s| s).collect::<Vec<&Signature>>();","highlight_start":1,"highlight_end":73},{"text":"                let pks_refs: Vec<&PublicKey> =","highlight_start":1,"highlight_end":48},{"text":"                    pks.iter().map(|pk| pk).collect();","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let msgs_rev: Vec<&[u8]> =","highlight_start":1,"highlight_end":43},{"text":"                    msgs.iter().rev().map(|m| m.as_slice()).collect();","highlight_start":1,"highlight_end":71},{"text":"                let sig_rev =","highlight_start":1,"highlight_end":30},{"text":"                    sigs.iter().rev().map(|s| s).collect::<Vec<&Signature>>();","highlight_start":1,"highlight_end":79},{"text":"                let pks_rev: Vec<&PublicKey> =","highlight_start":1,"highlight_end":47},{"text":"                    pks.iter().rev().map(|pk| pk).collect();","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut result =","highlight_start":1,"highlight_end":33},{"text":"                    Signature::verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":69},{"text":"                        &msgs_refs, dst, &pks_refs, false, &sig_refs, true,","highlight_start":1,"highlight_end":76},{"text":"                        &rands, 64,","highlight_start":1,"highlight_end":36},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                assert_eq!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // negative tests (use reverse msgs, pks, and sigs)","highlight_start":1,"highlight_end":68},{"text":"                result = Signature::verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":74},{"text":"                    &msgs_rev, dst, &pks_refs, false, &sig_refs, true, &rands,","highlight_start":1,"highlight_end":79},{"text":"                    64,","highlight_start":1,"highlight_end":24},{"text":"                );","highlight_start":1,"highlight_end":19},{"text":"                assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                result = Signature::verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":74},{"text":"                    &msgs_refs, dst, &pks_rev, false, &sig_refs, true, &rands,","highlight_start":1,"highlight_end":79},{"text":"                    64,","highlight_start":1,"highlight_end":24},{"text":"                );","highlight_start":1,"highlight_end":19},{"text":"                assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                result = Signature::verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":74},{"text":"                    &msgs_refs, dst, &pks_refs, false, &sig_rev, true, &rands,","highlight_start":1,"highlight_end":79},{"text":"                    64,","highlight_start":1,"highlight_end":24},{"text":"                );","highlight_start":1,"highlight_end":19},{"text":"                assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[test]","highlight_start":1,"highlight_end":20},{"text":"            fn test_serialization() {","highlight_start":1,"highlight_end":38},{"text":"                let seed = [0u8; 32];","highlight_start":1,"highlight_end":38},{"text":"                let mut rng = ChaCha20Rng::from_seed(seed);","highlight_start":1,"highlight_end":60},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sk = gen_random_key(&mut rng);","highlight_start":1,"highlight_end":51},{"text":"                let sk2 = gen_random_key(&mut rng);","highlight_start":1,"highlight_end":52},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk = sk.sk_to_pk();","highlight_start":1,"highlight_end":40},{"text":"                let pk_comp = pk.compress();","highlight_start":1,"highlight_end":45},{"text":"                let pk_ser = pk.serialize();","highlight_start":1,"highlight_end":45},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_uncomp = PublicKey::uncompress(&pk_comp);","highlight_start":1,"highlight_end":65},{"text":"                assert_eq!(pk_uncomp.is_ok(), true);","highlight_start":1,"highlight_end":53},{"text":"                assert_eq!(pk_uncomp.unwrap(), pk);","highlight_start":1,"highlight_end":52},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_deser = PublicKey::deserialize(&pk_ser);","highlight_start":1,"highlight_end":64},{"text":"                assert_eq!(pk_deser.is_ok(), true);","highlight_start":1,"highlight_end":52},{"text":"                assert_eq!(pk_deser.unwrap(), pk);","highlight_start":1,"highlight_end":51},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk2 = sk2.sk_to_pk();","highlight_start":1,"highlight_end":42},{"text":"                let pk_comp2 = pk2.compress();","highlight_start":1,"highlight_end":47},{"text":"                let pk_ser2 = pk2.serialize();","highlight_start":1,"highlight_end":47},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_uncomp2 = PublicKey::uncompress(&pk_comp2);","highlight_start":1,"highlight_end":67},{"text":"                assert_eq!(pk_uncomp2.is_ok(), true);","highlight_start":1,"highlight_end":54},{"text":"                assert_eq!(pk_uncomp2.unwrap(), pk2);","highlight_start":1,"highlight_end":54},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_deser2 = PublicKey::deserialize(&pk_ser2);","highlight_start":1,"highlight_end":66},{"text":"                assert_eq!(pk_deser2.is_ok(), true);","highlight_start":1,"highlight_end":53},{"text":"                assert_eq!(pk_deser2.unwrap(), pk2);","highlight_start":1,"highlight_end":53},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                assert_ne!(pk, pk2);","highlight_start":1,"highlight_end":37},{"text":"                assert_ne!(pk_uncomp.unwrap(), pk2);","highlight_start":1,"highlight_end":53},{"text":"                assert_ne!(pk_deser.unwrap(), pk2);","highlight_start":1,"highlight_end":52},{"text":"                assert_ne!(pk_uncomp2.unwrap(), pk);","highlight_start":1,"highlight_end":53},{"text":"                assert_ne!(pk_deser2.unwrap(), pk);","highlight_start":1,"highlight_end":52},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: variable does not need to be mutable\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/azureuser/blst/bindings/rust/src/lib.rs:779:21\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m779\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m                let mut acc = rx.recv().unwrap();\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: remove this `mut`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1472\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    sig_variant_impl!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1473\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"MinPk\",\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1474\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        blst_p1,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1475\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        blst_p1_affine,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1509\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        blst_p2_in_g2,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1510\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    );\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|______-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_mut)]` on by default\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this warning originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"variable does not need to be mutable","code":{"code":"unused_mut","explanation":null},"level":"warning","spans":[{"file_name":"/home/azureuser/blst/bindings/rust/src/lib.rs","byte_start":25106,"byte_end":25113,"line_start":779,"line_end":779,"column_start":21,"column_end":28,"is_primary":true,"text":[{"text":"                let mut acc = rx.recv().unwrap();","highlight_start":21,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/azureuser/blst/bindings/rust/src/lib.rs","byte_start":53005,"byte_end":54021,"line_start":1516,"line_end":1554,"column_start":5,"column_end":7,"is_primary":false,"text":[{"text":"    sig_variant_impl!(","highlight_start":5,"highlight_end":23},{"text":"        \"MinSig\",","highlight_start":1,"highlight_end":18},{"text":"        blst_p2,","highlight_start":1,"highlight_end":17},{"text":"        blst_p2_affine,","highlight_start":1,"highlight_end":24},{"text":"        blst_p1,","highlight_start":1,"highlight_end":17},{"text":"        blst_p1_affine,","highlight_start":1,"highlight_end":24},{"text":"        blst_sk_to_pk2_in_g2,","highlight_start":1,"highlight_end":30},{"text":"        true,","highlight_start":1,"highlight_end":14},{"text":"        blst_hash_to_g1,","highlight_start":1,"highlight_end":25},{"text":"        blst_sign_pk2_in_g2,","highlight_start":1,"highlight_end":29},{"text":"        blst_p2_affine_is_equal,","highlight_start":1,"highlight_end":33},{"text":"        blst_p1_affine_is_equal,","highlight_start":1,"highlight_end":33},{"text":"        blst_core_verify_pk_in_g2,","highlight_start":1,"highlight_end":35},{"text":"        blst_p2_affine_in_g2,","highlight_start":1,"highlight_end":30},{"text":"        blst_p2_to_affine,","highlight_start":1,"highlight_end":27},{"text":"        blst_p2_from_affine,","highlight_start":1,"highlight_end":29},{"text":"        blst_p2_affine_serialize,","highlight_start":1,"highlight_end":34},{"text":"        blst_p2_affine_compress,","highlight_start":1,"highlight_end":33},{"text":"        blst_p2_deserialize,","highlight_start":1,"highlight_end":29},{"text":"        blst_p2_uncompress,","highlight_start":1,"highlight_end":28},{"text":"        96,","highlight_start":1,"highlight_end":12},{"text":"        192,","highlight_start":1,"highlight_end":13},{"text":"        blst_p1_affine_in_g1,","highlight_start":1,"highlight_end":30},{"text":"        blst_p1_to_affine,","highlight_start":1,"highlight_end":27},{"text":"        blst_p1_from_affine,","highlight_start":1,"highlight_end":29},{"text":"        blst_p1_affine_serialize,","highlight_start":1,"highlight_end":34},{"text":"        blst_p1_affine_compress,","highlight_start":1,"highlight_end":33},{"text":"        blst_p1_deserialize,","highlight_start":1,"highlight_end":29},{"text":"        blst_p1_uncompress,","highlight_start":1,"highlight_end":28},{"text":"        48,","highlight_start":1,"highlight_end":12},{"text":"        96,","highlight_start":1,"highlight_end":12},{"text":"        blst_p2_add_or_double,","highlight_start":1,"highlight_end":31},{"text":"        blst_p2_add_or_double_affine,","highlight_start":1,"highlight_end":38},{"text":"        blst_p1_add_or_double,","highlight_start":1,"highlight_end":31},{"text":"        blst_p1_add_or_double_affine,","highlight_start":1,"highlight_end":38},{"text":"        blst_p2_affine_is_inf,","highlight_start":1,"highlight_end":31},{"text":"        blst_p1_affine_is_inf,","highlight_start":1,"highlight_end":31},{"text":"        blst_p1_in_g1,","highlight_start":1,"highlight_end":23},{"text":"    );","highlight_start":1,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"sig_variant_impl!","def_site_span":{"file_name":"/home/azureuser/blst/bindings/rust/src/lib.rs","byte_start":7790,"byte_end":51903,"line_start":283,"line_end":1467,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! sig_variant_impl {","highlight_start":1,"highlight_end":32},{"text":"    (","highlight_start":1,"highlight_end":6},{"text":"        $name:expr,","highlight_start":1,"highlight_end":20},{"text":"        $pk:ty,","highlight_start":1,"highlight_end":16},{"text":"        $pk_aff:ty,","highlight_start":1,"highlight_end":20},{"text":"        $sig:ty,","highlight_start":1,"highlight_end":17},{"text":"        $sig_aff:ty,","highlight_start":1,"highlight_end":21},{"text":"        $sk_to_pk:ident,","highlight_start":1,"highlight_end":25},{"text":"        $hash_or_encode:expr,","highlight_start":1,"highlight_end":30},{"text":"        $hash_or_encode_to:ident,","highlight_start":1,"highlight_end":34},{"text":"        $sign:ident,","highlight_start":1,"highlight_end":21},{"text":"        $pk_eq:ident,","highlight_start":1,"highlight_end":22},{"text":"        $sig_eq:ident,","highlight_start":1,"highlight_end":23},{"text":"        $verify:ident,","highlight_start":1,"highlight_end":23},{"text":"        $pk_in_group:ident,","highlight_start":1,"highlight_end":28},{"text":"        $pk_to_aff:ident,","highlight_start":1,"highlight_end":26},{"text":"        $pk_from_aff:ident,","highlight_start":1,"highlight_end":28},{"text":"        $pk_ser:ident,","highlight_start":1,"highlight_end":23},{"text":"        $pk_comp:ident,","highlight_start":1,"highlight_end":24},{"text":"        $pk_deser:ident,","highlight_start":1,"highlight_end":25},{"text":"        $pk_uncomp:ident,","highlight_start":1,"highlight_end":26},{"text":"        $pk_comp_size:expr,","highlight_start":1,"highlight_end":28},{"text":"        $pk_ser_size:expr,","highlight_start":1,"highlight_end":27},{"text":"        $sig_in_group:ident,","highlight_start":1,"highlight_end":29},{"text":"        $sig_to_aff:ident,","highlight_start":1,"highlight_end":27},{"text":"        $sig_from_aff:ident,","highlight_start":1,"highlight_end":29},{"text":"        $sig_ser:ident,","highlight_start":1,"highlight_end":24},{"text":"        $sig_comp:ident,","highlight_start":1,"highlight_end":25},{"text":"        $sig_deser:ident,","highlight_start":1,"highlight_end":26},{"text":"        $sig_uncomp:ident,","highlight_start":1,"highlight_end":27},{"text":"        $sig_comp_size:expr,","highlight_start":1,"highlight_end":29},{"text":"        $sig_ser_size:expr,","highlight_start":1,"highlight_end":28},{"text":"        $pk_add_or_dbl:ident,","highlight_start":1,"highlight_end":30},{"text":"        $pk_add_or_dbl_aff:ident,","highlight_start":1,"highlight_end":34},{"text":"        $sig_add_or_dbl:ident,","highlight_start":1,"highlight_end":31},{"text":"        $sig_add_or_dbl_aff:ident,","highlight_start":1,"highlight_end":35},{"text":"        $pk_is_inf:ident,","highlight_start":1,"highlight_end":26},{"text":"        $sig_is_inf:ident,","highlight_start":1,"highlight_end":27},{"text":"        $sig_aggr_in_group:ident,","highlight_start":1,"highlight_end":34},{"text":"    ) => {","highlight_start":1,"highlight_end":11},{"text":"        /// Secret Key","highlight_start":1,"highlight_end":23},{"text":"        #[derive(Default, Debug, Clone, Zeroize)]","highlight_start":1,"highlight_end":50},{"text":"        #[zeroize(drop)]","highlight_start":1,"highlight_end":25},{"text":"        pub struct SecretKey {","highlight_start":1,"highlight_end":31},{"text":"            value: blst_scalar,","highlight_start":1,"highlight_end":32},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl SecretKey {","highlight_start":1,"highlight_end":25},{"text":"            /// Deterministically generate a secret key from key material","highlight_start":1,"highlight_end":74},{"text":"            pub fn key_gen(","highlight_start":1,"highlight_end":28},{"text":"                ikm: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                key_info: &[u8],","highlight_start":1,"highlight_end":33},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                if ikm.len() < 32 {","highlight_start":1,"highlight_end":36},{"text":"                    return Err(BLST_ERROR::BLST_BAD_ENCODING);","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut sk = SecretKey::default();","highlight_start":1,"highlight_end":51},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    blst_keygen(","highlight_start":1,"highlight_end":33},{"text":"                        &mut sk.value,","highlight_start":1,"highlight_end":39},{"text":"                        ikm.as_ptr(),","highlight_start":1,"highlight_end":38},{"text":"                        ikm.len(),","highlight_start":1,"highlight_end":35},{"text":"                        key_info.as_ptr(),","highlight_start":1,"highlight_end":43},{"text":"                        key_info.len(),","highlight_start":1,"highlight_end":40},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(sk)","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // sk_to_pk","highlight_start":1,"highlight_end":24},{"text":"            pub fn sk_to_pk(&self) -> PublicKey {","highlight_start":1,"highlight_end":50},{"text":"                // TODO - would the user like the serialized/compressed pk as well?","highlight_start":1,"highlight_end":84},{"text":"                let mut pk_aff = PublicKey::default();","highlight_start":1,"highlight_end":55},{"text":"                //let mut pk_ser = [0u8; $pk_ser_size];","highlight_start":1,"highlight_end":56},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sk_to_pk(","highlight_start":1,"highlight_end":31},{"text":"                        //pk_ser.as_mut_ptr(),","highlight_start":1,"highlight_end":47},{"text":"                        ptr::null_mut(),","highlight_start":1,"highlight_end":41},{"text":"                        &mut pk_aff.point,","highlight_start":1,"highlight_end":43},{"text":"                        &self.value,","highlight_start":1,"highlight_end":37},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                pk_aff","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Sign","highlight_start":1,"highlight_end":20},{"text":"            pub fn sign(","highlight_start":1,"highlight_end":25},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                msg: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                aug: &[u8],","highlight_start":1,"highlight_end":28},{"text":"            ) -> Signature {","highlight_start":1,"highlight_end":29},{"text":"                // TODO - would the user like the serialized/compressed sig as well?","highlight_start":1,"highlight_end":85},{"text":"                let mut q = <$sig>::default();","highlight_start":1,"highlight_end":47},{"text":"                let mut sig_aff = <$sig_aff>::default();","highlight_start":1,"highlight_end":57},{"text":"                //let mut sig_ser = [0u8; $sig_ser_size];","highlight_start":1,"highlight_end":58},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $hash_or_encode_to(","highlight_start":1,"highlight_end":40},{"text":"                        &mut q,","highlight_start":1,"highlight_end":32},{"text":"                        msg.as_ptr(),","highlight_start":1,"highlight_end":38},{"text":"                        msg.len(),","highlight_start":1,"highlight_end":35},{"text":"                        dst.as_ptr(),","highlight_start":1,"highlight_end":38},{"text":"                        dst.len(),","highlight_start":1,"highlight_end":35},{"text":"                        aug.as_ptr(),","highlight_start":1,"highlight_end":38},{"text":"                        aug.len(),","highlight_start":1,"highlight_end":35},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                    $sign(ptr::null_mut(), &mut sig_aff, &q, &self.value);","highlight_start":1,"highlight_end":75},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Signature { point: sig_aff }","highlight_start":1,"highlight_end":45},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // TODO - formally speaking application is entitled to have","highlight_start":1,"highlight_end":72},{"text":"            // ultimate control over secret key storage, which means that","highlight_start":1,"highlight_end":74},{"text":"            // corresponding serialization/deserialization subroutines","highlight_start":1,"highlight_end":71},{"text":"            // should accept reference to where to store the result, as","highlight_start":1,"highlight_end":72},{"text":"            // opposite to returning one.","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // serialize","highlight_start":1,"highlight_end":25},{"text":"            pub fn serialize(&self) -> [u8; 32] {","highlight_start":1,"highlight_end":50},{"text":"                let mut sk_out = [0; 32];","highlight_start":1,"highlight_end":42},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    blst_bendian_from_scalar(sk_out.as_mut_ptr(), &self.value);","highlight_start":1,"highlight_end":80},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                sk_out","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // deserialize","highlight_start":1,"highlight_end":27},{"text":"            pub fn deserialize(sk_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":75},{"text":"                let mut sk = blst_scalar::default();","highlight_start":1,"highlight_end":53},{"text":"                if sk_in.len() != 32 {","highlight_start":1,"highlight_end":39},{"text":"                    return Err(BLST_ERROR::BLST_BAD_ENCODING);","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    blst_scalar_from_bendian(&mut sk, sk_in.as_ptr());","highlight_start":1,"highlight_end":71},{"text":"                    if !blst_sk_check(&sk) {","highlight_start":1,"highlight_end":45},{"text":"                        return Err(BLST_ERROR::BLST_BAD_ENCODING);","highlight_start":1,"highlight_end":67},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(Self { value: sk })","highlight_start":1,"highlight_end":39},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_bytes(&self) -> [u8; 32] {","highlight_start":1,"highlight_end":49},{"text":"                SecretKey::serialize(&self)","highlight_start":1,"highlight_end":44},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_bytes(sk_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":74},{"text":"                SecretKey::deserialize(sk_in)","highlight_start":1,"highlight_end":46},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[derive(Default, Debug, Clone, Copy)]","highlight_start":1,"highlight_end":47},{"text":"        pub struct PublicKey {","highlight_start":1,"highlight_end":31},{"text":"            point: $pk_aff,","highlight_start":1,"highlight_end":28},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl PublicKey {","highlight_start":1,"highlight_end":25},{"text":"            // Core operations","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // key_validate","highlight_start":1,"highlight_end":28},{"text":"            pub fn validate(&self) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":63},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    if $pk_is_inf(&self.point) {","highlight_start":1,"highlight_end":49},{"text":"                        return Err(BLST_ERROR::BLST_PK_IS_INFINITY);","highlight_start":1,"highlight_end":69},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    if !$pk_in_group(&self.point) {","highlight_start":1,"highlight_end":52},{"text":"                        return Err(BLST_ERROR::BLST_POINT_NOT_IN_GROUP);","highlight_start":1,"highlight_end":73},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn key_validate(key: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":74},{"text":"                let pk = PublicKey::from_bytes(key)?;","highlight_start":1,"highlight_end":54},{"text":"                pk.validate()?;","highlight_start":1,"highlight_end":32},{"text":"                Ok(pk)","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_aggregate(agg_pk: &AggregatePublicKey) -> Self {","highlight_start":1,"highlight_end":73},{"text":"                let mut pk_aff = <$pk_aff>::default();","highlight_start":1,"highlight_end":55},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_to_aff(&mut pk_aff, &agg_pk.point);","highlight_start":1,"highlight_end":60},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Self { point: pk_aff }","highlight_start":1,"highlight_end":39},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Serdes","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn compress(&self) -> [u8; $pk_comp_size] {","highlight_start":1,"highlight_end":60},{"text":"                let mut pk_comp = [0u8; $pk_comp_size];","highlight_start":1,"highlight_end":56},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_comp(pk_comp.as_mut_ptr(), &self.point);","highlight_start":1,"highlight_end":65},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                pk_comp","highlight_start":1,"highlight_end":24},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn serialize(&self) -> [u8; $pk_ser_size] {","highlight_start":1,"highlight_end":60},{"text":"                let mut pk_out = [0u8; $pk_ser_size];","highlight_start":1,"highlight_end":54},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_ser(pk_out.as_mut_ptr(), &self.point);","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                pk_out","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn uncompress(pk_comp: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":76},{"text":"                if pk_comp.len() == $pk_comp_size && (pk_comp[0] & 0x80) != 0 {","highlight_start":1,"highlight_end":80},{"text":"                    let mut pk = <$pk_aff>::default();","highlight_start":1,"highlight_end":55},{"text":"                    let err = unsafe { $pk_uncomp(&mut pk, pk_comp.as_ptr()) };","highlight_start":1,"highlight_end":80},{"text":"                    if err != BLST_ERROR::BLST_SUCCESS {","highlight_start":1,"highlight_end":57},{"text":"                        return Err(err);","highlight_start":1,"highlight_end":41},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(Self { point: pk })","highlight_start":1,"highlight_end":43},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Err(BLST_ERROR::BLST_BAD_ENCODING)","highlight_start":1,"highlight_end":55},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn deserialize(pk_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":75},{"text":"                if (pk_in.len() == $pk_ser_size && (pk_in[0] & 0x80) == 0)","highlight_start":1,"highlight_end":75},{"text":"                    || (pk_in.len() == $pk_comp_size && (pk_in[0] & 0x80) != 0)","highlight_start":1,"highlight_end":80},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    let mut pk = <$pk_aff>::default();","highlight_start":1,"highlight_end":55},{"text":"                    let err = unsafe { $pk_deser(&mut pk, pk_in.as_ptr()) };","highlight_start":1,"highlight_end":77},{"text":"                    if err != BLST_ERROR::BLST_SUCCESS {","highlight_start":1,"highlight_end":57},{"text":"                        return Err(err);","highlight_start":1,"highlight_end":41},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(Self { point: pk })","highlight_start":1,"highlight_end":43},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Err(BLST_ERROR::BLST_BAD_ENCODING)","highlight_start":1,"highlight_end":55},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_bytes(pk_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":74},{"text":"                PublicKey::deserialize(pk_in)","highlight_start":1,"highlight_end":46},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_bytes(&self) -> [u8; $pk_comp_size] {","highlight_start":1,"highlight_end":60},{"text":"                self.compress()","highlight_start":1,"highlight_end":32},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Trait for equality comparisons which are equivalence relations.","highlight_start":1,"highlight_end":75},{"text":"        //","highlight_start":1,"highlight_end":11},{"text":"        // This means, that in addition to a == b and a != b being strict","highlight_start":1,"highlight_end":74},{"text":"        // inverses, the equality must be reflexive, symmetric and transitive.","highlight_start":1,"highlight_end":79},{"text":"        impl Eq for PublicKey {}","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl PartialEq for PublicKey {","highlight_start":1,"highlight_end":39},{"text":"            fn eq(&self, other: &Self) -> bool {","highlight_start":1,"highlight_end":49},{"text":"                unsafe { $pk_eq(&self.point, &other.point) }","highlight_start":1,"highlight_end":61},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[derive(Debug, Clone, Copy)]","highlight_start":1,"highlight_end":38},{"text":"        pub struct AggregatePublicKey {","highlight_start":1,"highlight_end":40},{"text":"            point: $pk,","highlight_start":1,"highlight_end":24},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl AggregatePublicKey {","highlight_start":1,"highlight_end":34},{"text":"            pub fn from_public_key(pk: &PublicKey) -> Self {","highlight_start":1,"highlight_end":61},{"text":"                let mut agg_pk = <$pk>::default();","highlight_start":1,"highlight_end":51},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_from_aff(&mut agg_pk, &pk.point);","highlight_start":1,"highlight_end":58},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Self { point: agg_pk }","highlight_start":1,"highlight_end":39},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_public_key(&self) -> PublicKey {","highlight_start":1,"highlight_end":55},{"text":"                let mut pk = <$pk_aff>::default();","highlight_start":1,"highlight_end":51},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_to_aff(&mut pk, &self.point);","highlight_start":1,"highlight_end":54},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                PublicKey { point: pk }","highlight_start":1,"highlight_end":40},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Aggregate","highlight_start":1,"highlight_end":25},{"text":"            pub fn aggregate(","highlight_start":1,"highlight_end":30},{"text":"                pks: &[&PublicKey],","highlight_start":1,"highlight_end":36},{"text":"                pks_validate: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                if pks.len() == 0 {","highlight_start":1,"highlight_end":36},{"text":"                    return Err(BLST_ERROR::BLST_AGGR_TYPE_MISMATCH);","highlight_start":1,"highlight_end":69},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if pks_validate {","highlight_start":1,"highlight_end":34},{"text":"                    pks[0].validate()?;","highlight_start":1,"highlight_end":40},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut agg_pk = AggregatePublicKey::from_public_key(pks[0]);","highlight_start":1,"highlight_end":78},{"text":"                for s in pks.iter().skip(1) {","highlight_start":1,"highlight_end":46},{"text":"                    if pks_validate {","highlight_start":1,"highlight_end":38},{"text":"                        s.validate()?;","highlight_start":1,"highlight_end":39},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        $pk_add_or_dbl_aff(","highlight_start":1,"highlight_end":44},{"text":"                            &mut agg_pk.point,","highlight_start":1,"highlight_end":47},{"text":"                            &agg_pk.point,","highlight_start":1,"highlight_end":43},{"text":"                            &s.point,","highlight_start":1,"highlight_end":38},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(agg_pk)","highlight_start":1,"highlight_end":27},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn aggregate_serialized(","highlight_start":1,"highlight_end":41},{"text":"                pks: &[&[u8]],","highlight_start":1,"highlight_end":31},{"text":"                pks_validate: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                // TODO - threading","highlight_start":1,"highlight_end":36},{"text":"                if pks.len() == 0 {","highlight_start":1,"highlight_end":36},{"text":"                    return Err(BLST_ERROR::BLST_AGGR_TYPE_MISMATCH);","highlight_start":1,"highlight_end":69},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut pk = if pks_validate {","highlight_start":1,"highlight_end":47},{"text":"                    PublicKey::key_validate(pks[0])?","highlight_start":1,"highlight_end":53},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    PublicKey::from_bytes(pks[0])?","highlight_start":1,"highlight_end":51},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut agg_pk = AggregatePublicKey::from_public_key(&pk);","highlight_start":1,"highlight_end":75},{"text":"                for s in pks.iter().skip(1) {","highlight_start":1,"highlight_end":46},{"text":"                    pk = if pks_validate {","highlight_start":1,"highlight_end":43},{"text":"                        PublicKey::key_validate(s)?","highlight_start":1,"highlight_end":52},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        PublicKey::from_bytes(s)?","highlight_start":1,"highlight_end":50},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        $pk_add_or_dbl_aff(","highlight_start":1,"highlight_end":44},{"text":"                            &mut agg_pk.point,","highlight_start":1,"highlight_end":47},{"text":"                            &agg_pk.point,","highlight_start":1,"highlight_end":43},{"text":"                            &pk.point,","highlight_start":1,"highlight_end":39},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(agg_pk)","highlight_start":1,"highlight_end":27},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn add_aggregate(&mut self, agg_pk: &AggregatePublicKey) {","highlight_start":1,"highlight_end":75},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_add_or_dbl(&mut self.point, &self.point, &agg_pk.point);","highlight_start":1,"highlight_end":81},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn add_public_key(","highlight_start":1,"highlight_end":35},{"text":"                &mut self,","highlight_start":1,"highlight_end":27},{"text":"                pk: &PublicKey,","highlight_start":1,"highlight_end":32},{"text":"                pk_validate: bool,","highlight_start":1,"highlight_end":35},{"text":"            ) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":42},{"text":"                if pk_validate {","highlight_start":1,"highlight_end":33},{"text":"                    pk.validate()?;","highlight_start":1,"highlight_end":36},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_add_or_dbl_aff(&mut self.point, &self.point, &pk.point);","highlight_start":1,"highlight_end":81},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[derive(Debug, Clone, Copy)]","highlight_start":1,"highlight_end":38},{"text":"        pub struct Signature {","highlight_start":1,"highlight_end":31},{"text":"            point: $sig_aff,","highlight_start":1,"highlight_end":29},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl Signature {","highlight_start":1,"highlight_end":25},{"text":"            // sig_infcheck, check for infinity, is a way to avoid going","highlight_start":1,"highlight_end":73},{"text":"            // into resource-consuming verification. Passing 'false' is","highlight_start":1,"highlight_end":72},{"text":"            // always cryptographically safe, but application might want","highlight_start":1,"highlight_end":73},{"text":"            // to guard against obviously bogus individual[!] signatures.","highlight_start":1,"highlight_end":74},{"text":"            pub fn validate(","highlight_start":1,"highlight_end":29},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_infcheck: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":42},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    if sig_infcheck && $sig_is_inf(&self.point) {","highlight_start":1,"highlight_end":66},{"text":"                        return Err(BLST_ERROR::BLST_PK_IS_INFINITY);","highlight_start":1,"highlight_end":69},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    if !$sig_in_group(&self.point) {","highlight_start":1,"highlight_end":53},{"text":"                        return Err(BLST_ERROR::BLST_POINT_NOT_IN_GROUP);","highlight_start":1,"highlight_end":73},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn sig_validate(","highlight_start":1,"highlight_end":33},{"text":"                sig: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                sig_infcheck: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                let sig = Signature::from_bytes(sig)?;","highlight_start":1,"highlight_end":55},{"text":"                sig.validate(sig_infcheck)?;","highlight_start":1,"highlight_end":45},{"text":"                Ok(sig)","highlight_start":1,"highlight_end":24},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn verify(","highlight_start":1,"highlight_end":27},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"                msg: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                aug: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pk: &PublicKey,","highlight_start":1,"highlight_end":32},{"text":"                pk_validate: bool,","highlight_start":1,"highlight_end":35},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                let aug_msg = [aug, msg].concat();","highlight_start":1,"highlight_end":51},{"text":"                self.aggregate_verify(","highlight_start":1,"highlight_end":39},{"text":"                    sig_groupcheck,","highlight_start":1,"highlight_end":36},{"text":"                    &[aug_msg.as_slice()],","highlight_start":1,"highlight_end":43},{"text":"                    dst,","highlight_start":1,"highlight_end":25},{"text":"                    &[pk],","highlight_start":1,"highlight_end":27},{"text":"                    pk_validate,","highlight_start":1,"highlight_end":33},{"text":"                )","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn aggregate_verify(","highlight_start":1,"highlight_end":37},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"                msgs: &[&[u8]],","highlight_start":1,"highlight_end":32},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pks: &[&PublicKey],","highlight_start":1,"highlight_end":36},{"text":"                pks_validate: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                let n_elems = pks.len();","highlight_start":1,"highlight_end":41},{"text":"                if n_elems == 0 || msgs.len() != n_elems {","highlight_start":1,"highlight_end":59},{"text":"                    return BLST_ERROR::BLST_VERIFY_FAIL;","highlight_start":1,"highlight_end":57},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // TODO - check msg uniqueness?","highlight_start":1,"highlight_end":48},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // let pool = da_pool();","highlight_start":1,"highlight_end":41},{"text":"                let (tx, rx) = channel();","highlight_start":1,"highlight_end":42},{"text":"                let counter = Arc::new(AtomicUsize::new(0));","highlight_start":1,"highlight_end":61},{"text":"                let valid = Arc::new(AtomicBool::new(true));","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Bypass 'lifetime limitations by brute force. It works,","highlight_start":1,"highlight_end":74},{"text":"                // because we explicitly join the threads...","highlight_start":1,"highlight_end":61},{"text":"                let raw_pks = unsafe {","highlight_start":1,"highlight_end":39},{"text":"                    transmute::<*const &PublicKey, usize>(pks.as_ptr())","highlight_start":1,"highlight_end":72},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let raw_msgs =","highlight_start":1,"highlight_end":31},{"text":"                    unsafe { transmute::<*const &[u8], usize>(msgs.as_ptr()) };","highlight_start":1,"highlight_end":80},{"text":"                let dst =","highlight_start":1,"highlight_end":26},{"text":"                    unsafe { slice::from_raw_parts(dst.as_ptr(), dst.len()) };","highlight_start":1,"highlight_end":79},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // let n_workers = std::cmp::min(pool.max_count(), n_elems);","highlight_start":1,"highlight_end":77},{"text":"                // for _ in 0..n_workers {","highlight_start":1,"highlight_end":43},{"text":"                    let tx = tx.clone();","highlight_start":1,"highlight_end":41},{"text":"                    let counter = counter.clone();","highlight_start":1,"highlight_end":51},{"text":"                    let valid = valid.clone();","highlight_start":1,"highlight_end":47},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // pool.execute(move || {","highlight_start":1,"highlight_end":46},{"text":"                        let mut pairing = Pairing::new($hash_or_encode, dst);","highlight_start":1,"highlight_end":78},{"text":"                        // reconstruct input slices...","highlight_start":1,"highlight_end":55},{"text":"                        let msgs = unsafe {","highlight_start":1,"highlight_end":44},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &[u8]>(raw_msgs),","highlight_start":1,"highlight_end":76},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                        let pks = unsafe {","highlight_start":1,"highlight_end":43},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &PublicKey>(raw_pks),","highlight_start":1,"highlight_end":80},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        while valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":62},{"text":"                            let work = counter.fetch_add(1, Ordering::Relaxed);","highlight_start":1,"highlight_end":80},{"text":"                            if work >= n_elems {","highlight_start":1,"highlight_end":49},{"text":"                                break;","highlight_start":1,"highlight_end":39},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                            if pairing.aggregate(","highlight_start":1,"highlight_end":50},{"text":"                                &pks[work].point,","highlight_start":1,"highlight_end":50},{"text":"                                pks_validate,","highlight_start":1,"highlight_end":46},{"text":"                                &unsafe { ptr::null::<$sig_aff>().as_ref() },","highlight_start":1,"highlight_end":78},{"text":"                                false,","highlight_start":1,"highlight_end":39},{"text":"                                &msgs[work],","highlight_start":1,"highlight_end":45},{"text":"                                &[],","highlight_start":1,"highlight_end":37},{"text":"                            ) != BLST_ERROR::BLST_SUCCESS","highlight_start":1,"highlight_end":58},{"text":"                            {","highlight_start":1,"highlight_end":30},{"text":"                                valid.store(false, Ordering::Relaxed);","highlight_start":1,"highlight_end":71},{"text":"                                break;","highlight_start":1,"highlight_end":39},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        if valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":59},{"text":"                            pairing.commit();","highlight_start":1,"highlight_end":46},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        tx.send(pairing).expect(\"disaster\");","highlight_start":1,"highlight_end":61},{"text":"                    // });","highlight_start":1,"highlight_end":27},{"text":"                // }","highlight_start":1,"highlight_end":21},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                if sig_groupcheck && valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":69},{"text":"                    match self.validate(false) {","highlight_start":1,"highlight_end":49},{"text":"                        Err(_err) => valid.store(false, Ordering::Relaxed),","highlight_start":1,"highlight_end":76},{"text":"                        _ => (),","highlight_start":1,"highlight_end":33},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut gtsig = blst_fp12::default();","highlight_start":1,"highlight_end":54},{"text":"                if valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":51},{"text":"                    Pairing::aggregated(&mut gtsig, &self.point);","highlight_start":1,"highlight_end":66},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut acc = rx.recv().unwrap();","highlight_start":1,"highlight_end":50},{"text":"                // for _ in 1..n_workers {","highlight_start":1,"highlight_end":43},{"text":"                    // acc.merge(&rx.recv().unwrap());","highlight_start":1,"highlight_end":55},{"text":"                // }","highlight_start":1,"highlight_end":21},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                if valid.load(Ordering::Relaxed)","highlight_start":1,"highlight_end":49},{"text":"                    && acc.finalverify(Some(&gtsig))","highlight_start":1,"highlight_end":53},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    BLST_ERROR::BLST_SUCCESS","highlight_start":1,"highlight_end":45},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    BLST_ERROR::BLST_VERIFY_FAIL","highlight_start":1,"highlight_end":49},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // pks are assumed to be verified for proof of possession,","highlight_start":1,"highlight_end":71},{"text":"            // which implies that they are already group-checked","highlight_start":1,"highlight_end":65},{"text":"            pub fn fast_aggregate_verify(","highlight_start":1,"highlight_end":42},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"                msg: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pks: &[&PublicKey],","highlight_start":1,"highlight_end":36},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                let agg_pk = match AggregatePublicKey::aggregate(pks, false) {","highlight_start":1,"highlight_end":79},{"text":"                    Ok(agg_sig) => agg_sig,","highlight_start":1,"highlight_end":44},{"text":"                    Err(err) => return err,","highlight_start":1,"highlight_end":44},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let pk = agg_pk.to_public_key();","highlight_start":1,"highlight_end":49},{"text":"                self.aggregate_verify(","highlight_start":1,"highlight_end":39},{"text":"                    sig_groupcheck,","highlight_start":1,"highlight_end":36},{"text":"                    &[msg],","highlight_start":1,"highlight_end":28},{"text":"                    dst,","highlight_start":1,"highlight_end":25},{"text":"                    &[&pk],","highlight_start":1,"highlight_end":28},{"text":"                    false,","highlight_start":1,"highlight_end":27},{"text":"                )","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn fast_aggregate_verify_pre_aggregated(","highlight_start":1,"highlight_end":57},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"                msg: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pk: &PublicKey,","highlight_start":1,"highlight_end":32},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                self.aggregate_verify(sig_groupcheck, &[msg], dst, &[pk], false)","highlight_start":1,"highlight_end":81},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // https://ethresear.ch/t/fast-verification-of-multiple-bls-signatures/5407","highlight_start":1,"highlight_end":88},{"text":"            pub fn verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":57},{"text":"                msgs: &[&[u8]],","highlight_start":1,"highlight_end":32},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pks: &[&PublicKey],","highlight_start":1,"highlight_end":36},{"text":"                pks_validate: bool,","highlight_start":1,"highlight_end":36},{"text":"                sigs: &[&Signature],","highlight_start":1,"highlight_end":37},{"text":"                sigs_groupcheck: bool,","highlight_start":1,"highlight_end":39},{"text":"                rands: &[blst_scalar],","highlight_start":1,"highlight_end":39},{"text":"                rand_bits: usize,","highlight_start":1,"highlight_end":34},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                let n_elems = pks.len();","highlight_start":1,"highlight_end":41},{"text":"                if n_elems == 0","highlight_start":1,"highlight_end":32},{"text":"                    || msgs.len() != n_elems","highlight_start":1,"highlight_end":45},{"text":"                    || sigs.len() != n_elems","highlight_start":1,"highlight_end":45},{"text":"                    || rands.len() != n_elems","highlight_start":1,"highlight_end":46},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    return BLST_ERROR::BLST_VERIFY_FAIL;","highlight_start":1,"highlight_end":57},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // TODO - check msg uniqueness?","highlight_start":1,"highlight_end":48},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // let pool = da_pool();","highlight_start":1,"highlight_end":41},{"text":"                let (tx, rx) = channel();","highlight_start":1,"highlight_end":42},{"text":"                let counter = Arc::new(AtomicUsize::new(0));","highlight_start":1,"highlight_end":61},{"text":"                let valid = Arc::new(AtomicBool::new(true));","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Bypass 'lifetime limitations by brute force. It works,","highlight_start":1,"highlight_end":74},{"text":"                // because we explicitly join the threads...","highlight_start":1,"highlight_end":61},{"text":"                let raw_pks = unsafe {","highlight_start":1,"highlight_end":39},{"text":"                    transmute::<*const &PublicKey, usize>(pks.as_ptr())","highlight_start":1,"highlight_end":72},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let raw_sigs = unsafe {","highlight_start":1,"highlight_end":40},{"text":"                    transmute::<*const &Signature, usize>(sigs.as_ptr())","highlight_start":1,"highlight_end":73},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let raw_rands = unsafe {","highlight_start":1,"highlight_end":41},{"text":"                    transmute::<*const blst_scalar, usize>(rands.as_ptr())","highlight_start":1,"highlight_end":75},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let raw_msgs =","highlight_start":1,"highlight_end":31},{"text":"                    unsafe { transmute::<*const &[u8], usize>(msgs.as_ptr()) };","highlight_start":1,"highlight_end":80},{"text":"                let dst =","highlight_start":1,"highlight_end":26},{"text":"                    unsafe { slice::from_raw_parts(dst.as_ptr(), dst.len()) };","highlight_start":1,"highlight_end":79},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // let n_workers = std::cmp::min(pool.max_count(), n_elems);","highlight_start":1,"highlight_end":77},{"text":"                //for _ in 0..n_workers {","highlight_start":1,"highlight_end":42},{"text":"                    let tx = tx.clone();","highlight_start":1,"highlight_end":41},{"text":"                    let counter = counter.clone();","highlight_start":1,"highlight_end":51},{"text":"                    let valid = valid.clone();","highlight_start":1,"highlight_end":47},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // pool.execute(move || {","highlight_start":1,"highlight_end":46},{"text":"                        let mut pairing = Pairing::new($hash_or_encode, dst);","highlight_start":1,"highlight_end":78},{"text":"                        // reconstruct input slices...","highlight_start":1,"highlight_end":55},{"text":"                        let rands = unsafe {","highlight_start":1,"highlight_end":45},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const blst_scalar>(","highlight_start":1,"highlight_end":72},{"text":"                                    raw_rands,","highlight_start":1,"highlight_end":47},{"text":"                                ),","highlight_start":1,"highlight_end":35},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                        let msgs = unsafe {","highlight_start":1,"highlight_end":44},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &[u8]>(raw_msgs),","highlight_start":1,"highlight_end":76},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                        let sigs = unsafe {","highlight_start":1,"highlight_end":44},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &Signature>(raw_sigs),","highlight_start":1,"highlight_end":81},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                        let pks = unsafe {","highlight_start":1,"highlight_end":43},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &PublicKey>(raw_pks),","highlight_start":1,"highlight_end":80},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        // TODO - engage multi-point mul-n-add for larger","highlight_start":1,"highlight_end":74},{"text":"                        // amount of inputs...","highlight_start":1,"highlight_end":47},{"text":"                        while valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":62},{"text":"                            let work = counter.fetch_add(1, Ordering::Relaxed);","highlight_start":1,"highlight_end":80},{"text":"                            if work >= n_elems {","highlight_start":1,"highlight_end":49},{"text":"                                break;","highlight_start":1,"highlight_end":39},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            if pairing.mul_n_aggregate(","highlight_start":1,"highlight_end":56},{"text":"                                &pks[work].point,","highlight_start":1,"highlight_end":50},{"text":"                                pks_validate,","highlight_start":1,"highlight_end":46},{"text":"                                &sigs[work].point,","highlight_start":1,"highlight_end":51},{"text":"                                sigs_groupcheck,","highlight_start":1,"highlight_end":49},{"text":"                                &rands[work].b,","highlight_start":1,"highlight_end":48},{"text":"                                rand_bits,","highlight_start":1,"highlight_end":43},{"text":"                                msgs[work],","highlight_start":1,"highlight_end":44},{"text":"                                &[],","highlight_start":1,"highlight_end":37},{"text":"                            ) != BLST_ERROR::BLST_SUCCESS","highlight_start":1,"highlight_end":58},{"text":"                            {","highlight_start":1,"highlight_end":30},{"text":"                                valid.store(false, Ordering::Relaxed);","highlight_start":1,"highlight_end":71},{"text":"                                break;","highlight_start":1,"highlight_end":39},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        if valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":59},{"text":"                            pairing.commit();","highlight_start":1,"highlight_end":46},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        tx.send(pairing).expect(\"disaster\");","highlight_start":1,"highlight_end":61},{"text":"                    // });","highlight_start":1,"highlight_end":27},{"text":"                //}","highlight_start":1,"highlight_end":20},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut acc = rx.recv().unwrap();","highlight_start":1,"highlight_end":50},{"text":"                //for _ in 1..n_workers {","highlight_start":1,"highlight_end":42},{"text":"                    // acc.merge(&rx.recv().unwrap());","highlight_start":1,"highlight_end":55},{"text":"                //}","highlight_start":1,"highlight_end":20},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                if valid.load(Ordering::Relaxed) && acc.finalverify(None) {","highlight_start":1,"highlight_end":76},{"text":"                    BLST_ERROR::BLST_SUCCESS","highlight_start":1,"highlight_end":45},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    BLST_ERROR::BLST_VERIFY_FAIL","highlight_start":1,"highlight_end":49},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_aggregate(agg_sig: &AggregateSignature) -> Self {","highlight_start":1,"highlight_end":74},{"text":"                let mut sig_aff = <$sig_aff>::default();","highlight_start":1,"highlight_end":57},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_to_aff(&mut sig_aff, &agg_sig.point);","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Self { point: sig_aff }","highlight_start":1,"highlight_end":40},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn compress(&self) -> [u8; $sig_comp_size] {","highlight_start":1,"highlight_end":61},{"text":"                let mut sig_comp = [0; $sig_comp_size];","highlight_start":1,"highlight_end":56},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_comp(sig_comp.as_mut_ptr(), &self.point);","highlight_start":1,"highlight_end":67},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                sig_comp","highlight_start":1,"highlight_end":25},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn serialize(&self) -> [u8; $sig_ser_size] {","highlight_start":1,"highlight_end":61},{"text":"                let mut sig_out = [0; $sig_ser_size];","highlight_start":1,"highlight_end":54},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_ser(sig_out.as_mut_ptr(), &self.point);","highlight_start":1,"highlight_end":65},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                sig_out","highlight_start":1,"highlight_end":24},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn uncompress(sig_comp: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":77},{"text":"                if sig_comp.len() == $sig_comp_size && (sig_comp[0] & 0x80) != 0","highlight_start":1,"highlight_end":81},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    let mut sig = <$sig_aff>::default();","highlight_start":1,"highlight_end":57},{"text":"                    let err =","highlight_start":1,"highlight_end":30},{"text":"                        unsafe { $sig_uncomp(&mut sig, sig_comp.as_ptr()) };","highlight_start":1,"highlight_end":77},{"text":"                    if err != BLST_ERROR::BLST_SUCCESS {","highlight_start":1,"highlight_end":57},{"text":"                        return Err(err);","highlight_start":1,"highlight_end":41},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(Self { point: sig })","highlight_start":1,"highlight_end":44},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Err(BLST_ERROR::BLST_BAD_ENCODING)","highlight_start":1,"highlight_end":55},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn deserialize(sig_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":76},{"text":"                if (sig_in.len() == $sig_ser_size && (sig_in[0] & 0x80) == 0)","highlight_start":1,"highlight_end":78},{"text":"                    || (sig_in.len() == $sig_comp_size","highlight_start":1,"highlight_end":55},{"text":"                        && (sig_in[0] & 0x80) != 0)","highlight_start":1,"highlight_end":52},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    let mut sig = <$sig_aff>::default();","highlight_start":1,"highlight_end":57},{"text":"                    let err = unsafe { $sig_deser(&mut sig, sig_in.as_ptr()) };","highlight_start":1,"highlight_end":80},{"text":"                    if err != BLST_ERROR::BLST_SUCCESS {","highlight_start":1,"highlight_end":57},{"text":"                        return Err(err);","highlight_start":1,"highlight_end":41},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(Self { point: sig })","highlight_start":1,"highlight_end":44},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Err(BLST_ERROR::BLST_BAD_ENCODING)","highlight_start":1,"highlight_end":55},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_bytes(sig_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":75},{"text":"                Signature::deserialize(sig_in)","highlight_start":1,"highlight_end":47},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_bytes(&self) -> [u8; $sig_comp_size] {","highlight_start":1,"highlight_end":61},{"text":"                self.compress()","highlight_start":1,"highlight_end":32},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn subgroup_check(&self) -> bool {","highlight_start":1,"highlight_end":51},{"text":"                unsafe { $sig_in_group(&self.point) }","highlight_start":1,"highlight_end":54},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Trait for equality comparisons which are equivalence relations.","highlight_start":1,"highlight_end":75},{"text":"        //","highlight_start":1,"highlight_end":11},{"text":"        // This means, that in addition to a == b and a != b being strict","highlight_start":1,"highlight_end":74},{"text":"        // inverses, the equality must be reflexive, symmetric and transitive.","highlight_start":1,"highlight_end":79},{"text":"        impl Eq for Signature {}","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl PartialEq for Signature {","highlight_start":1,"highlight_end":39},{"text":"            fn eq(&self, other: &Self) -> bool {","highlight_start":1,"highlight_end":49},{"text":"                unsafe { $sig_eq(&self.point, &other.point) }","highlight_start":1,"highlight_end":62},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[derive(Debug, Clone, Copy)]","highlight_start":1,"highlight_end":38},{"text":"        pub struct AggregateSignature {","highlight_start":1,"highlight_end":40},{"text":"            point: $sig,","highlight_start":1,"highlight_end":25},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl AggregateSignature {","highlight_start":1,"highlight_end":34},{"text":"            pub fn validate(&self) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":63},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    if !$sig_aggr_in_group(&self.point) {","highlight_start":1,"highlight_end":58},{"text":"                        return Err(BLST_ERROR::BLST_POINT_NOT_IN_GROUP);","highlight_start":1,"highlight_end":73},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_signature(sig: &Signature) -> Self {","highlight_start":1,"highlight_end":61},{"text":"                let mut agg_sig = <$sig>::default();","highlight_start":1,"highlight_end":53},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_from_aff(&mut agg_sig, &sig.point);","highlight_start":1,"highlight_end":61},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Self { point: agg_sig }","highlight_start":1,"highlight_end":40},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_signature(&self) -> Signature {","highlight_start":1,"highlight_end":54},{"text":"                let mut sig = <$sig_aff>::default();","highlight_start":1,"highlight_end":53},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_to_aff(&mut sig, &self.point);","highlight_start":1,"highlight_end":56},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Signature { point: sig }","highlight_start":1,"highlight_end":41},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Aggregate","highlight_start":1,"highlight_end":25},{"text":"            pub fn aggregate(","highlight_start":1,"highlight_end":30},{"text":"                sigs: &[&Signature],","highlight_start":1,"highlight_end":37},{"text":"                sigs_groupcheck: bool,","highlight_start":1,"highlight_end":39},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                if sigs.len() == 0 {","highlight_start":1,"highlight_end":37},{"text":"                    return Err(BLST_ERROR::BLST_AGGR_TYPE_MISMATCH);","highlight_start":1,"highlight_end":69},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if sigs_groupcheck {","highlight_start":1,"highlight_end":37},{"text":"                    // We can't actually judge if input is individual or","highlight_start":1,"highlight_end":73},{"text":"                    // aggregated signature, so we can't enforce infinitiy","highlight_start":1,"highlight_end":75},{"text":"                    // check.","highlight_start":1,"highlight_end":30},{"text":"                    sigs[0].validate(false)?;","highlight_start":1,"highlight_end":46},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut agg_sig = AggregateSignature::from_signature(sigs[0]);","highlight_start":1,"highlight_end":79},{"text":"                for s in sigs.iter().skip(1) {","highlight_start":1,"highlight_end":47},{"text":"                    if sigs_groupcheck {","highlight_start":1,"highlight_end":41},{"text":"                        s.validate(false)?;","highlight_start":1,"highlight_end":44},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        $sig_add_or_dbl_aff(","highlight_start":1,"highlight_end":45},{"text":"                            &mut agg_sig.point,","highlight_start":1,"highlight_end":48},{"text":"                            &agg_sig.point,","highlight_start":1,"highlight_end":44},{"text":"                            &s.point,","highlight_start":1,"highlight_end":38},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(agg_sig)","highlight_start":1,"highlight_end":28},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn aggregate_serialized(","highlight_start":1,"highlight_end":41},{"text":"                sigs: &[&[u8]],","highlight_start":1,"highlight_end":32},{"text":"                sigs_groupcheck: bool,","highlight_start":1,"highlight_end":39},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                // TODO - threading","highlight_start":1,"highlight_end":36},{"text":"                if sigs.len() == 0 {","highlight_start":1,"highlight_end":37},{"text":"                    return Err(BLST_ERROR::BLST_AGGR_TYPE_MISMATCH);","highlight_start":1,"highlight_end":69},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut sig = if sigs_groupcheck {","highlight_start":1,"highlight_end":51},{"text":"                    Signature::sig_validate(sigs[0], false)?","highlight_start":1,"highlight_end":61},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Signature::from_bytes(sigs[0])?","highlight_start":1,"highlight_end":52},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut agg_sig = AggregateSignature::from_signature(&sig);","highlight_start":1,"highlight_end":76},{"text":"                for s in sigs.iter().skip(1) {","highlight_start":1,"highlight_end":47},{"text":"                    sig = if sigs_groupcheck {","highlight_start":1,"highlight_end":47},{"text":"                        Signature::sig_validate(s, false)?","highlight_start":1,"highlight_end":59},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        Signature::from_bytes(s)?","highlight_start":1,"highlight_end":50},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        $sig_add_or_dbl_aff(","highlight_start":1,"highlight_end":45},{"text":"                            &mut agg_sig.point,","highlight_start":1,"highlight_end":48},{"text":"                            &agg_sig.point,","highlight_start":1,"highlight_end":44},{"text":"                            &sig.point,","highlight_start":1,"highlight_end":40},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(agg_sig)","highlight_start":1,"highlight_end":28},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn add_aggregate(&mut self, agg_sig: &AggregateSignature) {","highlight_start":1,"highlight_end":76},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_add_or_dbl(","highlight_start":1,"highlight_end":37},{"text":"                        &mut self.point,","highlight_start":1,"highlight_end":41},{"text":"                        &self.point,","highlight_start":1,"highlight_end":37},{"text":"                        &agg_sig.point,","highlight_start":1,"highlight_end":40},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn add_signature(","highlight_start":1,"highlight_end":34},{"text":"                &mut self,","highlight_start":1,"highlight_end":27},{"text":"                sig: &Signature,","highlight_start":1,"highlight_end":33},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"            ) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":42},{"text":"                if sig_groupcheck {","highlight_start":1,"highlight_end":36},{"text":"                    sig.validate(false)?;","highlight_start":1,"highlight_end":42},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_add_or_dbl_aff(","highlight_start":1,"highlight_end":41},{"text":"                        &mut self.point,","highlight_start":1,"highlight_end":41},{"text":"                        &self.point,","highlight_start":1,"highlight_end":37},{"text":"                        &sig.point,","highlight_start":1,"highlight_end":36},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn subgroup_check(&self) -> bool {","highlight_start":1,"highlight_end":51},{"text":"                unsafe { $sig_aggr_in_group(&self.point) }","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[cfg(test)]","highlight_start":1,"highlight_end":21},{"text":"        mod tests {","highlight_start":1,"highlight_end":20},{"text":"            use super::*;","highlight_start":1,"highlight_end":26},{"text":"            use rand::{RngCore, SeedableRng};","highlight_start":1,"highlight_end":46},{"text":"            use rand_chacha::ChaCha20Rng;","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Testing only - do not use for production","highlight_start":1,"highlight_end":56},{"text":"            pub fn gen_random_key(","highlight_start":1,"highlight_end":35},{"text":"                rng: &mut rand_chacha::ChaCha20Rng,","highlight_start":1,"highlight_end":52},{"text":"            ) -> SecretKey {","highlight_start":1,"highlight_end":29},{"text":"                let mut ikm = [0u8; 32];","highlight_start":1,"highlight_end":41},{"text":"                rng.fill_bytes(&mut ikm);","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut sk = <blst_scalar>::default();","highlight_start":1,"highlight_end":55},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    blst_keygen(&mut sk, ikm.as_ptr(), 32, ptr::null(), 0);","highlight_start":1,"highlight_end":76},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                SecretKey { value: sk }","highlight_start":1,"highlight_end":40},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[test]","highlight_start":1,"highlight_end":20},{"text":"            fn test_sign() {","highlight_start":1,"highlight_end":29},{"text":"                let ikm: [u8; 32] = [","highlight_start":1,"highlight_end":38},{"text":"                    0x93, 0xad, 0x7e, 0x65, 0xde, 0xad, 0x05, 0x2a, 0x08, 0x3a,","highlight_start":1,"highlight_end":80},{"text":"                    0x91, 0x0c, 0x8b, 0x72, 0x85, 0x91, 0x46, 0x4c, 0xca, 0x56,","highlight_start":1,"highlight_end":80},{"text":"                    0x60, 0x5b, 0xb0, 0x56, 0xed, 0xfe, 0x2b, 0x60, 0xa6, 0x3c,","highlight_start":1,"highlight_end":80},{"text":"                    0x48, 0x99,","highlight_start":1,"highlight_end":32},{"text":"                ];","highlight_start":1,"highlight_end":19},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sk = SecretKey::key_gen(&ikm, &[]).unwrap();","highlight_start":1,"highlight_end":65},{"text":"                let pk = sk.sk_to_pk();","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let dst = b\"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_\";","highlight_start":1,"highlight_end":74},{"text":"                let msg = b\"hello foo\";","highlight_start":1,"highlight_end":40},{"text":"                let sig = sk.sign(msg, dst, &[]);","highlight_start":1,"highlight_end":50},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let err = sig.verify(true, msg, dst, &[], &pk, true);","highlight_start":1,"highlight_end":70},{"text":"                assert_eq!(err, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[test]","highlight_start":1,"highlight_end":20},{"text":"            fn test_aggregate() {","highlight_start":1,"highlight_end":34},{"text":"                let num_msgs = 10;","highlight_start":1,"highlight_end":35},{"text":"                let dst = b\"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_\";","highlight_start":1,"highlight_end":74},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let seed = [0u8; 32];","highlight_start":1,"highlight_end":38},{"text":"                let mut rng = ChaCha20Rng::from_seed(seed);","highlight_start":1,"highlight_end":60},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sks: Vec<_> =","highlight_start":1,"highlight_end":34},{"text":"                    (0..num_msgs).map(|_| gen_random_key(&mut rng)).collect();","highlight_start":1,"highlight_end":79},{"text":"                let pks =","highlight_start":1,"highlight_end":26},{"text":"                    sks.iter().map(|sk| sk.sk_to_pk()).collect::<Vec<_>>();","highlight_start":1,"highlight_end":76},{"text":"                let pks_refs: Vec<&PublicKey> =","highlight_start":1,"highlight_end":48},{"text":"                    pks.iter().map(|pk| pk).collect();","highlight_start":1,"highlight_end":55},{"text":"                let pks_rev: Vec<&PublicKey> =","highlight_start":1,"highlight_end":47},{"text":"                    pks.iter().rev().map(|pk| pk).collect();","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_comp = pks[0].compress();","highlight_start":1,"highlight_end":49},{"text":"                let pk_uncomp = PublicKey::uncompress(&pk_comp);","highlight_start":1,"highlight_end":65},{"text":"                assert_eq!(pk_uncomp.is_ok(), true);","highlight_start":1,"highlight_end":53},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut msgs: Vec<Vec<u8>> = vec![vec![]; num_msgs];","highlight_start":1,"highlight_end":69},{"text":"                for i in 0..num_msgs {","highlight_start":1,"highlight_end":39},{"text":"                    let msg_len = (rng.next_u64() & 0x3F) + 1;","highlight_start":1,"highlight_end":63},{"text":"                    msgs[i] = vec![0u8; msg_len as usize];","highlight_start":1,"highlight_end":59},{"text":"                    rng.fill_bytes(&mut msgs[i]);","highlight_start":1,"highlight_end":50},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let msgs_refs: Vec<&[u8]> =","highlight_start":1,"highlight_end":44},{"text":"                    msgs.iter().map(|m| m.as_slice()).collect();","highlight_start":1,"highlight_end":65},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sigs = sks","highlight_start":1,"highlight_end":31},{"text":"                    .iter()","highlight_start":1,"highlight_end":28},{"text":"                    .zip(msgs.iter())","highlight_start":1,"highlight_end":38},{"text":"                    .map(|(sk, m)| (sk.sign(m, dst, &[])))","highlight_start":1,"highlight_end":59},{"text":"                    .collect::<Vec<Signature>>();","highlight_start":1,"highlight_end":50},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut errs = sigs","highlight_start":1,"highlight_end":36},{"text":"                    .iter()","highlight_start":1,"highlight_end":28},{"text":"                    .zip(msgs.iter())","highlight_start":1,"highlight_end":38},{"text":"                    .zip(pks.iter())","highlight_start":1,"highlight_end":37},{"text":"                    .map(|((s, m), pk)| (s.verify(true, m, dst, &[], pk, true)))","highlight_start":1,"highlight_end":81},{"text":"                    .collect::<Vec<BLST_ERROR>>();","highlight_start":1,"highlight_end":51},{"text":"                assert_eq!(errs, vec![BLST_ERROR::BLST_SUCCESS; num_msgs]);","highlight_start":1,"highlight_end":76},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Swap message/public key pairs to create bad signature","highlight_start":1,"highlight_end":73},{"text":"                errs = sigs","highlight_start":1,"highlight_end":28},{"text":"                    .iter()","highlight_start":1,"highlight_end":28},{"text":"                    .zip(msgs.iter())","highlight_start":1,"highlight_end":38},{"text":"                    .zip(pks.iter().rev())","highlight_start":1,"highlight_end":43},{"text":"                    .map(|((s, m), pk)| (s.verify(true, m, dst, &[], pk, true)))","highlight_start":1,"highlight_end":81},{"text":"                    .collect::<Vec<BLST_ERROR>>();","highlight_start":1,"highlight_end":51},{"text":"                assert_ne!(errs, vec![BLST_ERROR::BLST_SUCCESS; num_msgs]);","highlight_start":1,"highlight_end":76},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sig_refs =","highlight_start":1,"highlight_end":31},{"text":"                    sigs.iter().map(|s| s).collect::<Vec<&Signature>>();","highlight_start":1,"highlight_end":73},{"text":"                let agg = match AggregateSignature::aggregate(&sig_refs, true) {","highlight_start":1,"highlight_end":81},{"text":"                    Ok(agg) => agg,","highlight_start":1,"highlight_end":36},{"text":"                    Err(err) => panic!(\"aggregate failure: {:?}\", err),","highlight_start":1,"highlight_end":72},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let agg_sig = agg.to_signature();","highlight_start":1,"highlight_end":50},{"text":"                let mut result = agg_sig","highlight_start":1,"highlight_end":41},{"text":"                    .aggregate_verify(false, &msgs_refs, dst, &pks_refs, false);","highlight_start":1,"highlight_end":81},{"text":"                assert_eq!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Swap message/public key pairs to create bad signature","highlight_start":1,"highlight_end":73},{"text":"                result = agg_sig","highlight_start":1,"highlight_end":33},{"text":"                    .aggregate_verify(false, &msgs_refs, dst, &pks_rev, false);","highlight_start":1,"highlight_end":80},{"text":"                assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[test]","highlight_start":1,"highlight_end":20},{"text":"            fn test_multiple_agg_sigs() {","highlight_start":1,"highlight_end":42},{"text":"                let dst = b\"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_\";","highlight_start":1,"highlight_end":74},{"text":"                let num_pks_per_sig = 10;","highlight_start":1,"highlight_end":42},{"text":"                let num_sigs = 10;","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let seed = [0u8; 32];","highlight_start":1,"highlight_end":38},{"text":"                let mut rng = ChaCha20Rng::from_seed(seed);","highlight_start":1,"highlight_end":60},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut msgs: Vec<Vec<u8>> = vec![vec![]; num_sigs];","highlight_start":1,"highlight_end":69},{"text":"                let mut sigs: Vec<Signature> = Vec::with_capacity(num_sigs);","highlight_start":1,"highlight_end":77},{"text":"                let mut pks: Vec<PublicKey> = Vec::with_capacity(num_sigs);","highlight_start":1,"highlight_end":76},{"text":"                let mut rands: Vec<blst_scalar> = Vec::with_capacity(num_sigs);","highlight_start":1,"highlight_end":80},{"text":"                for i in 0..num_sigs {","highlight_start":1,"highlight_end":39},{"text":"                    // Create public keys","highlight_start":1,"highlight_end":42},{"text":"                    let sks_i: Vec<_> = (0..num_pks_per_sig)","highlight_start":1,"highlight_end":61},{"text":"                        .map(|_| gen_random_key(&mut rng))","highlight_start":1,"highlight_end":59},{"text":"                        .collect();","highlight_start":1,"highlight_end":36},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let pks_i = sks_i","highlight_start":1,"highlight_end":38},{"text":"                        .iter()","highlight_start":1,"highlight_end":32},{"text":"                        .map(|sk| sk.sk_to_pk())","highlight_start":1,"highlight_end":49},{"text":"                        .collect::<Vec<_>>();","highlight_start":1,"highlight_end":46},{"text":"                    let pks_refs_i: Vec<&PublicKey> =","highlight_start":1,"highlight_end":54},{"text":"                        pks_i.iter().map(|pk| pk).collect();","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Create random message for pks to all sign","highlight_start":1,"highlight_end":65},{"text":"                    let msg_len = (rng.next_u64() & 0x3F) + 1;","highlight_start":1,"highlight_end":63},{"text":"                    msgs[i] = vec![0u8; msg_len as usize];","highlight_start":1,"highlight_end":59},{"text":"                    rng.fill_bytes(&mut msgs[i]);","highlight_start":1,"highlight_end":50},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Generate signature for each key pair","highlight_start":1,"highlight_end":60},{"text":"                    let sigs_i = sks_i","highlight_start":1,"highlight_end":39},{"text":"                        .iter()","highlight_start":1,"highlight_end":32},{"text":"                        .map(|sk| sk.sign(&msgs[i], dst, &[]))","highlight_start":1,"highlight_end":63},{"text":"                        .collect::<Vec<Signature>>();","highlight_start":1,"highlight_end":54},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Test each current single signature","highlight_start":1,"highlight_end":58},{"text":"                    let errs = sigs_i","highlight_start":1,"highlight_end":38},{"text":"                        .iter()","highlight_start":1,"highlight_end":32},{"text":"                        .zip(pks_i.iter())","highlight_start":1,"highlight_end":43},{"text":"                        .map(|(s, pk)| {","highlight_start":1,"highlight_end":41},{"text":"                            (s.verify(true, &msgs[i], dst, &[], pk, true))","highlight_start":1,"highlight_end":75},{"text":"                        })","highlight_start":1,"highlight_end":27},{"text":"                        .collect::<Vec<BLST_ERROR>>();","highlight_start":1,"highlight_end":55},{"text":"                    assert_eq!(","highlight_start":1,"highlight_end":32},{"text":"                        errs,","highlight_start":1,"highlight_end":30},{"text":"                        vec![BLST_ERROR::BLST_SUCCESS; num_pks_per_sig]","highlight_start":1,"highlight_end":72},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let sig_refs_i =","highlight_start":1,"highlight_end":37},{"text":"                        sigs_i.iter().map(|s| s).collect::<Vec<&Signature>>();","highlight_start":1,"highlight_end":79},{"text":"                    let agg_i =","highlight_start":1,"highlight_end":32},{"text":"                        match AggregateSignature::aggregate(&sig_refs_i, false)","highlight_start":1,"highlight_end":80},{"text":"                        {","highlight_start":1,"highlight_end":26},{"text":"                            Ok(agg_i) => agg_i,","highlight_start":1,"highlight_end":48},{"text":"                            Err(err) => panic!(\"aggregate failure: {:?}\", err),","highlight_start":1,"highlight_end":80},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Test current aggregate signature","highlight_start":1,"highlight_end":56},{"text":"                    sigs.push(agg_i.to_signature());","highlight_start":1,"highlight_end":53},{"text":"                    let mut result = sigs[i].fast_aggregate_verify(","highlight_start":1,"highlight_end":68},{"text":"                        false,","highlight_start":1,"highlight_end":31},{"text":"                        &msgs[i],","highlight_start":1,"highlight_end":34},{"text":"                        dst,","highlight_start":1,"highlight_end":29},{"text":"                        &pks_refs_i,","highlight_start":1,"highlight_end":37},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                    assert_eq!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":66},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // negative test","highlight_start":1,"highlight_end":37},{"text":"                    if i != 0 {","highlight_start":1,"highlight_end":32},{"text":"                        result = sigs[i - 1].fast_aggregate_verify(","highlight_start":1,"highlight_end":68},{"text":"                            false,","highlight_start":1,"highlight_end":35},{"text":"                            &msgs[i],","highlight_start":1,"highlight_end":38},{"text":"                            dst,","highlight_start":1,"highlight_end":33},{"text":"                            &pks_refs_i,","highlight_start":1,"highlight_end":41},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                        assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":70},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // aggregate public keys and push into vec","highlight_start":1,"highlight_end":63},{"text":"                    let agg_pk_i =","highlight_start":1,"highlight_end":35},{"text":"                        match AggregatePublicKey::aggregate(&pks_refs_i, false)","highlight_start":1,"highlight_end":80},{"text":"                        {","highlight_start":1,"highlight_end":26},{"text":"                            Ok(agg_pk_i) => agg_pk_i,","highlight_start":1,"highlight_end":54},{"text":"                            Err(err) => panic!(\"aggregate failure: {:?}\", err),","highlight_start":1,"highlight_end":80},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                    pks.push(agg_pk_i.to_public_key());","highlight_start":1,"highlight_end":56},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Test current aggregate signature with aggregated pks","highlight_start":1,"highlight_end":76},{"text":"                    result = sigs[i].fast_aggregate_verify_pre_aggregated(","highlight_start":1,"highlight_end":75},{"text":"                        false, &msgs[i], dst, &pks[i],","highlight_start":1,"highlight_end":55},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                    assert_eq!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":66},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // negative test","highlight_start":1,"highlight_end":37},{"text":"                    if i != 0 {","highlight_start":1,"highlight_end":32},{"text":"                        result = sigs[i - 1]","highlight_start":1,"highlight_end":45},{"text":"                            .fast_aggregate_verify_pre_aggregated(","highlight_start":1,"highlight_end":67},{"text":"                                false, &msgs[i], dst, &pks[i],","highlight_start":1,"highlight_end":63},{"text":"                            );","highlight_start":1,"highlight_end":31},{"text":"                        assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":70},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // create random values","highlight_start":1,"highlight_end":44},{"text":"                    let mut vals = [0u64; 4];","highlight_start":1,"highlight_end":46},{"text":"                    vals[0] = rng.next_u64();","highlight_start":1,"highlight_end":46},{"text":"                    while vals[0] == 0 {","highlight_start":1,"highlight_end":41},{"text":"                        // Reject zero as it is used for multiplication.","highlight_start":1,"highlight_end":73},{"text":"                        vals[0] = rng.next_u64();","highlight_start":1,"highlight_end":50},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    let mut rand_i =","highlight_start":1,"highlight_end":37},{"text":"                        std::mem::MaybeUninit::<blst_scalar>::uninit();","highlight_start":1,"highlight_end":72},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        blst_scalar_from_uint64(","highlight_start":1,"highlight_end":49},{"text":"                            rand_i.as_mut_ptr(),","highlight_start":1,"highlight_end":49},{"text":"                            vals.as_ptr(),","highlight_start":1,"highlight_end":43},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                        rands.push(rand_i.assume_init());","highlight_start":1,"highlight_end":58},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let msgs_refs: Vec<&[u8]> =","highlight_start":1,"highlight_end":44},{"text":"                    msgs.iter().map(|m| m.as_slice()).collect();","highlight_start":1,"highlight_end":65},{"text":"                let sig_refs =","highlight_start":1,"highlight_end":31},{"text":"                    sigs.iter().map(|s| s).collect::<Vec<&Signature>>();","highlight_start":1,"highlight_end":73},{"text":"                let pks_refs: Vec<&PublicKey> =","highlight_start":1,"highlight_end":48},{"text":"                    pks.iter().map(|pk| pk).collect();","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let msgs_rev: Vec<&[u8]> =","highlight_start":1,"highlight_end":43},{"text":"                    msgs.iter().rev().map(|m| m.as_slice()).collect();","highlight_start":1,"highlight_end":71},{"text":"                let sig_rev =","highlight_start":1,"highlight_end":30},{"text":"                    sigs.iter().rev().map(|s| s).collect::<Vec<&Signature>>();","highlight_start":1,"highlight_end":79},{"text":"                let pks_rev: Vec<&PublicKey> =","highlight_start":1,"highlight_end":47},{"text":"                    pks.iter().rev().map(|pk| pk).collect();","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut result =","highlight_start":1,"highlight_end":33},{"text":"                    Signature::verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":69},{"text":"                        &msgs_refs, dst, &pks_refs, false, &sig_refs, true,","highlight_start":1,"highlight_end":76},{"text":"                        &rands, 64,","highlight_start":1,"highlight_end":36},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                assert_eq!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // negative tests (use reverse msgs, pks, and sigs)","highlight_start":1,"highlight_end":68},{"text":"                result = Signature::verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":74},{"text":"                    &msgs_rev, dst, &pks_refs, false, &sig_refs, true, &rands,","highlight_start":1,"highlight_end":79},{"text":"                    64,","highlight_start":1,"highlight_end":24},{"text":"                );","highlight_start":1,"highlight_end":19},{"text":"                assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                result = Signature::verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":74},{"text":"                    &msgs_refs, dst, &pks_rev, false, &sig_refs, true, &rands,","highlight_start":1,"highlight_end":79},{"text":"                    64,","highlight_start":1,"highlight_end":24},{"text":"                );","highlight_start":1,"highlight_end":19},{"text":"                assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                result = Signature::verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":74},{"text":"                    &msgs_refs, dst, &pks_refs, false, &sig_rev, true, &rands,","highlight_start":1,"highlight_end":79},{"text":"                    64,","highlight_start":1,"highlight_end":24},{"text":"                );","highlight_start":1,"highlight_end":19},{"text":"                assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[test]","highlight_start":1,"highlight_end":20},{"text":"            fn test_serialization() {","highlight_start":1,"highlight_end":38},{"text":"                let seed = [0u8; 32];","highlight_start":1,"highlight_end":38},{"text":"                let mut rng = ChaCha20Rng::from_seed(seed);","highlight_start":1,"highlight_end":60},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sk = gen_random_key(&mut rng);","highlight_start":1,"highlight_end":51},{"text":"                let sk2 = gen_random_key(&mut rng);","highlight_start":1,"highlight_end":52},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk = sk.sk_to_pk();","highlight_start":1,"highlight_end":40},{"text":"                let pk_comp = pk.compress();","highlight_start":1,"highlight_end":45},{"text":"                let pk_ser = pk.serialize();","highlight_start":1,"highlight_end":45},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_uncomp = PublicKey::uncompress(&pk_comp);","highlight_start":1,"highlight_end":65},{"text":"                assert_eq!(pk_uncomp.is_ok(), true);","highlight_start":1,"highlight_end":53},{"text":"                assert_eq!(pk_uncomp.unwrap(), pk);","highlight_start":1,"highlight_end":52},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_deser = PublicKey::deserialize(&pk_ser);","highlight_start":1,"highlight_end":64},{"text":"                assert_eq!(pk_deser.is_ok(), true);","highlight_start":1,"highlight_end":52},{"text":"                assert_eq!(pk_deser.unwrap(), pk);","highlight_start":1,"highlight_end":51},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk2 = sk2.sk_to_pk();","highlight_start":1,"highlight_end":42},{"text":"                let pk_comp2 = pk2.compress();","highlight_start":1,"highlight_end":47},{"text":"                let pk_ser2 = pk2.serialize();","highlight_start":1,"highlight_end":47},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_uncomp2 = PublicKey::uncompress(&pk_comp2);","highlight_start":1,"highlight_end":67},{"text":"                assert_eq!(pk_uncomp2.is_ok(), true);","highlight_start":1,"highlight_end":54},{"text":"                assert_eq!(pk_uncomp2.unwrap(), pk2);","highlight_start":1,"highlight_end":54},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_deser2 = PublicKey::deserialize(&pk_ser2);","highlight_start":1,"highlight_end":66},{"text":"                assert_eq!(pk_deser2.is_ok(), true);","highlight_start":1,"highlight_end":53},{"text":"                assert_eq!(pk_deser2.unwrap(), pk2);","highlight_start":1,"highlight_end":53},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                assert_ne!(pk, pk2);","highlight_start":1,"highlight_end":37},{"text":"                assert_ne!(pk_uncomp.unwrap(), pk2);","highlight_start":1,"highlight_end":53},{"text":"                assert_ne!(pk_deser.unwrap(), pk2);","highlight_start":1,"highlight_end":52},{"text":"                assert_ne!(pk_uncomp2.unwrap(), pk);","highlight_start":1,"highlight_end":53},{"text":"                assert_ne!(pk_deser2.unwrap(), pk);","highlight_start":1,"highlight_end":52},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"remove this `mut`","code":null,"level":"help","spans":[{"file_name":"/home/azureuser/blst/bindings/rust/src/lib.rs","byte_start":25106,"byte_end":25110,"line_start":779,"line_end":779,"column_start":21,"column_end":25,"is_primary":true,"text":[{"text":"                let mut acc = rx.recv().unwrap();","highlight_start":21,"highlight_end":25}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"/home/azureuser/blst/bindings/rust/src/lib.rs","byte_start":53005,"byte_end":54021,"line_start":1516,"line_end":1554,"column_start":5,"column_end":7,"is_primary":false,"text":[{"text":"    sig_variant_impl!(","highlight_start":5,"highlight_end":23},{"text":"        \"MinSig\",","highlight_start":1,"highlight_end":18},{"text":"        blst_p2,","highlight_start":1,"highlight_end":17},{"text":"        blst_p2_affine,","highlight_start":1,"highlight_end":24},{"text":"        blst_p1,","highlight_start":1,"highlight_end":17},{"text":"        blst_p1_affine,","highlight_start":1,"highlight_end":24},{"text":"        blst_sk_to_pk2_in_g2,","highlight_start":1,"highlight_end":30},{"text":"        true,","highlight_start":1,"highlight_end":14},{"text":"        blst_hash_to_g1,","highlight_start":1,"highlight_end":25},{"text":"        blst_sign_pk2_in_g2,","highlight_start":1,"highlight_end":29},{"text":"        blst_p2_affine_is_equal,","highlight_start":1,"highlight_end":33},{"text":"        blst_p1_affine_is_equal,","highlight_start":1,"highlight_end":33},{"text":"        blst_core_verify_pk_in_g2,","highlight_start":1,"highlight_end":35},{"text":"        blst_p2_affine_in_g2,","highlight_start":1,"highlight_end":30},{"text":"        blst_p2_to_affine,","highlight_start":1,"highlight_end":27},{"text":"        blst_p2_from_affine,","highlight_start":1,"highlight_end":29},{"text":"        blst_p2_affine_serialize,","highlight_start":1,"highlight_end":34},{"text":"        blst_p2_affine_compress,","highlight_start":1,"highlight_end":33},{"text":"        blst_p2_deserialize,","highlight_start":1,"highlight_end":29},{"text":"        blst_p2_uncompress,","highlight_start":1,"highlight_end":28},{"text":"        96,","highlight_start":1,"highlight_end":12},{"text":"        192,","highlight_start":1,"highlight_end":13},{"text":"        blst_p1_affine_in_g1,","highlight_start":1,"highlight_end":30},{"text":"        blst_p1_to_affine,","highlight_start":1,"highlight_end":27},{"text":"        blst_p1_from_affine,","highlight_start":1,"highlight_end":29},{"text":"        blst_p1_affine_serialize,","highlight_start":1,"highlight_end":34},{"text":"        blst_p1_affine_compress,","highlight_start":1,"highlight_end":33},{"text":"        blst_p1_deserialize,","highlight_start":1,"highlight_end":29},{"text":"        blst_p1_uncompress,","highlight_start":1,"highlight_end":28},{"text":"        48,","highlight_start":1,"highlight_end":12},{"text":"        96,","highlight_start":1,"highlight_end":12},{"text":"        blst_p2_add_or_double,","highlight_start":1,"highlight_end":31},{"text":"        blst_p2_add_or_double_affine,","highlight_start":1,"highlight_end":38},{"text":"        blst_p1_add_or_double,","highlight_start":1,"highlight_end":31},{"text":"        blst_p1_add_or_double_affine,","highlight_start":1,"highlight_end":38},{"text":"        blst_p2_affine_is_inf,","highlight_start":1,"highlight_end":31},{"text":"        blst_p1_affine_is_inf,","highlight_start":1,"highlight_end":31},{"text":"        blst_p1_in_g1,","highlight_start":1,"highlight_end":23},{"text":"    );","highlight_start":1,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"sig_variant_impl!","def_site_span":{"file_name":"/home/azureuser/blst/bindings/rust/src/lib.rs","byte_start":7790,"byte_end":51903,"line_start":283,"line_end":1467,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! sig_variant_impl {","highlight_start":1,"highlight_end":32},{"text":"    (","highlight_start":1,"highlight_end":6},{"text":"        $name:expr,","highlight_start":1,"highlight_end":20},{"text":"        $pk:ty,","highlight_start":1,"highlight_end":16},{"text":"        $pk_aff:ty,","highlight_start":1,"highlight_end":20},{"text":"        $sig:ty,","highlight_start":1,"highlight_end":17},{"text":"        $sig_aff:ty,","highlight_start":1,"highlight_end":21},{"text":"        $sk_to_pk:ident,","highlight_start":1,"highlight_end":25},{"text":"        $hash_or_encode:expr,","highlight_start":1,"highlight_end":30},{"text":"        $hash_or_encode_to:ident,","highlight_start":1,"highlight_end":34},{"text":"        $sign:ident,","highlight_start":1,"highlight_end":21},{"text":"        $pk_eq:ident,","highlight_start":1,"highlight_end":22},{"text":"        $sig_eq:ident,","highlight_start":1,"highlight_end":23},{"text":"        $verify:ident,","highlight_start":1,"highlight_end":23},{"text":"        $pk_in_group:ident,","highlight_start":1,"highlight_end":28},{"text":"        $pk_to_aff:ident,","highlight_start":1,"highlight_end":26},{"text":"        $pk_from_aff:ident,","highlight_start":1,"highlight_end":28},{"text":"        $pk_ser:ident,","highlight_start":1,"highlight_end":23},{"text":"        $pk_comp:ident,","highlight_start":1,"highlight_end":24},{"text":"        $pk_deser:ident,","highlight_start":1,"highlight_end":25},{"text":"        $pk_uncomp:ident,","highlight_start":1,"highlight_end":26},{"text":"        $pk_comp_size:expr,","highlight_start":1,"highlight_end":28},{"text":"        $pk_ser_size:expr,","highlight_start":1,"highlight_end":27},{"text":"        $sig_in_group:ident,","highlight_start":1,"highlight_end":29},{"text":"        $sig_to_aff:ident,","highlight_start":1,"highlight_end":27},{"text":"        $sig_from_aff:ident,","highlight_start":1,"highlight_end":29},{"text":"        $sig_ser:ident,","highlight_start":1,"highlight_end":24},{"text":"        $sig_comp:ident,","highlight_start":1,"highlight_end":25},{"text":"        $sig_deser:ident,","highlight_start":1,"highlight_end":26},{"text":"        $sig_uncomp:ident,","highlight_start":1,"highlight_end":27},{"text":"        $sig_comp_size:expr,","highlight_start":1,"highlight_end":29},{"text":"        $sig_ser_size:expr,","highlight_start":1,"highlight_end":28},{"text":"        $pk_add_or_dbl:ident,","highlight_start":1,"highlight_end":30},{"text":"        $pk_add_or_dbl_aff:ident,","highlight_start":1,"highlight_end":34},{"text":"        $sig_add_or_dbl:ident,","highlight_start":1,"highlight_end":31},{"text":"        $sig_add_or_dbl_aff:ident,","highlight_start":1,"highlight_end":35},{"text":"        $pk_is_inf:ident,","highlight_start":1,"highlight_end":26},{"text":"        $sig_is_inf:ident,","highlight_start":1,"highlight_end":27},{"text":"        $sig_aggr_in_group:ident,","highlight_start":1,"highlight_end":34},{"text":"    ) => {","highlight_start":1,"highlight_end":11},{"text":"        /// Secret Key","highlight_start":1,"highlight_end":23},{"text":"        #[derive(Default, Debug, Clone, Zeroize)]","highlight_start":1,"highlight_end":50},{"text":"        #[zeroize(drop)]","highlight_start":1,"highlight_end":25},{"text":"        pub struct SecretKey {","highlight_start":1,"highlight_end":31},{"text":"            value: blst_scalar,","highlight_start":1,"highlight_end":32},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl SecretKey {","highlight_start":1,"highlight_end":25},{"text":"            /// Deterministically generate a secret key from key material","highlight_start":1,"highlight_end":74},{"text":"            pub fn key_gen(","highlight_start":1,"highlight_end":28},{"text":"                ikm: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                key_info: &[u8],","highlight_start":1,"highlight_end":33},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                if ikm.len() < 32 {","highlight_start":1,"highlight_end":36},{"text":"                    return Err(BLST_ERROR::BLST_BAD_ENCODING);","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut sk = SecretKey::default();","highlight_start":1,"highlight_end":51},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    blst_keygen(","highlight_start":1,"highlight_end":33},{"text":"                        &mut sk.value,","highlight_start":1,"highlight_end":39},{"text":"                        ikm.as_ptr(),","highlight_start":1,"highlight_end":38},{"text":"                        ikm.len(),","highlight_start":1,"highlight_end":35},{"text":"                        key_info.as_ptr(),","highlight_start":1,"highlight_end":43},{"text":"                        key_info.len(),","highlight_start":1,"highlight_end":40},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(sk)","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // sk_to_pk","highlight_start":1,"highlight_end":24},{"text":"            pub fn sk_to_pk(&self) -> PublicKey {","highlight_start":1,"highlight_end":50},{"text":"                // TODO - would the user like the serialized/compressed pk as well?","highlight_start":1,"highlight_end":84},{"text":"                let mut pk_aff = PublicKey::default();","highlight_start":1,"highlight_end":55},{"text":"                //let mut pk_ser = [0u8; $pk_ser_size];","highlight_start":1,"highlight_end":56},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sk_to_pk(","highlight_start":1,"highlight_end":31},{"text":"                        //pk_ser.as_mut_ptr(),","highlight_start":1,"highlight_end":47},{"text":"                        ptr::null_mut(),","highlight_start":1,"highlight_end":41},{"text":"                        &mut pk_aff.point,","highlight_start":1,"highlight_end":43},{"text":"                        &self.value,","highlight_start":1,"highlight_end":37},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                pk_aff","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Sign","highlight_start":1,"highlight_end":20},{"text":"            pub fn sign(","highlight_start":1,"highlight_end":25},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                msg: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                aug: &[u8],","highlight_start":1,"highlight_end":28},{"text":"            ) -> Signature {","highlight_start":1,"highlight_end":29},{"text":"                // TODO - would the user like the serialized/compressed sig as well?","highlight_start":1,"highlight_end":85},{"text":"                let mut q = <$sig>::default();","highlight_start":1,"highlight_end":47},{"text":"                let mut sig_aff = <$sig_aff>::default();","highlight_start":1,"highlight_end":57},{"text":"                //let mut sig_ser = [0u8; $sig_ser_size];","highlight_start":1,"highlight_end":58},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $hash_or_encode_to(","highlight_start":1,"highlight_end":40},{"text":"                        &mut q,","highlight_start":1,"highlight_end":32},{"text":"                        msg.as_ptr(),","highlight_start":1,"highlight_end":38},{"text":"                        msg.len(),","highlight_start":1,"highlight_end":35},{"text":"                        dst.as_ptr(),","highlight_start":1,"highlight_end":38},{"text":"                        dst.len(),","highlight_start":1,"highlight_end":35},{"text":"                        aug.as_ptr(),","highlight_start":1,"highlight_end":38},{"text":"                        aug.len(),","highlight_start":1,"highlight_end":35},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                    $sign(ptr::null_mut(), &mut sig_aff, &q, &self.value);","highlight_start":1,"highlight_end":75},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Signature { point: sig_aff }","highlight_start":1,"highlight_end":45},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // TODO - formally speaking application is entitled to have","highlight_start":1,"highlight_end":72},{"text":"            // ultimate control over secret key storage, which means that","highlight_start":1,"highlight_end":74},{"text":"            // corresponding serialization/deserialization subroutines","highlight_start":1,"highlight_end":71},{"text":"            // should accept reference to where to store the result, as","highlight_start":1,"highlight_end":72},{"text":"            // opposite to returning one.","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // serialize","highlight_start":1,"highlight_end":25},{"text":"            pub fn serialize(&self) -> [u8; 32] {","highlight_start":1,"highlight_end":50},{"text":"                let mut sk_out = [0; 32];","highlight_start":1,"highlight_end":42},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    blst_bendian_from_scalar(sk_out.as_mut_ptr(), &self.value);","highlight_start":1,"highlight_end":80},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                sk_out","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // deserialize","highlight_start":1,"highlight_end":27},{"text":"            pub fn deserialize(sk_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":75},{"text":"                let mut sk = blst_scalar::default();","highlight_start":1,"highlight_end":53},{"text":"                if sk_in.len() != 32 {","highlight_start":1,"highlight_end":39},{"text":"                    return Err(BLST_ERROR::BLST_BAD_ENCODING);","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    blst_scalar_from_bendian(&mut sk, sk_in.as_ptr());","highlight_start":1,"highlight_end":71},{"text":"                    if !blst_sk_check(&sk) {","highlight_start":1,"highlight_end":45},{"text":"                        return Err(BLST_ERROR::BLST_BAD_ENCODING);","highlight_start":1,"highlight_end":67},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(Self { value: sk })","highlight_start":1,"highlight_end":39},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_bytes(&self) -> [u8; 32] {","highlight_start":1,"highlight_end":49},{"text":"                SecretKey::serialize(&self)","highlight_start":1,"highlight_end":44},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_bytes(sk_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":74},{"text":"                SecretKey::deserialize(sk_in)","highlight_start":1,"highlight_end":46},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[derive(Default, Debug, Clone, Copy)]","highlight_start":1,"highlight_end":47},{"text":"        pub struct PublicKey {","highlight_start":1,"highlight_end":31},{"text":"            point: $pk_aff,","highlight_start":1,"highlight_end":28},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl PublicKey {","highlight_start":1,"highlight_end":25},{"text":"            // Core operations","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // key_validate","highlight_start":1,"highlight_end":28},{"text":"            pub fn validate(&self) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":63},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    if $pk_is_inf(&self.point) {","highlight_start":1,"highlight_end":49},{"text":"                        return Err(BLST_ERROR::BLST_PK_IS_INFINITY);","highlight_start":1,"highlight_end":69},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    if !$pk_in_group(&self.point) {","highlight_start":1,"highlight_end":52},{"text":"                        return Err(BLST_ERROR::BLST_POINT_NOT_IN_GROUP);","highlight_start":1,"highlight_end":73},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn key_validate(key: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":74},{"text":"                let pk = PublicKey::from_bytes(key)?;","highlight_start":1,"highlight_end":54},{"text":"                pk.validate()?;","highlight_start":1,"highlight_end":32},{"text":"                Ok(pk)","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_aggregate(agg_pk: &AggregatePublicKey) -> Self {","highlight_start":1,"highlight_end":73},{"text":"                let mut pk_aff = <$pk_aff>::default();","highlight_start":1,"highlight_end":55},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_to_aff(&mut pk_aff, &agg_pk.point);","highlight_start":1,"highlight_end":60},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Self { point: pk_aff }","highlight_start":1,"highlight_end":39},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Serdes","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn compress(&self) -> [u8; $pk_comp_size] {","highlight_start":1,"highlight_end":60},{"text":"                let mut pk_comp = [0u8; $pk_comp_size];","highlight_start":1,"highlight_end":56},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_comp(pk_comp.as_mut_ptr(), &self.point);","highlight_start":1,"highlight_end":65},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                pk_comp","highlight_start":1,"highlight_end":24},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn serialize(&self) -> [u8; $pk_ser_size] {","highlight_start":1,"highlight_end":60},{"text":"                let mut pk_out = [0u8; $pk_ser_size];","highlight_start":1,"highlight_end":54},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_ser(pk_out.as_mut_ptr(), &self.point);","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                pk_out","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn uncompress(pk_comp: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":76},{"text":"                if pk_comp.len() == $pk_comp_size && (pk_comp[0] & 0x80) != 0 {","highlight_start":1,"highlight_end":80},{"text":"                    let mut pk = <$pk_aff>::default();","highlight_start":1,"highlight_end":55},{"text":"                    let err = unsafe { $pk_uncomp(&mut pk, pk_comp.as_ptr()) };","highlight_start":1,"highlight_end":80},{"text":"                    if err != BLST_ERROR::BLST_SUCCESS {","highlight_start":1,"highlight_end":57},{"text":"                        return Err(err);","highlight_start":1,"highlight_end":41},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(Self { point: pk })","highlight_start":1,"highlight_end":43},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Err(BLST_ERROR::BLST_BAD_ENCODING)","highlight_start":1,"highlight_end":55},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn deserialize(pk_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":75},{"text":"                if (pk_in.len() == $pk_ser_size && (pk_in[0] & 0x80) == 0)","highlight_start":1,"highlight_end":75},{"text":"                    || (pk_in.len() == $pk_comp_size && (pk_in[0] & 0x80) != 0)","highlight_start":1,"highlight_end":80},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    let mut pk = <$pk_aff>::default();","highlight_start":1,"highlight_end":55},{"text":"                    let err = unsafe { $pk_deser(&mut pk, pk_in.as_ptr()) };","highlight_start":1,"highlight_end":77},{"text":"                    if err != BLST_ERROR::BLST_SUCCESS {","highlight_start":1,"highlight_end":57},{"text":"                        return Err(err);","highlight_start":1,"highlight_end":41},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(Self { point: pk })","highlight_start":1,"highlight_end":43},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Err(BLST_ERROR::BLST_BAD_ENCODING)","highlight_start":1,"highlight_end":55},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_bytes(pk_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":74},{"text":"                PublicKey::deserialize(pk_in)","highlight_start":1,"highlight_end":46},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_bytes(&self) -> [u8; $pk_comp_size] {","highlight_start":1,"highlight_end":60},{"text":"                self.compress()","highlight_start":1,"highlight_end":32},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Trait for equality comparisons which are equivalence relations.","highlight_start":1,"highlight_end":75},{"text":"        //","highlight_start":1,"highlight_end":11},{"text":"        // This means, that in addition to a == b and a != b being strict","highlight_start":1,"highlight_end":74},{"text":"        // inverses, the equality must be reflexive, symmetric and transitive.","highlight_start":1,"highlight_end":79},{"text":"        impl Eq for PublicKey {}","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl PartialEq for PublicKey {","highlight_start":1,"highlight_end":39},{"text":"            fn eq(&self, other: &Self) -> bool {","highlight_start":1,"highlight_end":49},{"text":"                unsafe { $pk_eq(&self.point, &other.point) }","highlight_start":1,"highlight_end":61},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[derive(Debug, Clone, Copy)]","highlight_start":1,"highlight_end":38},{"text":"        pub struct AggregatePublicKey {","highlight_start":1,"highlight_end":40},{"text":"            point: $pk,","highlight_start":1,"highlight_end":24},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl AggregatePublicKey {","highlight_start":1,"highlight_end":34},{"text":"            pub fn from_public_key(pk: &PublicKey) -> Self {","highlight_start":1,"highlight_end":61},{"text":"                let mut agg_pk = <$pk>::default();","highlight_start":1,"highlight_end":51},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_from_aff(&mut agg_pk, &pk.point);","highlight_start":1,"highlight_end":58},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Self { point: agg_pk }","highlight_start":1,"highlight_end":39},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_public_key(&self) -> PublicKey {","highlight_start":1,"highlight_end":55},{"text":"                let mut pk = <$pk_aff>::default();","highlight_start":1,"highlight_end":51},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_to_aff(&mut pk, &self.point);","highlight_start":1,"highlight_end":54},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                PublicKey { point: pk }","highlight_start":1,"highlight_end":40},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Aggregate","highlight_start":1,"highlight_end":25},{"text":"            pub fn aggregate(","highlight_start":1,"highlight_end":30},{"text":"                pks: &[&PublicKey],","highlight_start":1,"highlight_end":36},{"text":"                pks_validate: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                if pks.len() == 0 {","highlight_start":1,"highlight_end":36},{"text":"                    return Err(BLST_ERROR::BLST_AGGR_TYPE_MISMATCH);","highlight_start":1,"highlight_end":69},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if pks_validate {","highlight_start":1,"highlight_end":34},{"text":"                    pks[0].validate()?;","highlight_start":1,"highlight_end":40},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut agg_pk = AggregatePublicKey::from_public_key(pks[0]);","highlight_start":1,"highlight_end":78},{"text":"                for s in pks.iter().skip(1) {","highlight_start":1,"highlight_end":46},{"text":"                    if pks_validate {","highlight_start":1,"highlight_end":38},{"text":"                        s.validate()?;","highlight_start":1,"highlight_end":39},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        $pk_add_or_dbl_aff(","highlight_start":1,"highlight_end":44},{"text":"                            &mut agg_pk.point,","highlight_start":1,"highlight_end":47},{"text":"                            &agg_pk.point,","highlight_start":1,"highlight_end":43},{"text":"                            &s.point,","highlight_start":1,"highlight_end":38},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(agg_pk)","highlight_start":1,"highlight_end":27},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn aggregate_serialized(","highlight_start":1,"highlight_end":41},{"text":"                pks: &[&[u8]],","highlight_start":1,"highlight_end":31},{"text":"                pks_validate: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                // TODO - threading","highlight_start":1,"highlight_end":36},{"text":"                if pks.len() == 0 {","highlight_start":1,"highlight_end":36},{"text":"                    return Err(BLST_ERROR::BLST_AGGR_TYPE_MISMATCH);","highlight_start":1,"highlight_end":69},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut pk = if pks_validate {","highlight_start":1,"highlight_end":47},{"text":"                    PublicKey::key_validate(pks[0])?","highlight_start":1,"highlight_end":53},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    PublicKey::from_bytes(pks[0])?","highlight_start":1,"highlight_end":51},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut agg_pk = AggregatePublicKey::from_public_key(&pk);","highlight_start":1,"highlight_end":75},{"text":"                for s in pks.iter().skip(1) {","highlight_start":1,"highlight_end":46},{"text":"                    pk = if pks_validate {","highlight_start":1,"highlight_end":43},{"text":"                        PublicKey::key_validate(s)?","highlight_start":1,"highlight_end":52},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        PublicKey::from_bytes(s)?","highlight_start":1,"highlight_end":50},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        $pk_add_or_dbl_aff(","highlight_start":1,"highlight_end":44},{"text":"                            &mut agg_pk.point,","highlight_start":1,"highlight_end":47},{"text":"                            &agg_pk.point,","highlight_start":1,"highlight_end":43},{"text":"                            &pk.point,","highlight_start":1,"highlight_end":39},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(agg_pk)","highlight_start":1,"highlight_end":27},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn add_aggregate(&mut self, agg_pk: &AggregatePublicKey) {","highlight_start":1,"highlight_end":75},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_add_or_dbl(&mut self.point, &self.point, &agg_pk.point);","highlight_start":1,"highlight_end":81},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn add_public_key(","highlight_start":1,"highlight_end":35},{"text":"                &mut self,","highlight_start":1,"highlight_end":27},{"text":"                pk: &PublicKey,","highlight_start":1,"highlight_end":32},{"text":"                pk_validate: bool,","highlight_start":1,"highlight_end":35},{"text":"            ) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":42},{"text":"                if pk_validate {","highlight_start":1,"highlight_end":33},{"text":"                    pk.validate()?;","highlight_start":1,"highlight_end":36},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_add_or_dbl_aff(&mut self.point, &self.point, &pk.point);","highlight_start":1,"highlight_end":81},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[derive(Debug, Clone, Copy)]","highlight_start":1,"highlight_end":38},{"text":"        pub struct Signature {","highlight_start":1,"highlight_end":31},{"text":"            point: $sig_aff,","highlight_start":1,"highlight_end":29},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl Signature {","highlight_start":1,"highlight_end":25},{"text":"            // sig_infcheck, check for infinity, is a way to avoid going","highlight_start":1,"highlight_end":73},{"text":"            // into resource-consuming verification. Passing 'false' is","highlight_start":1,"highlight_end":72},{"text":"            // always cryptographically safe, but application might want","highlight_start":1,"highlight_end":73},{"text":"            // to guard against obviously bogus individual[!] signatures.","highlight_start":1,"highlight_end":74},{"text":"            pub fn validate(","highlight_start":1,"highlight_end":29},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_infcheck: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":42},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    if sig_infcheck && $sig_is_inf(&self.point) {","highlight_start":1,"highlight_end":66},{"text":"                        return Err(BLST_ERROR::BLST_PK_IS_INFINITY);","highlight_start":1,"highlight_end":69},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    if !$sig_in_group(&self.point) {","highlight_start":1,"highlight_end":53},{"text":"                        return Err(BLST_ERROR::BLST_POINT_NOT_IN_GROUP);","highlight_start":1,"highlight_end":73},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn sig_validate(","highlight_start":1,"highlight_end":33},{"text":"                sig: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                sig_infcheck: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                let sig = Signature::from_bytes(sig)?;","highlight_start":1,"highlight_end":55},{"text":"                sig.validate(sig_infcheck)?;","highlight_start":1,"highlight_end":45},{"text":"                Ok(sig)","highlight_start":1,"highlight_end":24},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn verify(","highlight_start":1,"highlight_end":27},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"                msg: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                aug: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pk: &PublicKey,","highlight_start":1,"highlight_end":32},{"text":"                pk_validate: bool,","highlight_start":1,"highlight_end":35},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                let aug_msg = [aug, msg].concat();","highlight_start":1,"highlight_end":51},{"text":"                self.aggregate_verify(","highlight_start":1,"highlight_end":39},{"text":"                    sig_groupcheck,","highlight_start":1,"highlight_end":36},{"text":"                    &[aug_msg.as_slice()],","highlight_start":1,"highlight_end":43},{"text":"                    dst,","highlight_start":1,"highlight_end":25},{"text":"                    &[pk],","highlight_start":1,"highlight_end":27},{"text":"                    pk_validate,","highlight_start":1,"highlight_end":33},{"text":"                )","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn aggregate_verify(","highlight_start":1,"highlight_end":37},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"                msgs: &[&[u8]],","highlight_start":1,"highlight_end":32},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pks: &[&PublicKey],","highlight_start":1,"highlight_end":36},{"text":"                pks_validate: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                let n_elems = pks.len();","highlight_start":1,"highlight_end":41},{"text":"                if n_elems == 0 || msgs.len() != n_elems {","highlight_start":1,"highlight_end":59},{"text":"                    return BLST_ERROR::BLST_VERIFY_FAIL;","highlight_start":1,"highlight_end":57},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // TODO - check msg uniqueness?","highlight_start":1,"highlight_end":48},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // let pool = da_pool();","highlight_start":1,"highlight_end":41},{"text":"                let (tx, rx) = channel();","highlight_start":1,"highlight_end":42},{"text":"                let counter = Arc::new(AtomicUsize::new(0));","highlight_start":1,"highlight_end":61},{"text":"                let valid = Arc::new(AtomicBool::new(true));","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Bypass 'lifetime limitations by brute force. It works,","highlight_start":1,"highlight_end":74},{"text":"                // because we explicitly join the threads...","highlight_start":1,"highlight_end":61},{"text":"                let raw_pks = unsafe {","highlight_start":1,"highlight_end":39},{"text":"                    transmute::<*const &PublicKey, usize>(pks.as_ptr())","highlight_start":1,"highlight_end":72},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let raw_msgs =","highlight_start":1,"highlight_end":31},{"text":"                    unsafe { transmute::<*const &[u8], usize>(msgs.as_ptr()) };","highlight_start":1,"highlight_end":80},{"text":"                let dst =","highlight_start":1,"highlight_end":26},{"text":"                    unsafe { slice::from_raw_parts(dst.as_ptr(), dst.len()) };","highlight_start":1,"highlight_end":79},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // let n_workers = std::cmp::min(pool.max_count(), n_elems);","highlight_start":1,"highlight_end":77},{"text":"                // for _ in 0..n_workers {","highlight_start":1,"highlight_end":43},{"text":"                    let tx = tx.clone();","highlight_start":1,"highlight_end":41},{"text":"                    let counter = counter.clone();","highlight_start":1,"highlight_end":51},{"text":"                    let valid = valid.clone();","highlight_start":1,"highlight_end":47},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // pool.execute(move || {","highlight_start":1,"highlight_end":46},{"text":"                        let mut pairing = Pairing::new($hash_or_encode, dst);","highlight_start":1,"highlight_end":78},{"text":"                        // reconstruct input slices...","highlight_start":1,"highlight_end":55},{"text":"                        let msgs = unsafe {","highlight_start":1,"highlight_end":44},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &[u8]>(raw_msgs),","highlight_start":1,"highlight_end":76},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                        let pks = unsafe {","highlight_start":1,"highlight_end":43},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &PublicKey>(raw_pks),","highlight_start":1,"highlight_end":80},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        while valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":62},{"text":"                            let work = counter.fetch_add(1, Ordering::Relaxed);","highlight_start":1,"highlight_end":80},{"text":"                            if work >= n_elems {","highlight_start":1,"highlight_end":49},{"text":"                                break;","highlight_start":1,"highlight_end":39},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                            if pairing.aggregate(","highlight_start":1,"highlight_end":50},{"text":"                                &pks[work].point,","highlight_start":1,"highlight_end":50},{"text":"                                pks_validate,","highlight_start":1,"highlight_end":46},{"text":"                                &unsafe { ptr::null::<$sig_aff>().as_ref() },","highlight_start":1,"highlight_end":78},{"text":"                                false,","highlight_start":1,"highlight_end":39},{"text":"                                &msgs[work],","highlight_start":1,"highlight_end":45},{"text":"                                &[],","highlight_start":1,"highlight_end":37},{"text":"                            ) != BLST_ERROR::BLST_SUCCESS","highlight_start":1,"highlight_end":58},{"text":"                            {","highlight_start":1,"highlight_end":30},{"text":"                                valid.store(false, Ordering::Relaxed);","highlight_start":1,"highlight_end":71},{"text":"                                break;","highlight_start":1,"highlight_end":39},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        if valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":59},{"text":"                            pairing.commit();","highlight_start":1,"highlight_end":46},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        tx.send(pairing).expect(\"disaster\");","highlight_start":1,"highlight_end":61},{"text":"                    // });","highlight_start":1,"highlight_end":27},{"text":"                // }","highlight_start":1,"highlight_end":21},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                if sig_groupcheck && valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":69},{"text":"                    match self.validate(false) {","highlight_start":1,"highlight_end":49},{"text":"                        Err(_err) => valid.store(false, Ordering::Relaxed),","highlight_start":1,"highlight_end":76},{"text":"                        _ => (),","highlight_start":1,"highlight_end":33},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut gtsig = blst_fp12::default();","highlight_start":1,"highlight_end":54},{"text":"                if valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":51},{"text":"                    Pairing::aggregated(&mut gtsig, &self.point);","highlight_start":1,"highlight_end":66},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut acc = rx.recv().unwrap();","highlight_start":1,"highlight_end":50},{"text":"                // for _ in 1..n_workers {","highlight_start":1,"highlight_end":43},{"text":"                    // acc.merge(&rx.recv().unwrap());","highlight_start":1,"highlight_end":55},{"text":"                // }","highlight_start":1,"highlight_end":21},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                if valid.load(Ordering::Relaxed)","highlight_start":1,"highlight_end":49},{"text":"                    && acc.finalverify(Some(&gtsig))","highlight_start":1,"highlight_end":53},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    BLST_ERROR::BLST_SUCCESS","highlight_start":1,"highlight_end":45},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    BLST_ERROR::BLST_VERIFY_FAIL","highlight_start":1,"highlight_end":49},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // pks are assumed to be verified for proof of possession,","highlight_start":1,"highlight_end":71},{"text":"            // which implies that they are already group-checked","highlight_start":1,"highlight_end":65},{"text":"            pub fn fast_aggregate_verify(","highlight_start":1,"highlight_end":42},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"                msg: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pks: &[&PublicKey],","highlight_start":1,"highlight_end":36},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                let agg_pk = match AggregatePublicKey::aggregate(pks, false) {","highlight_start":1,"highlight_end":79},{"text":"                    Ok(agg_sig) => agg_sig,","highlight_start":1,"highlight_end":44},{"text":"                    Err(err) => return err,","highlight_start":1,"highlight_end":44},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let pk = agg_pk.to_public_key();","highlight_start":1,"highlight_end":49},{"text":"                self.aggregate_verify(","highlight_start":1,"highlight_end":39},{"text":"                    sig_groupcheck,","highlight_start":1,"highlight_end":36},{"text":"                    &[msg],","highlight_start":1,"highlight_end":28},{"text":"                    dst,","highlight_start":1,"highlight_end":25},{"text":"                    &[&pk],","highlight_start":1,"highlight_end":28},{"text":"                    false,","highlight_start":1,"highlight_end":27},{"text":"                )","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn fast_aggregate_verify_pre_aggregated(","highlight_start":1,"highlight_end":57},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"                msg: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pk: &PublicKey,","highlight_start":1,"highlight_end":32},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                self.aggregate_verify(sig_groupcheck, &[msg], dst, &[pk], false)","highlight_start":1,"highlight_end":81},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // https://ethresear.ch/t/fast-verification-of-multiple-bls-signatures/5407","highlight_start":1,"highlight_end":88},{"text":"            pub fn verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":57},{"text":"                msgs: &[&[u8]],","highlight_start":1,"highlight_end":32},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pks: &[&PublicKey],","highlight_start":1,"highlight_end":36},{"text":"                pks_validate: bool,","highlight_start":1,"highlight_end":36},{"text":"                sigs: &[&Signature],","highlight_start":1,"highlight_end":37},{"text":"                sigs_groupcheck: bool,","highlight_start":1,"highlight_end":39},{"text":"                rands: &[blst_scalar],","highlight_start":1,"highlight_end":39},{"text":"                rand_bits: usize,","highlight_start":1,"highlight_end":34},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                let n_elems = pks.len();","highlight_start":1,"highlight_end":41},{"text":"                if n_elems == 0","highlight_start":1,"highlight_end":32},{"text":"                    || msgs.len() != n_elems","highlight_start":1,"highlight_end":45},{"text":"                    || sigs.len() != n_elems","highlight_start":1,"highlight_end":45},{"text":"                    || rands.len() != n_elems","highlight_start":1,"highlight_end":46},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    return BLST_ERROR::BLST_VERIFY_FAIL;","highlight_start":1,"highlight_end":57},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // TODO - check msg uniqueness?","highlight_start":1,"highlight_end":48},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // let pool = da_pool();","highlight_start":1,"highlight_end":41},{"text":"                let (tx, rx) = channel();","highlight_start":1,"highlight_end":42},{"text":"                let counter = Arc::new(AtomicUsize::new(0));","highlight_start":1,"highlight_end":61},{"text":"                let valid = Arc::new(AtomicBool::new(true));","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Bypass 'lifetime limitations by brute force. It works,","highlight_start":1,"highlight_end":74},{"text":"                // because we explicitly join the threads...","highlight_start":1,"highlight_end":61},{"text":"                let raw_pks = unsafe {","highlight_start":1,"highlight_end":39},{"text":"                    transmute::<*const &PublicKey, usize>(pks.as_ptr())","highlight_start":1,"highlight_end":72},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let raw_sigs = unsafe {","highlight_start":1,"highlight_end":40},{"text":"                    transmute::<*const &Signature, usize>(sigs.as_ptr())","highlight_start":1,"highlight_end":73},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let raw_rands = unsafe {","highlight_start":1,"highlight_end":41},{"text":"                    transmute::<*const blst_scalar, usize>(rands.as_ptr())","highlight_start":1,"highlight_end":75},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let raw_msgs =","highlight_start":1,"highlight_end":31},{"text":"                    unsafe { transmute::<*const &[u8], usize>(msgs.as_ptr()) };","highlight_start":1,"highlight_end":80},{"text":"                let dst =","highlight_start":1,"highlight_end":26},{"text":"                    unsafe { slice::from_raw_parts(dst.as_ptr(), dst.len()) };","highlight_start":1,"highlight_end":79},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // let n_workers = std::cmp::min(pool.max_count(), n_elems);","highlight_start":1,"highlight_end":77},{"text":"                //for _ in 0..n_workers {","highlight_start":1,"highlight_end":42},{"text":"                    let tx = tx.clone();","highlight_start":1,"highlight_end":41},{"text":"                    let counter = counter.clone();","highlight_start":1,"highlight_end":51},{"text":"                    let valid = valid.clone();","highlight_start":1,"highlight_end":47},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // pool.execute(move || {","highlight_start":1,"highlight_end":46},{"text":"                        let mut pairing = Pairing::new($hash_or_encode, dst);","highlight_start":1,"highlight_end":78},{"text":"                        // reconstruct input slices...","highlight_start":1,"highlight_end":55},{"text":"                        let rands = unsafe {","highlight_start":1,"highlight_end":45},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const blst_scalar>(","highlight_start":1,"highlight_end":72},{"text":"                                    raw_rands,","highlight_start":1,"highlight_end":47},{"text":"                                ),","highlight_start":1,"highlight_end":35},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                        let msgs = unsafe {","highlight_start":1,"highlight_end":44},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &[u8]>(raw_msgs),","highlight_start":1,"highlight_end":76},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                        let sigs = unsafe {","highlight_start":1,"highlight_end":44},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &Signature>(raw_sigs),","highlight_start":1,"highlight_end":81},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                        let pks = unsafe {","highlight_start":1,"highlight_end":43},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &PublicKey>(raw_pks),","highlight_start":1,"highlight_end":80},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        // TODO - engage multi-point mul-n-add for larger","highlight_start":1,"highlight_end":74},{"text":"                        // amount of inputs...","highlight_start":1,"highlight_end":47},{"text":"                        while valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":62},{"text":"                            let work = counter.fetch_add(1, Ordering::Relaxed);","highlight_start":1,"highlight_end":80},{"text":"                            if work >= n_elems {","highlight_start":1,"highlight_end":49},{"text":"                                break;","highlight_start":1,"highlight_end":39},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            if pairing.mul_n_aggregate(","highlight_start":1,"highlight_end":56},{"text":"                                &pks[work].point,","highlight_start":1,"highlight_end":50},{"text":"                                pks_validate,","highlight_start":1,"highlight_end":46},{"text":"                                &sigs[work].point,","highlight_start":1,"highlight_end":51},{"text":"                                sigs_groupcheck,","highlight_start":1,"highlight_end":49},{"text":"                                &rands[work].b,","highlight_start":1,"highlight_end":48},{"text":"                                rand_bits,","highlight_start":1,"highlight_end":43},{"text":"                                msgs[work],","highlight_start":1,"highlight_end":44},{"text":"                                &[],","highlight_start":1,"highlight_end":37},{"text":"                            ) != BLST_ERROR::BLST_SUCCESS","highlight_start":1,"highlight_end":58},{"text":"                            {","highlight_start":1,"highlight_end":30},{"text":"                                valid.store(false, Ordering::Relaxed);","highlight_start":1,"highlight_end":71},{"text":"                                break;","highlight_start":1,"highlight_end":39},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        if valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":59},{"text":"                            pairing.commit();","highlight_start":1,"highlight_end":46},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        tx.send(pairing).expect(\"disaster\");","highlight_start":1,"highlight_end":61},{"text":"                    // });","highlight_start":1,"highlight_end":27},{"text":"                //}","highlight_start":1,"highlight_end":20},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut acc = rx.recv().unwrap();","highlight_start":1,"highlight_end":50},{"text":"                //for _ in 1..n_workers {","highlight_start":1,"highlight_end":42},{"text":"                    // acc.merge(&rx.recv().unwrap());","highlight_start":1,"highlight_end":55},{"text":"                //}","highlight_start":1,"highlight_end":20},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                if valid.load(Ordering::Relaxed) && acc.finalverify(None) {","highlight_start":1,"highlight_end":76},{"text":"                    BLST_ERROR::BLST_SUCCESS","highlight_start":1,"highlight_end":45},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    BLST_ERROR::BLST_VERIFY_FAIL","highlight_start":1,"highlight_end":49},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_aggregate(agg_sig: &AggregateSignature) -> Self {","highlight_start":1,"highlight_end":74},{"text":"                let mut sig_aff = <$sig_aff>::default();","highlight_start":1,"highlight_end":57},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_to_aff(&mut sig_aff, &agg_sig.point);","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Self { point: sig_aff }","highlight_start":1,"highlight_end":40},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn compress(&self) -> [u8; $sig_comp_size] {","highlight_start":1,"highlight_end":61},{"text":"                let mut sig_comp = [0; $sig_comp_size];","highlight_start":1,"highlight_end":56},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_comp(sig_comp.as_mut_ptr(), &self.point);","highlight_start":1,"highlight_end":67},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                sig_comp","highlight_start":1,"highlight_end":25},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn serialize(&self) -> [u8; $sig_ser_size] {","highlight_start":1,"highlight_end":61},{"text":"                let mut sig_out = [0; $sig_ser_size];","highlight_start":1,"highlight_end":54},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_ser(sig_out.as_mut_ptr(), &self.point);","highlight_start":1,"highlight_end":65},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                sig_out","highlight_start":1,"highlight_end":24},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn uncompress(sig_comp: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":77},{"text":"                if sig_comp.len() == $sig_comp_size && (sig_comp[0] & 0x80) != 0","highlight_start":1,"highlight_end":81},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    let mut sig = <$sig_aff>::default();","highlight_start":1,"highlight_end":57},{"text":"                    let err =","highlight_start":1,"highlight_end":30},{"text":"                        unsafe { $sig_uncomp(&mut sig, sig_comp.as_ptr()) };","highlight_start":1,"highlight_end":77},{"text":"                    if err != BLST_ERROR::BLST_SUCCESS {","highlight_start":1,"highlight_end":57},{"text":"                        return Err(err);","highlight_start":1,"highlight_end":41},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(Self { point: sig })","highlight_start":1,"highlight_end":44},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Err(BLST_ERROR::BLST_BAD_ENCODING)","highlight_start":1,"highlight_end":55},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn deserialize(sig_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":76},{"text":"                if (sig_in.len() == $sig_ser_size && (sig_in[0] & 0x80) == 0)","highlight_start":1,"highlight_end":78},{"text":"                    || (sig_in.len() == $sig_comp_size","highlight_start":1,"highlight_end":55},{"text":"                        && (sig_in[0] & 0x80) != 0)","highlight_start":1,"highlight_end":52},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    let mut sig = <$sig_aff>::default();","highlight_start":1,"highlight_end":57},{"text":"                    let err = unsafe { $sig_deser(&mut sig, sig_in.as_ptr()) };","highlight_start":1,"highlight_end":80},{"text":"                    if err != BLST_ERROR::BLST_SUCCESS {","highlight_start":1,"highlight_end":57},{"text":"                        return Err(err);","highlight_start":1,"highlight_end":41},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(Self { point: sig })","highlight_start":1,"highlight_end":44},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Err(BLST_ERROR::BLST_BAD_ENCODING)","highlight_start":1,"highlight_end":55},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_bytes(sig_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":75},{"text":"                Signature::deserialize(sig_in)","highlight_start":1,"highlight_end":47},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_bytes(&self) -> [u8; $sig_comp_size] {","highlight_start":1,"highlight_end":61},{"text":"                self.compress()","highlight_start":1,"highlight_end":32},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn subgroup_check(&self) -> bool {","highlight_start":1,"highlight_end":51},{"text":"                unsafe { $sig_in_group(&self.point) }","highlight_start":1,"highlight_end":54},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Trait for equality comparisons which are equivalence relations.","highlight_start":1,"highlight_end":75},{"text":"        //","highlight_start":1,"highlight_end":11},{"text":"        // This means, that in addition to a == b and a != b being strict","highlight_start":1,"highlight_end":74},{"text":"        // inverses, the equality must be reflexive, symmetric and transitive.","highlight_start":1,"highlight_end":79},{"text":"        impl Eq for Signature {}","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl PartialEq for Signature {","highlight_start":1,"highlight_end":39},{"text":"            fn eq(&self, other: &Self) -> bool {","highlight_start":1,"highlight_end":49},{"text":"                unsafe { $sig_eq(&self.point, &other.point) }","highlight_start":1,"highlight_end":62},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[derive(Debug, Clone, Copy)]","highlight_start":1,"highlight_end":38},{"text":"        pub struct AggregateSignature {","highlight_start":1,"highlight_end":40},{"text":"            point: $sig,","highlight_start":1,"highlight_end":25},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl AggregateSignature {","highlight_start":1,"highlight_end":34},{"text":"            pub fn validate(&self) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":63},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    if !$sig_aggr_in_group(&self.point) {","highlight_start":1,"highlight_end":58},{"text":"                        return Err(BLST_ERROR::BLST_POINT_NOT_IN_GROUP);","highlight_start":1,"highlight_end":73},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_signature(sig: &Signature) -> Self {","highlight_start":1,"highlight_end":61},{"text":"                let mut agg_sig = <$sig>::default();","highlight_start":1,"highlight_end":53},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_from_aff(&mut agg_sig, &sig.point);","highlight_start":1,"highlight_end":61},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Self { point: agg_sig }","highlight_start":1,"highlight_end":40},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_signature(&self) -> Signature {","highlight_start":1,"highlight_end":54},{"text":"                let mut sig = <$sig_aff>::default();","highlight_start":1,"highlight_end":53},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_to_aff(&mut sig, &self.point);","highlight_start":1,"highlight_end":56},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Signature { point: sig }","highlight_start":1,"highlight_end":41},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Aggregate","highlight_start":1,"highlight_end":25},{"text":"            pub fn aggregate(","highlight_start":1,"highlight_end":30},{"text":"                sigs: &[&Signature],","highlight_start":1,"highlight_end":37},{"text":"                sigs_groupcheck: bool,","highlight_start":1,"highlight_end":39},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                if sigs.len() == 0 {","highlight_start":1,"highlight_end":37},{"text":"                    return Err(BLST_ERROR::BLST_AGGR_TYPE_MISMATCH);","highlight_start":1,"highlight_end":69},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if sigs_groupcheck {","highlight_start":1,"highlight_end":37},{"text":"                    // We can't actually judge if input is individual or","highlight_start":1,"highlight_end":73},{"text":"                    // aggregated signature, so we can't enforce infinitiy","highlight_start":1,"highlight_end":75},{"text":"                    // check.","highlight_start":1,"highlight_end":30},{"text":"                    sigs[0].validate(false)?;","highlight_start":1,"highlight_end":46},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut agg_sig = AggregateSignature::from_signature(sigs[0]);","highlight_start":1,"highlight_end":79},{"text":"                for s in sigs.iter().skip(1) {","highlight_start":1,"highlight_end":47},{"text":"                    if sigs_groupcheck {","highlight_start":1,"highlight_end":41},{"text":"                        s.validate(false)?;","highlight_start":1,"highlight_end":44},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        $sig_add_or_dbl_aff(","highlight_start":1,"highlight_end":45},{"text":"                            &mut agg_sig.point,","highlight_start":1,"highlight_end":48},{"text":"                            &agg_sig.point,","highlight_start":1,"highlight_end":44},{"text":"                            &s.point,","highlight_start":1,"highlight_end":38},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(agg_sig)","highlight_start":1,"highlight_end":28},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn aggregate_serialized(","highlight_start":1,"highlight_end":41},{"text":"                sigs: &[&[u8]],","highlight_start":1,"highlight_end":32},{"text":"                sigs_groupcheck: bool,","highlight_start":1,"highlight_end":39},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                // TODO - threading","highlight_start":1,"highlight_end":36},{"text":"                if sigs.len() == 0 {","highlight_start":1,"highlight_end":37},{"text":"                    return Err(BLST_ERROR::BLST_AGGR_TYPE_MISMATCH);","highlight_start":1,"highlight_end":69},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut sig = if sigs_groupcheck {","highlight_start":1,"highlight_end":51},{"text":"                    Signature::sig_validate(sigs[0], false)?","highlight_start":1,"highlight_end":61},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Signature::from_bytes(sigs[0])?","highlight_start":1,"highlight_end":52},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut agg_sig = AggregateSignature::from_signature(&sig);","highlight_start":1,"highlight_end":76},{"text":"                for s in sigs.iter().skip(1) {","highlight_start":1,"highlight_end":47},{"text":"                    sig = if sigs_groupcheck {","highlight_start":1,"highlight_end":47},{"text":"                        Signature::sig_validate(s, false)?","highlight_start":1,"highlight_end":59},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        Signature::from_bytes(s)?","highlight_start":1,"highlight_end":50},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        $sig_add_or_dbl_aff(","highlight_start":1,"highlight_end":45},{"text":"                            &mut agg_sig.point,","highlight_start":1,"highlight_end":48},{"text":"                            &agg_sig.point,","highlight_start":1,"highlight_end":44},{"text":"                            &sig.point,","highlight_start":1,"highlight_end":40},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(agg_sig)","highlight_start":1,"highlight_end":28},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn add_aggregate(&mut self, agg_sig: &AggregateSignature) {","highlight_start":1,"highlight_end":76},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_add_or_dbl(","highlight_start":1,"highlight_end":37},{"text":"                        &mut self.point,","highlight_start":1,"highlight_end":41},{"text":"                        &self.point,","highlight_start":1,"highlight_end":37},{"text":"                        &agg_sig.point,","highlight_start":1,"highlight_end":40},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn add_signature(","highlight_start":1,"highlight_end":34},{"text":"                &mut self,","highlight_start":1,"highlight_end":27},{"text":"                sig: &Signature,","highlight_start":1,"highlight_end":33},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"            ) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":42},{"text":"                if sig_groupcheck {","highlight_start":1,"highlight_end":36},{"text":"                    sig.validate(false)?;","highlight_start":1,"highlight_end":42},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_add_or_dbl_aff(","highlight_start":1,"highlight_end":41},{"text":"                        &mut self.point,","highlight_start":1,"highlight_end":41},{"text":"                        &self.point,","highlight_start":1,"highlight_end":37},{"text":"                        &sig.point,","highlight_start":1,"highlight_end":36},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn subgroup_check(&self) -> bool {","highlight_start":1,"highlight_end":51},{"text":"                unsafe { $sig_aggr_in_group(&self.point) }","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[cfg(test)]","highlight_start":1,"highlight_end":21},{"text":"        mod tests {","highlight_start":1,"highlight_end":20},{"text":"            use super::*;","highlight_start":1,"highlight_end":26},{"text":"            use rand::{RngCore, SeedableRng};","highlight_start":1,"highlight_end":46},{"text":"            use rand_chacha::ChaCha20Rng;","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Testing only - do not use for production","highlight_start":1,"highlight_end":56},{"text":"            pub fn gen_random_key(","highlight_start":1,"highlight_end":35},{"text":"                rng: &mut rand_chacha::ChaCha20Rng,","highlight_start":1,"highlight_end":52},{"text":"            ) -> SecretKey {","highlight_start":1,"highlight_end":29},{"text":"                let mut ikm = [0u8; 32];","highlight_start":1,"highlight_end":41},{"text":"                rng.fill_bytes(&mut ikm);","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut sk = <blst_scalar>::default();","highlight_start":1,"highlight_end":55},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    blst_keygen(&mut sk, ikm.as_ptr(), 32, ptr::null(), 0);","highlight_start":1,"highlight_end":76},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                SecretKey { value: sk }","highlight_start":1,"highlight_end":40},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[test]","highlight_start":1,"highlight_end":20},{"text":"            fn test_sign() {","highlight_start":1,"highlight_end":29},{"text":"                let ikm: [u8; 32] = [","highlight_start":1,"highlight_end":38},{"text":"                    0x93, 0xad, 0x7e, 0x65, 0xde, 0xad, 0x05, 0x2a, 0x08, 0x3a,","highlight_start":1,"highlight_end":80},{"text":"                    0x91, 0x0c, 0x8b, 0x72, 0x85, 0x91, 0x46, 0x4c, 0xca, 0x56,","highlight_start":1,"highlight_end":80},{"text":"                    0x60, 0x5b, 0xb0, 0x56, 0xed, 0xfe, 0x2b, 0x60, 0xa6, 0x3c,","highlight_start":1,"highlight_end":80},{"text":"                    0x48, 0x99,","highlight_start":1,"highlight_end":32},{"text":"                ];","highlight_start":1,"highlight_end":19},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sk = SecretKey::key_gen(&ikm, &[]).unwrap();","highlight_start":1,"highlight_end":65},{"text":"                let pk = sk.sk_to_pk();","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let dst = b\"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_\";","highlight_start":1,"highlight_end":74},{"text":"                let msg = b\"hello foo\";","highlight_start":1,"highlight_end":40},{"text":"                let sig = sk.sign(msg, dst, &[]);","highlight_start":1,"highlight_end":50},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let err = sig.verify(true, msg, dst, &[], &pk, true);","highlight_start":1,"highlight_end":70},{"text":"                assert_eq!(err, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[test]","highlight_start":1,"highlight_end":20},{"text":"            fn test_aggregate() {","highlight_start":1,"highlight_end":34},{"text":"                let num_msgs = 10;","highlight_start":1,"highlight_end":35},{"text":"                let dst = b\"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_\";","highlight_start":1,"highlight_end":74},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let seed = [0u8; 32];","highlight_start":1,"highlight_end":38},{"text":"                let mut rng = ChaCha20Rng::from_seed(seed);","highlight_start":1,"highlight_end":60},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sks: Vec<_> =","highlight_start":1,"highlight_end":34},{"text":"                    (0..num_msgs).map(|_| gen_random_key(&mut rng)).collect();","highlight_start":1,"highlight_end":79},{"text":"                let pks =","highlight_start":1,"highlight_end":26},{"text":"                    sks.iter().map(|sk| sk.sk_to_pk()).collect::<Vec<_>>();","highlight_start":1,"highlight_end":76},{"text":"                let pks_refs: Vec<&PublicKey> =","highlight_start":1,"highlight_end":48},{"text":"                    pks.iter().map(|pk| pk).collect();","highlight_start":1,"highlight_end":55},{"text":"                let pks_rev: Vec<&PublicKey> =","highlight_start":1,"highlight_end":47},{"text":"                    pks.iter().rev().map(|pk| pk).collect();","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_comp = pks[0].compress();","highlight_start":1,"highlight_end":49},{"text":"                let pk_uncomp = PublicKey::uncompress(&pk_comp);","highlight_start":1,"highlight_end":65},{"text":"                assert_eq!(pk_uncomp.is_ok(), true);","highlight_start":1,"highlight_end":53},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut msgs: Vec<Vec<u8>> = vec![vec![]; num_msgs];","highlight_start":1,"highlight_end":69},{"text":"                for i in 0..num_msgs {","highlight_start":1,"highlight_end":39},{"text":"                    let msg_len = (rng.next_u64() & 0x3F) + 1;","highlight_start":1,"highlight_end":63},{"text":"                    msgs[i] = vec![0u8; msg_len as usize];","highlight_start":1,"highlight_end":59},{"text":"                    rng.fill_bytes(&mut msgs[i]);","highlight_start":1,"highlight_end":50},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let msgs_refs: Vec<&[u8]> =","highlight_start":1,"highlight_end":44},{"text":"                    msgs.iter().map(|m| m.as_slice()).collect();","highlight_start":1,"highlight_end":65},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sigs = sks","highlight_start":1,"highlight_end":31},{"text":"                    .iter()","highlight_start":1,"highlight_end":28},{"text":"                    .zip(msgs.iter())","highlight_start":1,"highlight_end":38},{"text":"                    .map(|(sk, m)| (sk.sign(m, dst, &[])))","highlight_start":1,"highlight_end":59},{"text":"                    .collect::<Vec<Signature>>();","highlight_start":1,"highlight_end":50},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut errs = sigs","highlight_start":1,"highlight_end":36},{"text":"                    .iter()","highlight_start":1,"highlight_end":28},{"text":"                    .zip(msgs.iter())","highlight_start":1,"highlight_end":38},{"text":"                    .zip(pks.iter())","highlight_start":1,"highlight_end":37},{"text":"                    .map(|((s, m), pk)| (s.verify(true, m, dst, &[], pk, true)))","highlight_start":1,"highlight_end":81},{"text":"                    .collect::<Vec<BLST_ERROR>>();","highlight_start":1,"highlight_end":51},{"text":"                assert_eq!(errs, vec![BLST_ERROR::BLST_SUCCESS; num_msgs]);","highlight_start":1,"highlight_end":76},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Swap message/public key pairs to create bad signature","highlight_start":1,"highlight_end":73},{"text":"                errs = sigs","highlight_start":1,"highlight_end":28},{"text":"                    .iter()","highlight_start":1,"highlight_end":28},{"text":"                    .zip(msgs.iter())","highlight_start":1,"highlight_end":38},{"text":"                    .zip(pks.iter().rev())","highlight_start":1,"highlight_end":43},{"text":"                    .map(|((s, m), pk)| (s.verify(true, m, dst, &[], pk, true)))","highlight_start":1,"highlight_end":81},{"text":"                    .collect::<Vec<BLST_ERROR>>();","highlight_start":1,"highlight_end":51},{"text":"                assert_ne!(errs, vec![BLST_ERROR::BLST_SUCCESS; num_msgs]);","highlight_start":1,"highlight_end":76},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sig_refs =","highlight_start":1,"highlight_end":31},{"text":"                    sigs.iter().map(|s| s).collect::<Vec<&Signature>>();","highlight_start":1,"highlight_end":73},{"text":"                let agg = match AggregateSignature::aggregate(&sig_refs, true) {","highlight_start":1,"highlight_end":81},{"text":"                    Ok(agg) => agg,","highlight_start":1,"highlight_end":36},{"text":"                    Err(err) => panic!(\"aggregate failure: {:?}\", err),","highlight_start":1,"highlight_end":72},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let agg_sig = agg.to_signature();","highlight_start":1,"highlight_end":50},{"text":"                let mut result = agg_sig","highlight_start":1,"highlight_end":41},{"text":"                    .aggregate_verify(false, &msgs_refs, dst, &pks_refs, false);","highlight_start":1,"highlight_end":81},{"text":"                assert_eq!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Swap message/public key pairs to create bad signature","highlight_start":1,"highlight_end":73},{"text":"                result = agg_sig","highlight_start":1,"highlight_end":33},{"text":"                    .aggregate_verify(false, &msgs_refs, dst, &pks_rev, false);","highlight_start":1,"highlight_end":80},{"text":"                assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[test]","highlight_start":1,"highlight_end":20},{"text":"            fn test_multiple_agg_sigs() {","highlight_start":1,"highlight_end":42},{"text":"                let dst = b\"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_\";","highlight_start":1,"highlight_end":74},{"text":"                let num_pks_per_sig = 10;","highlight_start":1,"highlight_end":42},{"text":"                let num_sigs = 10;","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let seed = [0u8; 32];","highlight_start":1,"highlight_end":38},{"text":"                let mut rng = ChaCha20Rng::from_seed(seed);","highlight_start":1,"highlight_end":60},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut msgs: Vec<Vec<u8>> = vec![vec![]; num_sigs];","highlight_start":1,"highlight_end":69},{"text":"                let mut sigs: Vec<Signature> = Vec::with_capacity(num_sigs);","highlight_start":1,"highlight_end":77},{"text":"                let mut pks: Vec<PublicKey> = Vec::with_capacity(num_sigs);","highlight_start":1,"highlight_end":76},{"text":"                let mut rands: Vec<blst_scalar> = Vec::with_capacity(num_sigs);","highlight_start":1,"highlight_end":80},{"text":"                for i in 0..num_sigs {","highlight_start":1,"highlight_end":39},{"text":"                    // Create public keys","highlight_start":1,"highlight_end":42},{"text":"                    let sks_i: Vec<_> = (0..num_pks_per_sig)","highlight_start":1,"highlight_end":61},{"text":"                        .map(|_| gen_random_key(&mut rng))","highlight_start":1,"highlight_end":59},{"text":"                        .collect();","highlight_start":1,"highlight_end":36},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let pks_i = sks_i","highlight_start":1,"highlight_end":38},{"text":"                        .iter()","highlight_start":1,"highlight_end":32},{"text":"                        .map(|sk| sk.sk_to_pk())","highlight_start":1,"highlight_end":49},{"text":"                        .collect::<Vec<_>>();","highlight_start":1,"highlight_end":46},{"text":"                    let pks_refs_i: Vec<&PublicKey> =","highlight_start":1,"highlight_end":54},{"text":"                        pks_i.iter().map(|pk| pk).collect();","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Create random message for pks to all sign","highlight_start":1,"highlight_end":65},{"text":"                    let msg_len = (rng.next_u64() & 0x3F) + 1;","highlight_start":1,"highlight_end":63},{"text":"                    msgs[i] = vec![0u8; msg_len as usize];","highlight_start":1,"highlight_end":59},{"text":"                    rng.fill_bytes(&mut msgs[i]);","highlight_start":1,"highlight_end":50},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Generate signature for each key pair","highlight_start":1,"highlight_end":60},{"text":"                    let sigs_i = sks_i","highlight_start":1,"highlight_end":39},{"text":"                        .iter()","highlight_start":1,"highlight_end":32},{"text":"                        .map(|sk| sk.sign(&msgs[i], dst, &[]))","highlight_start":1,"highlight_end":63},{"text":"                        .collect::<Vec<Signature>>();","highlight_start":1,"highlight_end":54},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Test each current single signature","highlight_start":1,"highlight_end":58},{"text":"                    let errs = sigs_i","highlight_start":1,"highlight_end":38},{"text":"                        .iter()","highlight_start":1,"highlight_end":32},{"text":"                        .zip(pks_i.iter())","highlight_start":1,"highlight_end":43},{"text":"                        .map(|(s, pk)| {","highlight_start":1,"highlight_end":41},{"text":"                            (s.verify(true, &msgs[i], dst, &[], pk, true))","highlight_start":1,"highlight_end":75},{"text":"                        })","highlight_start":1,"highlight_end":27},{"text":"                        .collect::<Vec<BLST_ERROR>>();","highlight_start":1,"highlight_end":55},{"text":"                    assert_eq!(","highlight_start":1,"highlight_end":32},{"text":"                        errs,","highlight_start":1,"highlight_end":30},{"text":"                        vec![BLST_ERROR::BLST_SUCCESS; num_pks_per_sig]","highlight_start":1,"highlight_end":72},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let sig_refs_i =","highlight_start":1,"highlight_end":37},{"text":"                        sigs_i.iter().map(|s| s).collect::<Vec<&Signature>>();","highlight_start":1,"highlight_end":79},{"text":"                    let agg_i =","highlight_start":1,"highlight_end":32},{"text":"                        match AggregateSignature::aggregate(&sig_refs_i, false)","highlight_start":1,"highlight_end":80},{"text":"                        {","highlight_start":1,"highlight_end":26},{"text":"                            Ok(agg_i) => agg_i,","highlight_start":1,"highlight_end":48},{"text":"                            Err(err) => panic!(\"aggregate failure: {:?}\", err),","highlight_start":1,"highlight_end":80},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Test current aggregate signature","highlight_start":1,"highlight_end":56},{"text":"                    sigs.push(agg_i.to_signature());","highlight_start":1,"highlight_end":53},{"text":"                    let mut result = sigs[i].fast_aggregate_verify(","highlight_start":1,"highlight_end":68},{"text":"                        false,","highlight_start":1,"highlight_end":31},{"text":"                        &msgs[i],","highlight_start":1,"highlight_end":34},{"text":"                        dst,","highlight_start":1,"highlight_end":29},{"text":"                        &pks_refs_i,","highlight_start":1,"highlight_end":37},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                    assert_eq!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":66},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // negative test","highlight_start":1,"highlight_end":37},{"text":"                    if i != 0 {","highlight_start":1,"highlight_end":32},{"text":"                        result = sigs[i - 1].fast_aggregate_verify(","highlight_start":1,"highlight_end":68},{"text":"                            false,","highlight_start":1,"highlight_end":35},{"text":"                            &msgs[i],","highlight_start":1,"highlight_end":38},{"text":"                            dst,","highlight_start":1,"highlight_end":33},{"text":"                            &pks_refs_i,","highlight_start":1,"highlight_end":41},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                        assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":70},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // aggregate public keys and push into vec","highlight_start":1,"highlight_end":63},{"text":"                    let agg_pk_i =","highlight_start":1,"highlight_end":35},{"text":"                        match AggregatePublicKey::aggregate(&pks_refs_i, false)","highlight_start":1,"highlight_end":80},{"text":"                        {","highlight_start":1,"highlight_end":26},{"text":"                            Ok(agg_pk_i) => agg_pk_i,","highlight_start":1,"highlight_end":54},{"text":"                            Err(err) => panic!(\"aggregate failure: {:?}\", err),","highlight_start":1,"highlight_end":80},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                    pks.push(agg_pk_i.to_public_key());","highlight_start":1,"highlight_end":56},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Test current aggregate signature with aggregated pks","highlight_start":1,"highlight_end":76},{"text":"                    result = sigs[i].fast_aggregate_verify_pre_aggregated(","highlight_start":1,"highlight_end":75},{"text":"                        false, &msgs[i], dst, &pks[i],","highlight_start":1,"highlight_end":55},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                    assert_eq!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":66},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // negative test","highlight_start":1,"highlight_end":37},{"text":"                    if i != 0 {","highlight_start":1,"highlight_end":32},{"text":"                        result = sigs[i - 1]","highlight_start":1,"highlight_end":45},{"text":"                            .fast_aggregate_verify_pre_aggregated(","highlight_start":1,"highlight_end":67},{"text":"                                false, &msgs[i], dst, &pks[i],","highlight_start":1,"highlight_end":63},{"text":"                            );","highlight_start":1,"highlight_end":31},{"text":"                        assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":70},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // create random values","highlight_start":1,"highlight_end":44},{"text":"                    let mut vals = [0u64; 4];","highlight_start":1,"highlight_end":46},{"text":"                    vals[0] = rng.next_u64();","highlight_start":1,"highlight_end":46},{"text":"                    while vals[0] == 0 {","highlight_start":1,"highlight_end":41},{"text":"                        // Reject zero as it is used for multiplication.","highlight_start":1,"highlight_end":73},{"text":"                        vals[0] = rng.next_u64();","highlight_start":1,"highlight_end":50},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    let mut rand_i =","highlight_start":1,"highlight_end":37},{"text":"                        std::mem::MaybeUninit::<blst_scalar>::uninit();","highlight_start":1,"highlight_end":72},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        blst_scalar_from_uint64(","highlight_start":1,"highlight_end":49},{"text":"                            rand_i.as_mut_ptr(),","highlight_start":1,"highlight_end":49},{"text":"                            vals.as_ptr(),","highlight_start":1,"highlight_end":43},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                        rands.push(rand_i.assume_init());","highlight_start":1,"highlight_end":58},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let msgs_refs: Vec<&[u8]> =","highlight_start":1,"highlight_end":44},{"text":"                    msgs.iter().map(|m| m.as_slice()).collect();","highlight_start":1,"highlight_end":65},{"text":"                let sig_refs =","highlight_start":1,"highlight_end":31},{"text":"                    sigs.iter().map(|s| s).collect::<Vec<&Signature>>();","highlight_start":1,"highlight_end":73},{"text":"                let pks_refs: Vec<&PublicKey> =","highlight_start":1,"highlight_end":48},{"text":"                    pks.iter().map(|pk| pk).collect();","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let msgs_rev: Vec<&[u8]> =","highlight_start":1,"highlight_end":43},{"text":"                    msgs.iter().rev().map(|m| m.as_slice()).collect();","highlight_start":1,"highlight_end":71},{"text":"                let sig_rev =","highlight_start":1,"highlight_end":30},{"text":"                    sigs.iter().rev().map(|s| s).collect::<Vec<&Signature>>();","highlight_start":1,"highlight_end":79},{"text":"                let pks_rev: Vec<&PublicKey> =","highlight_start":1,"highlight_end":47},{"text":"                    pks.iter().rev().map(|pk| pk).collect();","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut result =","highlight_start":1,"highlight_end":33},{"text":"                    Signature::verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":69},{"text":"                        &msgs_refs, dst, &pks_refs, false, &sig_refs, true,","highlight_start":1,"highlight_end":76},{"text":"                        &rands, 64,","highlight_start":1,"highlight_end":36},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                assert_eq!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // negative tests (use reverse msgs, pks, and sigs)","highlight_start":1,"highlight_end":68},{"text":"                result = Signature::verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":74},{"text":"                    &msgs_rev, dst, &pks_refs, false, &sig_refs, true, &rands,","highlight_start":1,"highlight_end":79},{"text":"                    64,","highlight_start":1,"highlight_end":24},{"text":"                );","highlight_start":1,"highlight_end":19},{"text":"                assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                result = Signature::verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":74},{"text":"                    &msgs_refs, dst, &pks_rev, false, &sig_refs, true, &rands,","highlight_start":1,"highlight_end":79},{"text":"                    64,","highlight_start":1,"highlight_end":24},{"text":"                );","highlight_start":1,"highlight_end":19},{"text":"                assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                result = Signature::verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":74},{"text":"                    &msgs_refs, dst, &pks_refs, false, &sig_rev, true, &rands,","highlight_start":1,"highlight_end":79},{"text":"                    64,","highlight_start":1,"highlight_end":24},{"text":"                );","highlight_start":1,"highlight_end":19},{"text":"                assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[test]","highlight_start":1,"highlight_end":20},{"text":"            fn test_serialization() {","highlight_start":1,"highlight_end":38},{"text":"                let seed = [0u8; 32];","highlight_start":1,"highlight_end":38},{"text":"                let mut rng = ChaCha20Rng::from_seed(seed);","highlight_start":1,"highlight_end":60},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sk = gen_random_key(&mut rng);","highlight_start":1,"highlight_end":51},{"text":"                let sk2 = gen_random_key(&mut rng);","highlight_start":1,"highlight_end":52},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk = sk.sk_to_pk();","highlight_start":1,"highlight_end":40},{"text":"                let pk_comp = pk.compress();","highlight_start":1,"highlight_end":45},{"text":"                let pk_ser = pk.serialize();","highlight_start":1,"highlight_end":45},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_uncomp = PublicKey::uncompress(&pk_comp);","highlight_start":1,"highlight_end":65},{"text":"                assert_eq!(pk_uncomp.is_ok(), true);","highlight_start":1,"highlight_end":53},{"text":"                assert_eq!(pk_uncomp.unwrap(), pk);","highlight_start":1,"highlight_end":52},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_deser = PublicKey::deserialize(&pk_ser);","highlight_start":1,"highlight_end":64},{"text":"                assert_eq!(pk_deser.is_ok(), true);","highlight_start":1,"highlight_end":52},{"text":"                assert_eq!(pk_deser.unwrap(), pk);","highlight_start":1,"highlight_end":51},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk2 = sk2.sk_to_pk();","highlight_start":1,"highlight_end":42},{"text":"                let pk_comp2 = pk2.compress();","highlight_start":1,"highlight_end":47},{"text":"                let pk_ser2 = pk2.serialize();","highlight_start":1,"highlight_end":47},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_uncomp2 = PublicKey::uncompress(&pk_comp2);","highlight_start":1,"highlight_end":67},{"text":"                assert_eq!(pk_uncomp2.is_ok(), true);","highlight_start":1,"highlight_end":54},{"text":"                assert_eq!(pk_uncomp2.unwrap(), pk2);","highlight_start":1,"highlight_end":54},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_deser2 = PublicKey::deserialize(&pk_ser2);","highlight_start":1,"highlight_end":66},{"text":"                assert_eq!(pk_deser2.is_ok(), true);","highlight_start":1,"highlight_end":53},{"text":"                assert_eq!(pk_deser2.unwrap(), pk2);","highlight_start":1,"highlight_end":53},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                assert_ne!(pk, pk2);","highlight_start":1,"highlight_end":37},{"text":"                assert_ne!(pk_uncomp.unwrap(), pk2);","highlight_start":1,"highlight_end":53},{"text":"                assert_ne!(pk_deser.unwrap(), pk2);","highlight_start":1,"highlight_end":52},{"text":"                assert_ne!(pk_uncomp2.unwrap(), pk);","highlight_start":1,"highlight_end":53},{"text":"                assert_ne!(pk_deser2.unwrap(), pk);","highlight_start":1,"highlight_end":52},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: variable does not need to be mutable\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/azureuser/blst/bindings/rust/src/lib.rs:779:21\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m779\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m                let mut acc = rx.recv().unwrap();\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: remove this `mut`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1516\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    sig_variant_impl!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1517\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"MinSig\",\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1518\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        blst_p2,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1519\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        blst_p2_affine,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1553\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        blst_p1_in_g1,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1554\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    );\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|______-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this warning originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"variable does not need to be mutable","code":{"code":"unused_mut","explanation":null},"level":"warning","spans":[{"file_name":"/home/azureuser/blst/bindings/rust/src/lib.rs","byte_start":31357,"byte_end":31364,"line_start":935,"line_end":935,"column_start":21,"column_end":28,"is_primary":true,"text":[{"text":"                let mut acc = rx.recv().unwrap();","highlight_start":21,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/azureuser/blst/bindings/rust/src/lib.rs","byte_start":51945,"byte_end":52960,"line_start":1472,"line_end":1510,"column_start":5,"column_end":7,"is_primary":false,"text":[{"text":"    sig_variant_impl!(","highlight_start":5,"highlight_end":23},{"text":"        \"MinPk\",","highlight_start":1,"highlight_end":17},{"text":"        blst_p1,","highlight_start":1,"highlight_end":17},{"text":"        blst_p1_affine,","highlight_start":1,"highlight_end":24},{"text":"        blst_p2,","highlight_start":1,"highlight_end":17},{"text":"        blst_p2_affine,","highlight_start":1,"highlight_end":24},{"text":"        blst_sk_to_pk2_in_g1,","highlight_start":1,"highlight_end":30},{"text":"        true,","highlight_start":1,"highlight_end":14},{"text":"        blst_hash_to_g2,","highlight_start":1,"highlight_end":25},{"text":"        blst_sign_pk2_in_g1,","highlight_start":1,"highlight_end":29},{"text":"        blst_p1_affine_is_equal,","highlight_start":1,"highlight_end":33},{"text":"        blst_p2_affine_is_equal,","highlight_start":1,"highlight_end":33},{"text":"        blst_core_verify_pk_in_g1,","highlight_start":1,"highlight_end":35},{"text":"        blst_p1_affine_in_g1,","highlight_start":1,"highlight_end":30},{"text":"        blst_p1_to_affine,","highlight_start":1,"highlight_end":27},{"text":"        blst_p1_from_affine,","highlight_start":1,"highlight_end":29},{"text":"        blst_p1_affine_serialize,","highlight_start":1,"highlight_end":34},{"text":"        blst_p1_affine_compress,","highlight_start":1,"highlight_end":33},{"text":"        blst_p1_deserialize,","highlight_start":1,"highlight_end":29},{"text":"        blst_p1_uncompress,","highlight_start":1,"highlight_end":28},{"text":"        48,","highlight_start":1,"highlight_end":12},{"text":"        96,","highlight_start":1,"highlight_end":12},{"text":"        blst_p2_affine_in_g2,","highlight_start":1,"highlight_end":30},{"text":"        blst_p2_to_affine,","highlight_start":1,"highlight_end":27},{"text":"        blst_p2_from_affine,","highlight_start":1,"highlight_end":29},{"text":"        blst_p2_affine_serialize,","highlight_start":1,"highlight_end":34},{"text":"        blst_p2_affine_compress,","highlight_start":1,"highlight_end":33},{"text":"        blst_p2_deserialize,","highlight_start":1,"highlight_end":29},{"text":"        blst_p2_uncompress,","highlight_start":1,"highlight_end":28},{"text":"        96,","highlight_start":1,"highlight_end":12},{"text":"        192,","highlight_start":1,"highlight_end":13},{"text":"        blst_p1_add_or_double,","highlight_start":1,"highlight_end":31},{"text":"        blst_p1_add_or_double_affine,","highlight_start":1,"highlight_end":38},{"text":"        blst_p2_add_or_double,","highlight_start":1,"highlight_end":31},{"text":"        blst_p2_add_or_double_affine,","highlight_start":1,"highlight_end":38},{"text":"        blst_p1_affine_is_inf,","highlight_start":1,"highlight_end":31},{"text":"        blst_p2_affine_is_inf,","highlight_start":1,"highlight_end":31},{"text":"        blst_p2_in_g2,","highlight_start":1,"highlight_end":23},{"text":"    );","highlight_start":1,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"sig_variant_impl!","def_site_span":{"file_name":"/home/azureuser/blst/bindings/rust/src/lib.rs","byte_start":7790,"byte_end":51903,"line_start":283,"line_end":1467,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! sig_variant_impl {","highlight_start":1,"highlight_end":32},{"text":"    (","highlight_start":1,"highlight_end":6},{"text":"        $name:expr,","highlight_start":1,"highlight_end":20},{"text":"        $pk:ty,","highlight_start":1,"highlight_end":16},{"text":"        $pk_aff:ty,","highlight_start":1,"highlight_end":20},{"text":"        $sig:ty,","highlight_start":1,"highlight_end":17},{"text":"        $sig_aff:ty,","highlight_start":1,"highlight_end":21},{"text":"        $sk_to_pk:ident,","highlight_start":1,"highlight_end":25},{"text":"        $hash_or_encode:expr,","highlight_start":1,"highlight_end":30},{"text":"        $hash_or_encode_to:ident,","highlight_start":1,"highlight_end":34},{"text":"        $sign:ident,","highlight_start":1,"highlight_end":21},{"text":"        $pk_eq:ident,","highlight_start":1,"highlight_end":22},{"text":"        $sig_eq:ident,","highlight_start":1,"highlight_end":23},{"text":"        $verify:ident,","highlight_start":1,"highlight_end":23},{"text":"        $pk_in_group:ident,","highlight_start":1,"highlight_end":28},{"text":"        $pk_to_aff:ident,","highlight_start":1,"highlight_end":26},{"text":"        $pk_from_aff:ident,","highlight_start":1,"highlight_end":28},{"text":"        $pk_ser:ident,","highlight_start":1,"highlight_end":23},{"text":"        $pk_comp:ident,","highlight_start":1,"highlight_end":24},{"text":"        $pk_deser:ident,","highlight_start":1,"highlight_end":25},{"text":"        $pk_uncomp:ident,","highlight_start":1,"highlight_end":26},{"text":"        $pk_comp_size:expr,","highlight_start":1,"highlight_end":28},{"text":"        $pk_ser_size:expr,","highlight_start":1,"highlight_end":27},{"text":"        $sig_in_group:ident,","highlight_start":1,"highlight_end":29},{"text":"        $sig_to_aff:ident,","highlight_start":1,"highlight_end":27},{"text":"        $sig_from_aff:ident,","highlight_start":1,"highlight_end":29},{"text":"        $sig_ser:ident,","highlight_start":1,"highlight_end":24},{"text":"        $sig_comp:ident,","highlight_start":1,"highlight_end":25},{"text":"        $sig_deser:ident,","highlight_start":1,"highlight_end":26},{"text":"        $sig_uncomp:ident,","highlight_start":1,"highlight_end":27},{"text":"        $sig_comp_size:expr,","highlight_start":1,"highlight_end":29},{"text":"        $sig_ser_size:expr,","highlight_start":1,"highlight_end":28},{"text":"        $pk_add_or_dbl:ident,","highlight_start":1,"highlight_end":30},{"text":"        $pk_add_or_dbl_aff:ident,","highlight_start":1,"highlight_end":34},{"text":"        $sig_add_or_dbl:ident,","highlight_start":1,"highlight_end":31},{"text":"        $sig_add_or_dbl_aff:ident,","highlight_start":1,"highlight_end":35},{"text":"        $pk_is_inf:ident,","highlight_start":1,"highlight_end":26},{"text":"        $sig_is_inf:ident,","highlight_start":1,"highlight_end":27},{"text":"        $sig_aggr_in_group:ident,","highlight_start":1,"highlight_end":34},{"text":"    ) => {","highlight_start":1,"highlight_end":11},{"text":"        /// Secret Key","highlight_start":1,"highlight_end":23},{"text":"        #[derive(Default, Debug, Clone, Zeroize)]","highlight_start":1,"highlight_end":50},{"text":"        #[zeroize(drop)]","highlight_start":1,"highlight_end":25},{"text":"        pub struct SecretKey {","highlight_start":1,"highlight_end":31},{"text":"            value: blst_scalar,","highlight_start":1,"highlight_end":32},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl SecretKey {","highlight_start":1,"highlight_end":25},{"text":"            /// Deterministically generate a secret key from key material","highlight_start":1,"highlight_end":74},{"text":"            pub fn key_gen(","highlight_start":1,"highlight_end":28},{"text":"                ikm: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                key_info: &[u8],","highlight_start":1,"highlight_end":33},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                if ikm.len() < 32 {","highlight_start":1,"highlight_end":36},{"text":"                    return Err(BLST_ERROR::BLST_BAD_ENCODING);","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut sk = SecretKey::default();","highlight_start":1,"highlight_end":51},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    blst_keygen(","highlight_start":1,"highlight_end":33},{"text":"                        &mut sk.value,","highlight_start":1,"highlight_end":39},{"text":"                        ikm.as_ptr(),","highlight_start":1,"highlight_end":38},{"text":"                        ikm.len(),","highlight_start":1,"highlight_end":35},{"text":"                        key_info.as_ptr(),","highlight_start":1,"highlight_end":43},{"text":"                        key_info.len(),","highlight_start":1,"highlight_end":40},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(sk)","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // sk_to_pk","highlight_start":1,"highlight_end":24},{"text":"            pub fn sk_to_pk(&self) -> PublicKey {","highlight_start":1,"highlight_end":50},{"text":"                // TODO - would the user like the serialized/compressed pk as well?","highlight_start":1,"highlight_end":84},{"text":"                let mut pk_aff = PublicKey::default();","highlight_start":1,"highlight_end":55},{"text":"                //let mut pk_ser = [0u8; $pk_ser_size];","highlight_start":1,"highlight_end":56},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sk_to_pk(","highlight_start":1,"highlight_end":31},{"text":"                        //pk_ser.as_mut_ptr(),","highlight_start":1,"highlight_end":47},{"text":"                        ptr::null_mut(),","highlight_start":1,"highlight_end":41},{"text":"                        &mut pk_aff.point,","highlight_start":1,"highlight_end":43},{"text":"                        &self.value,","highlight_start":1,"highlight_end":37},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                pk_aff","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Sign","highlight_start":1,"highlight_end":20},{"text":"            pub fn sign(","highlight_start":1,"highlight_end":25},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                msg: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                aug: &[u8],","highlight_start":1,"highlight_end":28},{"text":"            ) -> Signature {","highlight_start":1,"highlight_end":29},{"text":"                // TODO - would the user like the serialized/compressed sig as well?","highlight_start":1,"highlight_end":85},{"text":"                let mut q = <$sig>::default();","highlight_start":1,"highlight_end":47},{"text":"                let mut sig_aff = <$sig_aff>::default();","highlight_start":1,"highlight_end":57},{"text":"                //let mut sig_ser = [0u8; $sig_ser_size];","highlight_start":1,"highlight_end":58},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $hash_or_encode_to(","highlight_start":1,"highlight_end":40},{"text":"                        &mut q,","highlight_start":1,"highlight_end":32},{"text":"                        msg.as_ptr(),","highlight_start":1,"highlight_end":38},{"text":"                        msg.len(),","highlight_start":1,"highlight_end":35},{"text":"                        dst.as_ptr(),","highlight_start":1,"highlight_end":38},{"text":"                        dst.len(),","highlight_start":1,"highlight_end":35},{"text":"                        aug.as_ptr(),","highlight_start":1,"highlight_end":38},{"text":"                        aug.len(),","highlight_start":1,"highlight_end":35},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                    $sign(ptr::null_mut(), &mut sig_aff, &q, &self.value);","highlight_start":1,"highlight_end":75},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Signature { point: sig_aff }","highlight_start":1,"highlight_end":45},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // TODO - formally speaking application is entitled to have","highlight_start":1,"highlight_end":72},{"text":"            // ultimate control over secret key storage, which means that","highlight_start":1,"highlight_end":74},{"text":"            // corresponding serialization/deserialization subroutines","highlight_start":1,"highlight_end":71},{"text":"            // should accept reference to where to store the result, as","highlight_start":1,"highlight_end":72},{"text":"            // opposite to returning one.","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // serialize","highlight_start":1,"highlight_end":25},{"text":"            pub fn serialize(&self) -> [u8; 32] {","highlight_start":1,"highlight_end":50},{"text":"                let mut sk_out = [0; 32];","highlight_start":1,"highlight_end":42},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    blst_bendian_from_scalar(sk_out.as_mut_ptr(), &self.value);","highlight_start":1,"highlight_end":80},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                sk_out","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // deserialize","highlight_start":1,"highlight_end":27},{"text":"            pub fn deserialize(sk_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":75},{"text":"                let mut sk = blst_scalar::default();","highlight_start":1,"highlight_end":53},{"text":"                if sk_in.len() != 32 {","highlight_start":1,"highlight_end":39},{"text":"                    return Err(BLST_ERROR::BLST_BAD_ENCODING);","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    blst_scalar_from_bendian(&mut sk, sk_in.as_ptr());","highlight_start":1,"highlight_end":71},{"text":"                    if !blst_sk_check(&sk) {","highlight_start":1,"highlight_end":45},{"text":"                        return Err(BLST_ERROR::BLST_BAD_ENCODING);","highlight_start":1,"highlight_end":67},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(Self { value: sk })","highlight_start":1,"highlight_end":39},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_bytes(&self) -> [u8; 32] {","highlight_start":1,"highlight_end":49},{"text":"                SecretKey::serialize(&self)","highlight_start":1,"highlight_end":44},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_bytes(sk_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":74},{"text":"                SecretKey::deserialize(sk_in)","highlight_start":1,"highlight_end":46},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[derive(Default, Debug, Clone, Copy)]","highlight_start":1,"highlight_end":47},{"text":"        pub struct PublicKey {","highlight_start":1,"highlight_end":31},{"text":"            point: $pk_aff,","highlight_start":1,"highlight_end":28},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl PublicKey {","highlight_start":1,"highlight_end":25},{"text":"            // Core operations","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // key_validate","highlight_start":1,"highlight_end":28},{"text":"            pub fn validate(&self) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":63},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    if $pk_is_inf(&self.point) {","highlight_start":1,"highlight_end":49},{"text":"                        return Err(BLST_ERROR::BLST_PK_IS_INFINITY);","highlight_start":1,"highlight_end":69},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    if !$pk_in_group(&self.point) {","highlight_start":1,"highlight_end":52},{"text":"                        return Err(BLST_ERROR::BLST_POINT_NOT_IN_GROUP);","highlight_start":1,"highlight_end":73},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn key_validate(key: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":74},{"text":"                let pk = PublicKey::from_bytes(key)?;","highlight_start":1,"highlight_end":54},{"text":"                pk.validate()?;","highlight_start":1,"highlight_end":32},{"text":"                Ok(pk)","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_aggregate(agg_pk: &AggregatePublicKey) -> Self {","highlight_start":1,"highlight_end":73},{"text":"                let mut pk_aff = <$pk_aff>::default();","highlight_start":1,"highlight_end":55},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_to_aff(&mut pk_aff, &agg_pk.point);","highlight_start":1,"highlight_end":60},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Self { point: pk_aff }","highlight_start":1,"highlight_end":39},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Serdes","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn compress(&self) -> [u8; $pk_comp_size] {","highlight_start":1,"highlight_end":60},{"text":"                let mut pk_comp = [0u8; $pk_comp_size];","highlight_start":1,"highlight_end":56},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_comp(pk_comp.as_mut_ptr(), &self.point);","highlight_start":1,"highlight_end":65},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                pk_comp","highlight_start":1,"highlight_end":24},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn serialize(&self) -> [u8; $pk_ser_size] {","highlight_start":1,"highlight_end":60},{"text":"                let mut pk_out = [0u8; $pk_ser_size];","highlight_start":1,"highlight_end":54},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_ser(pk_out.as_mut_ptr(), &self.point);","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                pk_out","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn uncompress(pk_comp: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":76},{"text":"                if pk_comp.len() == $pk_comp_size && (pk_comp[0] & 0x80) != 0 {","highlight_start":1,"highlight_end":80},{"text":"                    let mut pk = <$pk_aff>::default();","highlight_start":1,"highlight_end":55},{"text":"                    let err = unsafe { $pk_uncomp(&mut pk, pk_comp.as_ptr()) };","highlight_start":1,"highlight_end":80},{"text":"                    if err != BLST_ERROR::BLST_SUCCESS {","highlight_start":1,"highlight_end":57},{"text":"                        return Err(err);","highlight_start":1,"highlight_end":41},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(Self { point: pk })","highlight_start":1,"highlight_end":43},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Err(BLST_ERROR::BLST_BAD_ENCODING)","highlight_start":1,"highlight_end":55},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn deserialize(pk_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":75},{"text":"                if (pk_in.len() == $pk_ser_size && (pk_in[0] & 0x80) == 0)","highlight_start":1,"highlight_end":75},{"text":"                    || (pk_in.len() == $pk_comp_size && (pk_in[0] & 0x80) != 0)","highlight_start":1,"highlight_end":80},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    let mut pk = <$pk_aff>::default();","highlight_start":1,"highlight_end":55},{"text":"                    let err = unsafe { $pk_deser(&mut pk, pk_in.as_ptr()) };","highlight_start":1,"highlight_end":77},{"text":"                    if err != BLST_ERROR::BLST_SUCCESS {","highlight_start":1,"highlight_end":57},{"text":"                        return Err(err);","highlight_start":1,"highlight_end":41},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(Self { point: pk })","highlight_start":1,"highlight_end":43},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Err(BLST_ERROR::BLST_BAD_ENCODING)","highlight_start":1,"highlight_end":55},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_bytes(pk_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":74},{"text":"                PublicKey::deserialize(pk_in)","highlight_start":1,"highlight_end":46},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_bytes(&self) -> [u8; $pk_comp_size] {","highlight_start":1,"highlight_end":60},{"text":"                self.compress()","highlight_start":1,"highlight_end":32},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Trait for equality comparisons which are equivalence relations.","highlight_start":1,"highlight_end":75},{"text":"        //","highlight_start":1,"highlight_end":11},{"text":"        // This means, that in addition to a == b and a != b being strict","highlight_start":1,"highlight_end":74},{"text":"        // inverses, the equality must be reflexive, symmetric and transitive.","highlight_start":1,"highlight_end":79},{"text":"        impl Eq for PublicKey {}","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl PartialEq for PublicKey {","highlight_start":1,"highlight_end":39},{"text":"            fn eq(&self, other: &Self) -> bool {","highlight_start":1,"highlight_end":49},{"text":"                unsafe { $pk_eq(&self.point, &other.point) }","highlight_start":1,"highlight_end":61},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[derive(Debug, Clone, Copy)]","highlight_start":1,"highlight_end":38},{"text":"        pub struct AggregatePublicKey {","highlight_start":1,"highlight_end":40},{"text":"            point: $pk,","highlight_start":1,"highlight_end":24},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl AggregatePublicKey {","highlight_start":1,"highlight_end":34},{"text":"            pub fn from_public_key(pk: &PublicKey) -> Self {","highlight_start":1,"highlight_end":61},{"text":"                let mut agg_pk = <$pk>::default();","highlight_start":1,"highlight_end":51},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_from_aff(&mut agg_pk, &pk.point);","highlight_start":1,"highlight_end":58},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Self { point: agg_pk }","highlight_start":1,"highlight_end":39},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_public_key(&self) -> PublicKey {","highlight_start":1,"highlight_end":55},{"text":"                let mut pk = <$pk_aff>::default();","highlight_start":1,"highlight_end":51},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_to_aff(&mut pk, &self.point);","highlight_start":1,"highlight_end":54},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                PublicKey { point: pk }","highlight_start":1,"highlight_end":40},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Aggregate","highlight_start":1,"highlight_end":25},{"text":"            pub fn aggregate(","highlight_start":1,"highlight_end":30},{"text":"                pks: &[&PublicKey],","highlight_start":1,"highlight_end":36},{"text":"                pks_validate: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                if pks.len() == 0 {","highlight_start":1,"highlight_end":36},{"text":"                    return Err(BLST_ERROR::BLST_AGGR_TYPE_MISMATCH);","highlight_start":1,"highlight_end":69},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if pks_validate {","highlight_start":1,"highlight_end":34},{"text":"                    pks[0].validate()?;","highlight_start":1,"highlight_end":40},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut agg_pk = AggregatePublicKey::from_public_key(pks[0]);","highlight_start":1,"highlight_end":78},{"text":"                for s in pks.iter().skip(1) {","highlight_start":1,"highlight_end":46},{"text":"                    if pks_validate {","highlight_start":1,"highlight_end":38},{"text":"                        s.validate()?;","highlight_start":1,"highlight_end":39},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        $pk_add_or_dbl_aff(","highlight_start":1,"highlight_end":44},{"text":"                            &mut agg_pk.point,","highlight_start":1,"highlight_end":47},{"text":"                            &agg_pk.point,","highlight_start":1,"highlight_end":43},{"text":"                            &s.point,","highlight_start":1,"highlight_end":38},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(agg_pk)","highlight_start":1,"highlight_end":27},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn aggregate_serialized(","highlight_start":1,"highlight_end":41},{"text":"                pks: &[&[u8]],","highlight_start":1,"highlight_end":31},{"text":"                pks_validate: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                // TODO - threading","highlight_start":1,"highlight_end":36},{"text":"                if pks.len() == 0 {","highlight_start":1,"highlight_end":36},{"text":"                    return Err(BLST_ERROR::BLST_AGGR_TYPE_MISMATCH);","highlight_start":1,"highlight_end":69},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut pk = if pks_validate {","highlight_start":1,"highlight_end":47},{"text":"                    PublicKey::key_validate(pks[0])?","highlight_start":1,"highlight_end":53},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    PublicKey::from_bytes(pks[0])?","highlight_start":1,"highlight_end":51},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut agg_pk = AggregatePublicKey::from_public_key(&pk);","highlight_start":1,"highlight_end":75},{"text":"                for s in pks.iter().skip(1) {","highlight_start":1,"highlight_end":46},{"text":"                    pk = if pks_validate {","highlight_start":1,"highlight_end":43},{"text":"                        PublicKey::key_validate(s)?","highlight_start":1,"highlight_end":52},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        PublicKey::from_bytes(s)?","highlight_start":1,"highlight_end":50},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        $pk_add_or_dbl_aff(","highlight_start":1,"highlight_end":44},{"text":"                            &mut agg_pk.point,","highlight_start":1,"highlight_end":47},{"text":"                            &agg_pk.point,","highlight_start":1,"highlight_end":43},{"text":"                            &pk.point,","highlight_start":1,"highlight_end":39},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(agg_pk)","highlight_start":1,"highlight_end":27},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn add_aggregate(&mut self, agg_pk: &AggregatePublicKey) {","highlight_start":1,"highlight_end":75},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_add_or_dbl(&mut self.point, &self.point, &agg_pk.point);","highlight_start":1,"highlight_end":81},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn add_public_key(","highlight_start":1,"highlight_end":35},{"text":"                &mut self,","highlight_start":1,"highlight_end":27},{"text":"                pk: &PublicKey,","highlight_start":1,"highlight_end":32},{"text":"                pk_validate: bool,","highlight_start":1,"highlight_end":35},{"text":"            ) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":42},{"text":"                if pk_validate {","highlight_start":1,"highlight_end":33},{"text":"                    pk.validate()?;","highlight_start":1,"highlight_end":36},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_add_or_dbl_aff(&mut self.point, &self.point, &pk.point);","highlight_start":1,"highlight_end":81},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[derive(Debug, Clone, Copy)]","highlight_start":1,"highlight_end":38},{"text":"        pub struct Signature {","highlight_start":1,"highlight_end":31},{"text":"            point: $sig_aff,","highlight_start":1,"highlight_end":29},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl Signature {","highlight_start":1,"highlight_end":25},{"text":"            // sig_infcheck, check for infinity, is a way to avoid going","highlight_start":1,"highlight_end":73},{"text":"            // into resource-consuming verification. Passing 'false' is","highlight_start":1,"highlight_end":72},{"text":"            // always cryptographically safe, but application might want","highlight_start":1,"highlight_end":73},{"text":"            // to guard against obviously bogus individual[!] signatures.","highlight_start":1,"highlight_end":74},{"text":"            pub fn validate(","highlight_start":1,"highlight_end":29},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_infcheck: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":42},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    if sig_infcheck && $sig_is_inf(&self.point) {","highlight_start":1,"highlight_end":66},{"text":"                        return Err(BLST_ERROR::BLST_PK_IS_INFINITY);","highlight_start":1,"highlight_end":69},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    if !$sig_in_group(&self.point) {","highlight_start":1,"highlight_end":53},{"text":"                        return Err(BLST_ERROR::BLST_POINT_NOT_IN_GROUP);","highlight_start":1,"highlight_end":73},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn sig_validate(","highlight_start":1,"highlight_end":33},{"text":"                sig: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                sig_infcheck: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                let sig = Signature::from_bytes(sig)?;","highlight_start":1,"highlight_end":55},{"text":"                sig.validate(sig_infcheck)?;","highlight_start":1,"highlight_end":45},{"text":"                Ok(sig)","highlight_start":1,"highlight_end":24},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn verify(","highlight_start":1,"highlight_end":27},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"                msg: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                aug: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pk: &PublicKey,","highlight_start":1,"highlight_end":32},{"text":"                pk_validate: bool,","highlight_start":1,"highlight_end":35},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                let aug_msg = [aug, msg].concat();","highlight_start":1,"highlight_end":51},{"text":"                self.aggregate_verify(","highlight_start":1,"highlight_end":39},{"text":"                    sig_groupcheck,","highlight_start":1,"highlight_end":36},{"text":"                    &[aug_msg.as_slice()],","highlight_start":1,"highlight_end":43},{"text":"                    dst,","highlight_start":1,"highlight_end":25},{"text":"                    &[pk],","highlight_start":1,"highlight_end":27},{"text":"                    pk_validate,","highlight_start":1,"highlight_end":33},{"text":"                )","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn aggregate_verify(","highlight_start":1,"highlight_end":37},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"                msgs: &[&[u8]],","highlight_start":1,"highlight_end":32},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pks: &[&PublicKey],","highlight_start":1,"highlight_end":36},{"text":"                pks_validate: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                let n_elems = pks.len();","highlight_start":1,"highlight_end":41},{"text":"                if n_elems == 0 || msgs.len() != n_elems {","highlight_start":1,"highlight_end":59},{"text":"                    return BLST_ERROR::BLST_VERIFY_FAIL;","highlight_start":1,"highlight_end":57},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // TODO - check msg uniqueness?","highlight_start":1,"highlight_end":48},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // let pool = da_pool();","highlight_start":1,"highlight_end":41},{"text":"                let (tx, rx) = channel();","highlight_start":1,"highlight_end":42},{"text":"                let counter = Arc::new(AtomicUsize::new(0));","highlight_start":1,"highlight_end":61},{"text":"                let valid = Arc::new(AtomicBool::new(true));","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Bypass 'lifetime limitations by brute force. It works,","highlight_start":1,"highlight_end":74},{"text":"                // because we explicitly join the threads...","highlight_start":1,"highlight_end":61},{"text":"                let raw_pks = unsafe {","highlight_start":1,"highlight_end":39},{"text":"                    transmute::<*const &PublicKey, usize>(pks.as_ptr())","highlight_start":1,"highlight_end":72},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let raw_msgs =","highlight_start":1,"highlight_end":31},{"text":"                    unsafe { transmute::<*const &[u8], usize>(msgs.as_ptr()) };","highlight_start":1,"highlight_end":80},{"text":"                let dst =","highlight_start":1,"highlight_end":26},{"text":"                    unsafe { slice::from_raw_parts(dst.as_ptr(), dst.len()) };","highlight_start":1,"highlight_end":79},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // let n_workers = std::cmp::min(pool.max_count(), n_elems);","highlight_start":1,"highlight_end":77},{"text":"                // for _ in 0..n_workers {","highlight_start":1,"highlight_end":43},{"text":"                    let tx = tx.clone();","highlight_start":1,"highlight_end":41},{"text":"                    let counter = counter.clone();","highlight_start":1,"highlight_end":51},{"text":"                    let valid = valid.clone();","highlight_start":1,"highlight_end":47},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // pool.execute(move || {","highlight_start":1,"highlight_end":46},{"text":"                        let mut pairing = Pairing::new($hash_or_encode, dst);","highlight_start":1,"highlight_end":78},{"text":"                        // reconstruct input slices...","highlight_start":1,"highlight_end":55},{"text":"                        let msgs = unsafe {","highlight_start":1,"highlight_end":44},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &[u8]>(raw_msgs),","highlight_start":1,"highlight_end":76},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                        let pks = unsafe {","highlight_start":1,"highlight_end":43},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &PublicKey>(raw_pks),","highlight_start":1,"highlight_end":80},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        while valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":62},{"text":"                            let work = counter.fetch_add(1, Ordering::Relaxed);","highlight_start":1,"highlight_end":80},{"text":"                            if work >= n_elems {","highlight_start":1,"highlight_end":49},{"text":"                                break;","highlight_start":1,"highlight_end":39},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                            if pairing.aggregate(","highlight_start":1,"highlight_end":50},{"text":"                                &pks[work].point,","highlight_start":1,"highlight_end":50},{"text":"                                pks_validate,","highlight_start":1,"highlight_end":46},{"text":"                                &unsafe { ptr::null::<$sig_aff>().as_ref() },","highlight_start":1,"highlight_end":78},{"text":"                                false,","highlight_start":1,"highlight_end":39},{"text":"                                &msgs[work],","highlight_start":1,"highlight_end":45},{"text":"                                &[],","highlight_start":1,"highlight_end":37},{"text":"                            ) != BLST_ERROR::BLST_SUCCESS","highlight_start":1,"highlight_end":58},{"text":"                            {","highlight_start":1,"highlight_end":30},{"text":"                                valid.store(false, Ordering::Relaxed);","highlight_start":1,"highlight_end":71},{"text":"                                break;","highlight_start":1,"highlight_end":39},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        if valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":59},{"text":"                            pairing.commit();","highlight_start":1,"highlight_end":46},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        tx.send(pairing).expect(\"disaster\");","highlight_start":1,"highlight_end":61},{"text":"                    // });","highlight_start":1,"highlight_end":27},{"text":"                // }","highlight_start":1,"highlight_end":21},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                if sig_groupcheck && valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":69},{"text":"                    match self.validate(false) {","highlight_start":1,"highlight_end":49},{"text":"                        Err(_err) => valid.store(false, Ordering::Relaxed),","highlight_start":1,"highlight_end":76},{"text":"                        _ => (),","highlight_start":1,"highlight_end":33},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut gtsig = blst_fp12::default();","highlight_start":1,"highlight_end":54},{"text":"                if valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":51},{"text":"                    Pairing::aggregated(&mut gtsig, &self.point);","highlight_start":1,"highlight_end":66},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut acc = rx.recv().unwrap();","highlight_start":1,"highlight_end":50},{"text":"                // for _ in 1..n_workers {","highlight_start":1,"highlight_end":43},{"text":"                    // acc.merge(&rx.recv().unwrap());","highlight_start":1,"highlight_end":55},{"text":"                // }","highlight_start":1,"highlight_end":21},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                if valid.load(Ordering::Relaxed)","highlight_start":1,"highlight_end":49},{"text":"                    && acc.finalverify(Some(&gtsig))","highlight_start":1,"highlight_end":53},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    BLST_ERROR::BLST_SUCCESS","highlight_start":1,"highlight_end":45},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    BLST_ERROR::BLST_VERIFY_FAIL","highlight_start":1,"highlight_end":49},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // pks are assumed to be verified for proof of possession,","highlight_start":1,"highlight_end":71},{"text":"            // which implies that they are already group-checked","highlight_start":1,"highlight_end":65},{"text":"            pub fn fast_aggregate_verify(","highlight_start":1,"highlight_end":42},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"                msg: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pks: &[&PublicKey],","highlight_start":1,"highlight_end":36},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                let agg_pk = match AggregatePublicKey::aggregate(pks, false) {","highlight_start":1,"highlight_end":79},{"text":"                    Ok(agg_sig) => agg_sig,","highlight_start":1,"highlight_end":44},{"text":"                    Err(err) => return err,","highlight_start":1,"highlight_end":44},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let pk = agg_pk.to_public_key();","highlight_start":1,"highlight_end":49},{"text":"                self.aggregate_verify(","highlight_start":1,"highlight_end":39},{"text":"                    sig_groupcheck,","highlight_start":1,"highlight_end":36},{"text":"                    &[msg],","highlight_start":1,"highlight_end":28},{"text":"                    dst,","highlight_start":1,"highlight_end":25},{"text":"                    &[&pk],","highlight_start":1,"highlight_end":28},{"text":"                    false,","highlight_start":1,"highlight_end":27},{"text":"                )","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn fast_aggregate_verify_pre_aggregated(","highlight_start":1,"highlight_end":57},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"                msg: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pk: &PublicKey,","highlight_start":1,"highlight_end":32},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                self.aggregate_verify(sig_groupcheck, &[msg], dst, &[pk], false)","highlight_start":1,"highlight_end":81},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // https://ethresear.ch/t/fast-verification-of-multiple-bls-signatures/5407","highlight_start":1,"highlight_end":88},{"text":"            pub fn verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":57},{"text":"                msgs: &[&[u8]],","highlight_start":1,"highlight_end":32},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pks: &[&PublicKey],","highlight_start":1,"highlight_end":36},{"text":"                pks_validate: bool,","highlight_start":1,"highlight_end":36},{"text":"                sigs: &[&Signature],","highlight_start":1,"highlight_end":37},{"text":"                sigs_groupcheck: bool,","highlight_start":1,"highlight_end":39},{"text":"                rands: &[blst_scalar],","highlight_start":1,"highlight_end":39},{"text":"                rand_bits: usize,","highlight_start":1,"highlight_end":34},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                let n_elems = pks.len();","highlight_start":1,"highlight_end":41},{"text":"                if n_elems == 0","highlight_start":1,"highlight_end":32},{"text":"                    || msgs.len() != n_elems","highlight_start":1,"highlight_end":45},{"text":"                    || sigs.len() != n_elems","highlight_start":1,"highlight_end":45},{"text":"                    || rands.len() != n_elems","highlight_start":1,"highlight_end":46},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    return BLST_ERROR::BLST_VERIFY_FAIL;","highlight_start":1,"highlight_end":57},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // TODO - check msg uniqueness?","highlight_start":1,"highlight_end":48},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // let pool = da_pool();","highlight_start":1,"highlight_end":41},{"text":"                let (tx, rx) = channel();","highlight_start":1,"highlight_end":42},{"text":"                let counter = Arc::new(AtomicUsize::new(0));","highlight_start":1,"highlight_end":61},{"text":"                let valid = Arc::new(AtomicBool::new(true));","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Bypass 'lifetime limitations by brute force. It works,","highlight_start":1,"highlight_end":74},{"text":"                // because we explicitly join the threads...","highlight_start":1,"highlight_end":61},{"text":"                let raw_pks = unsafe {","highlight_start":1,"highlight_end":39},{"text":"                    transmute::<*const &PublicKey, usize>(pks.as_ptr())","highlight_start":1,"highlight_end":72},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let raw_sigs = unsafe {","highlight_start":1,"highlight_end":40},{"text":"                    transmute::<*const &Signature, usize>(sigs.as_ptr())","highlight_start":1,"highlight_end":73},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let raw_rands = unsafe {","highlight_start":1,"highlight_end":41},{"text":"                    transmute::<*const blst_scalar, usize>(rands.as_ptr())","highlight_start":1,"highlight_end":75},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let raw_msgs =","highlight_start":1,"highlight_end":31},{"text":"                    unsafe { transmute::<*const &[u8], usize>(msgs.as_ptr()) };","highlight_start":1,"highlight_end":80},{"text":"                let dst =","highlight_start":1,"highlight_end":26},{"text":"                    unsafe { slice::from_raw_parts(dst.as_ptr(), dst.len()) };","highlight_start":1,"highlight_end":79},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // let n_workers = std::cmp::min(pool.max_count(), n_elems);","highlight_start":1,"highlight_end":77},{"text":"                //for _ in 0..n_workers {","highlight_start":1,"highlight_end":42},{"text":"                    let tx = tx.clone();","highlight_start":1,"highlight_end":41},{"text":"                    let counter = counter.clone();","highlight_start":1,"highlight_end":51},{"text":"                    let valid = valid.clone();","highlight_start":1,"highlight_end":47},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // pool.execute(move || {","highlight_start":1,"highlight_end":46},{"text":"                        let mut pairing = Pairing::new($hash_or_encode, dst);","highlight_start":1,"highlight_end":78},{"text":"                        // reconstruct input slices...","highlight_start":1,"highlight_end":55},{"text":"                        let rands = unsafe {","highlight_start":1,"highlight_end":45},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const blst_scalar>(","highlight_start":1,"highlight_end":72},{"text":"                                    raw_rands,","highlight_start":1,"highlight_end":47},{"text":"                                ),","highlight_start":1,"highlight_end":35},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                        let msgs = unsafe {","highlight_start":1,"highlight_end":44},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &[u8]>(raw_msgs),","highlight_start":1,"highlight_end":76},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                        let sigs = unsafe {","highlight_start":1,"highlight_end":44},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &Signature>(raw_sigs),","highlight_start":1,"highlight_end":81},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                        let pks = unsafe {","highlight_start":1,"highlight_end":43},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &PublicKey>(raw_pks),","highlight_start":1,"highlight_end":80},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        // TODO - engage multi-point mul-n-add for larger","highlight_start":1,"highlight_end":74},{"text":"                        // amount of inputs...","highlight_start":1,"highlight_end":47},{"text":"                        while valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":62},{"text":"                            let work = counter.fetch_add(1, Ordering::Relaxed);","highlight_start":1,"highlight_end":80},{"text":"                            if work >= n_elems {","highlight_start":1,"highlight_end":49},{"text":"                                break;","highlight_start":1,"highlight_end":39},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            if pairing.mul_n_aggregate(","highlight_start":1,"highlight_end":56},{"text":"                                &pks[work].point,","highlight_start":1,"highlight_end":50},{"text":"                                pks_validate,","highlight_start":1,"highlight_end":46},{"text":"                                &sigs[work].point,","highlight_start":1,"highlight_end":51},{"text":"                                sigs_groupcheck,","highlight_start":1,"highlight_end":49},{"text":"                                &rands[work].b,","highlight_start":1,"highlight_end":48},{"text":"                                rand_bits,","highlight_start":1,"highlight_end":43},{"text":"                                msgs[work],","highlight_start":1,"highlight_end":44},{"text":"                                &[],","highlight_start":1,"highlight_end":37},{"text":"                            ) != BLST_ERROR::BLST_SUCCESS","highlight_start":1,"highlight_end":58},{"text":"                            {","highlight_start":1,"highlight_end":30},{"text":"                                valid.store(false, Ordering::Relaxed);","highlight_start":1,"highlight_end":71},{"text":"                                break;","highlight_start":1,"highlight_end":39},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        if valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":59},{"text":"                            pairing.commit();","highlight_start":1,"highlight_end":46},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        tx.send(pairing).expect(\"disaster\");","highlight_start":1,"highlight_end":61},{"text":"                    // });","highlight_start":1,"highlight_end":27},{"text":"                //}","highlight_start":1,"highlight_end":20},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut acc = rx.recv().unwrap();","highlight_start":1,"highlight_end":50},{"text":"                //for _ in 1..n_workers {","highlight_start":1,"highlight_end":42},{"text":"                    // acc.merge(&rx.recv().unwrap());","highlight_start":1,"highlight_end":55},{"text":"                //}","highlight_start":1,"highlight_end":20},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                if valid.load(Ordering::Relaxed) && acc.finalverify(None) {","highlight_start":1,"highlight_end":76},{"text":"                    BLST_ERROR::BLST_SUCCESS","highlight_start":1,"highlight_end":45},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    BLST_ERROR::BLST_VERIFY_FAIL","highlight_start":1,"highlight_end":49},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_aggregate(agg_sig: &AggregateSignature) -> Self {","highlight_start":1,"highlight_end":74},{"text":"                let mut sig_aff = <$sig_aff>::default();","highlight_start":1,"highlight_end":57},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_to_aff(&mut sig_aff, &agg_sig.point);","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Self { point: sig_aff }","highlight_start":1,"highlight_end":40},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn compress(&self) -> [u8; $sig_comp_size] {","highlight_start":1,"highlight_end":61},{"text":"                let mut sig_comp = [0; $sig_comp_size];","highlight_start":1,"highlight_end":56},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_comp(sig_comp.as_mut_ptr(), &self.point);","highlight_start":1,"highlight_end":67},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                sig_comp","highlight_start":1,"highlight_end":25},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn serialize(&self) -> [u8; $sig_ser_size] {","highlight_start":1,"highlight_end":61},{"text":"                let mut sig_out = [0; $sig_ser_size];","highlight_start":1,"highlight_end":54},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_ser(sig_out.as_mut_ptr(), &self.point);","highlight_start":1,"highlight_end":65},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                sig_out","highlight_start":1,"highlight_end":24},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn uncompress(sig_comp: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":77},{"text":"                if sig_comp.len() == $sig_comp_size && (sig_comp[0] & 0x80) != 0","highlight_start":1,"highlight_end":81},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    let mut sig = <$sig_aff>::default();","highlight_start":1,"highlight_end":57},{"text":"                    let err =","highlight_start":1,"highlight_end":30},{"text":"                        unsafe { $sig_uncomp(&mut sig, sig_comp.as_ptr()) };","highlight_start":1,"highlight_end":77},{"text":"                    if err != BLST_ERROR::BLST_SUCCESS {","highlight_start":1,"highlight_end":57},{"text":"                        return Err(err);","highlight_start":1,"highlight_end":41},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(Self { point: sig })","highlight_start":1,"highlight_end":44},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Err(BLST_ERROR::BLST_BAD_ENCODING)","highlight_start":1,"highlight_end":55},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn deserialize(sig_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":76},{"text":"                if (sig_in.len() == $sig_ser_size && (sig_in[0] & 0x80) == 0)","highlight_start":1,"highlight_end":78},{"text":"                    || (sig_in.len() == $sig_comp_size","highlight_start":1,"highlight_end":55},{"text":"                        && (sig_in[0] & 0x80) != 0)","highlight_start":1,"highlight_end":52},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    let mut sig = <$sig_aff>::default();","highlight_start":1,"highlight_end":57},{"text":"                    let err = unsafe { $sig_deser(&mut sig, sig_in.as_ptr()) };","highlight_start":1,"highlight_end":80},{"text":"                    if err != BLST_ERROR::BLST_SUCCESS {","highlight_start":1,"highlight_end":57},{"text":"                        return Err(err);","highlight_start":1,"highlight_end":41},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(Self { point: sig })","highlight_start":1,"highlight_end":44},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Err(BLST_ERROR::BLST_BAD_ENCODING)","highlight_start":1,"highlight_end":55},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_bytes(sig_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":75},{"text":"                Signature::deserialize(sig_in)","highlight_start":1,"highlight_end":47},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_bytes(&self) -> [u8; $sig_comp_size] {","highlight_start":1,"highlight_end":61},{"text":"                self.compress()","highlight_start":1,"highlight_end":32},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn subgroup_check(&self) -> bool {","highlight_start":1,"highlight_end":51},{"text":"                unsafe { $sig_in_group(&self.point) }","highlight_start":1,"highlight_end":54},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Trait for equality comparisons which are equivalence relations.","highlight_start":1,"highlight_end":75},{"text":"        //","highlight_start":1,"highlight_end":11},{"text":"        // This means, that in addition to a == b and a != b being strict","highlight_start":1,"highlight_end":74},{"text":"        // inverses, the equality must be reflexive, symmetric and transitive.","highlight_start":1,"highlight_end":79},{"text":"        impl Eq for Signature {}","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl PartialEq for Signature {","highlight_start":1,"highlight_end":39},{"text":"            fn eq(&self, other: &Self) -> bool {","highlight_start":1,"highlight_end":49},{"text":"                unsafe { $sig_eq(&self.point, &other.point) }","highlight_start":1,"highlight_end":62},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[derive(Debug, Clone, Copy)]","highlight_start":1,"highlight_end":38},{"text":"        pub struct AggregateSignature {","highlight_start":1,"highlight_end":40},{"text":"            point: $sig,","highlight_start":1,"highlight_end":25},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl AggregateSignature {","highlight_start":1,"highlight_end":34},{"text":"            pub fn validate(&self) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":63},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    if !$sig_aggr_in_group(&self.point) {","highlight_start":1,"highlight_end":58},{"text":"                        return Err(BLST_ERROR::BLST_POINT_NOT_IN_GROUP);","highlight_start":1,"highlight_end":73},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_signature(sig: &Signature) -> Self {","highlight_start":1,"highlight_end":61},{"text":"                let mut agg_sig = <$sig>::default();","highlight_start":1,"highlight_end":53},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_from_aff(&mut agg_sig, &sig.point);","highlight_start":1,"highlight_end":61},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Self { point: agg_sig }","highlight_start":1,"highlight_end":40},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_signature(&self) -> Signature {","highlight_start":1,"highlight_end":54},{"text":"                let mut sig = <$sig_aff>::default();","highlight_start":1,"highlight_end":53},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_to_aff(&mut sig, &self.point);","highlight_start":1,"highlight_end":56},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Signature { point: sig }","highlight_start":1,"highlight_end":41},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Aggregate","highlight_start":1,"highlight_end":25},{"text":"            pub fn aggregate(","highlight_start":1,"highlight_end":30},{"text":"                sigs: &[&Signature],","highlight_start":1,"highlight_end":37},{"text":"                sigs_groupcheck: bool,","highlight_start":1,"highlight_end":39},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                if sigs.len() == 0 {","highlight_start":1,"highlight_end":37},{"text":"                    return Err(BLST_ERROR::BLST_AGGR_TYPE_MISMATCH);","highlight_start":1,"highlight_end":69},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if sigs_groupcheck {","highlight_start":1,"highlight_end":37},{"text":"                    // We can't actually judge if input is individual or","highlight_start":1,"highlight_end":73},{"text":"                    // aggregated signature, so we can't enforce infinitiy","highlight_start":1,"highlight_end":75},{"text":"                    // check.","highlight_start":1,"highlight_end":30},{"text":"                    sigs[0].validate(false)?;","highlight_start":1,"highlight_end":46},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut agg_sig = AggregateSignature::from_signature(sigs[0]);","highlight_start":1,"highlight_end":79},{"text":"                for s in sigs.iter().skip(1) {","highlight_start":1,"highlight_end":47},{"text":"                    if sigs_groupcheck {","highlight_start":1,"highlight_end":41},{"text":"                        s.validate(false)?;","highlight_start":1,"highlight_end":44},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        $sig_add_or_dbl_aff(","highlight_start":1,"highlight_end":45},{"text":"                            &mut agg_sig.point,","highlight_start":1,"highlight_end":48},{"text":"                            &agg_sig.point,","highlight_start":1,"highlight_end":44},{"text":"                            &s.point,","highlight_start":1,"highlight_end":38},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(agg_sig)","highlight_start":1,"highlight_end":28},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn aggregate_serialized(","highlight_start":1,"highlight_end":41},{"text":"                sigs: &[&[u8]],","highlight_start":1,"highlight_end":32},{"text":"                sigs_groupcheck: bool,","highlight_start":1,"highlight_end":39},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                // TODO - threading","highlight_start":1,"highlight_end":36},{"text":"                if sigs.len() == 0 {","highlight_start":1,"highlight_end":37},{"text":"                    return Err(BLST_ERROR::BLST_AGGR_TYPE_MISMATCH);","highlight_start":1,"highlight_end":69},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut sig = if sigs_groupcheck {","highlight_start":1,"highlight_end":51},{"text":"                    Signature::sig_validate(sigs[0], false)?","highlight_start":1,"highlight_end":61},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Signature::from_bytes(sigs[0])?","highlight_start":1,"highlight_end":52},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut agg_sig = AggregateSignature::from_signature(&sig);","highlight_start":1,"highlight_end":76},{"text":"                for s in sigs.iter().skip(1) {","highlight_start":1,"highlight_end":47},{"text":"                    sig = if sigs_groupcheck {","highlight_start":1,"highlight_end":47},{"text":"                        Signature::sig_validate(s, false)?","highlight_start":1,"highlight_end":59},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        Signature::from_bytes(s)?","highlight_start":1,"highlight_end":50},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        $sig_add_or_dbl_aff(","highlight_start":1,"highlight_end":45},{"text":"                            &mut agg_sig.point,","highlight_start":1,"highlight_end":48},{"text":"                            &agg_sig.point,","highlight_start":1,"highlight_end":44},{"text":"                            &sig.point,","highlight_start":1,"highlight_end":40},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(agg_sig)","highlight_start":1,"highlight_end":28},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn add_aggregate(&mut self, agg_sig: &AggregateSignature) {","highlight_start":1,"highlight_end":76},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_add_or_dbl(","highlight_start":1,"highlight_end":37},{"text":"                        &mut self.point,","highlight_start":1,"highlight_end":41},{"text":"                        &self.point,","highlight_start":1,"highlight_end":37},{"text":"                        &agg_sig.point,","highlight_start":1,"highlight_end":40},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn add_signature(","highlight_start":1,"highlight_end":34},{"text":"                &mut self,","highlight_start":1,"highlight_end":27},{"text":"                sig: &Signature,","highlight_start":1,"highlight_end":33},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"            ) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":42},{"text":"                if sig_groupcheck {","highlight_start":1,"highlight_end":36},{"text":"                    sig.validate(false)?;","highlight_start":1,"highlight_end":42},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_add_or_dbl_aff(","highlight_start":1,"highlight_end":41},{"text":"                        &mut self.point,","highlight_start":1,"highlight_end":41},{"text":"                        &self.point,","highlight_start":1,"highlight_end":37},{"text":"                        &sig.point,","highlight_start":1,"highlight_end":36},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn subgroup_check(&self) -> bool {","highlight_start":1,"highlight_end":51},{"text":"                unsafe { $sig_aggr_in_group(&self.point) }","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[cfg(test)]","highlight_start":1,"highlight_end":21},{"text":"        mod tests {","highlight_start":1,"highlight_end":20},{"text":"            use super::*;","highlight_start":1,"highlight_end":26},{"text":"            use rand::{RngCore, SeedableRng};","highlight_start":1,"highlight_end":46},{"text":"            use rand_chacha::ChaCha20Rng;","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Testing only - do not use for production","highlight_start":1,"highlight_end":56},{"text":"            pub fn gen_random_key(","highlight_start":1,"highlight_end":35},{"text":"                rng: &mut rand_chacha::ChaCha20Rng,","highlight_start":1,"highlight_end":52},{"text":"            ) -> SecretKey {","highlight_start":1,"highlight_end":29},{"text":"                let mut ikm = [0u8; 32];","highlight_start":1,"highlight_end":41},{"text":"                rng.fill_bytes(&mut ikm);","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut sk = <blst_scalar>::default();","highlight_start":1,"highlight_end":55},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    blst_keygen(&mut sk, ikm.as_ptr(), 32, ptr::null(), 0);","highlight_start":1,"highlight_end":76},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                SecretKey { value: sk }","highlight_start":1,"highlight_end":40},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[test]","highlight_start":1,"highlight_end":20},{"text":"            fn test_sign() {","highlight_start":1,"highlight_end":29},{"text":"                let ikm: [u8; 32] = [","highlight_start":1,"highlight_end":38},{"text":"                    0x93, 0xad, 0x7e, 0x65, 0xde, 0xad, 0x05, 0x2a, 0x08, 0x3a,","highlight_start":1,"highlight_end":80},{"text":"                    0x91, 0x0c, 0x8b, 0x72, 0x85, 0x91, 0x46, 0x4c, 0xca, 0x56,","highlight_start":1,"highlight_end":80},{"text":"                    0x60, 0x5b, 0xb0, 0x56, 0xed, 0xfe, 0x2b, 0x60, 0xa6, 0x3c,","highlight_start":1,"highlight_end":80},{"text":"                    0x48, 0x99,","highlight_start":1,"highlight_end":32},{"text":"                ];","highlight_start":1,"highlight_end":19},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sk = SecretKey::key_gen(&ikm, &[]).unwrap();","highlight_start":1,"highlight_end":65},{"text":"                let pk = sk.sk_to_pk();","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let dst = b\"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_\";","highlight_start":1,"highlight_end":74},{"text":"                let msg = b\"hello foo\";","highlight_start":1,"highlight_end":40},{"text":"                let sig = sk.sign(msg, dst, &[]);","highlight_start":1,"highlight_end":50},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let err = sig.verify(true, msg, dst, &[], &pk, true);","highlight_start":1,"highlight_end":70},{"text":"                assert_eq!(err, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[test]","highlight_start":1,"highlight_end":20},{"text":"            fn test_aggregate() {","highlight_start":1,"highlight_end":34},{"text":"                let num_msgs = 10;","highlight_start":1,"highlight_end":35},{"text":"                let dst = b\"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_\";","highlight_start":1,"highlight_end":74},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let seed = [0u8; 32];","highlight_start":1,"highlight_end":38},{"text":"                let mut rng = ChaCha20Rng::from_seed(seed);","highlight_start":1,"highlight_end":60},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sks: Vec<_> =","highlight_start":1,"highlight_end":34},{"text":"                    (0..num_msgs).map(|_| gen_random_key(&mut rng)).collect();","highlight_start":1,"highlight_end":79},{"text":"                let pks =","highlight_start":1,"highlight_end":26},{"text":"                    sks.iter().map(|sk| sk.sk_to_pk()).collect::<Vec<_>>();","highlight_start":1,"highlight_end":76},{"text":"                let pks_refs: Vec<&PublicKey> =","highlight_start":1,"highlight_end":48},{"text":"                    pks.iter().map(|pk| pk).collect();","highlight_start":1,"highlight_end":55},{"text":"                let pks_rev: Vec<&PublicKey> =","highlight_start":1,"highlight_end":47},{"text":"                    pks.iter().rev().map(|pk| pk).collect();","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_comp = pks[0].compress();","highlight_start":1,"highlight_end":49},{"text":"                let pk_uncomp = PublicKey::uncompress(&pk_comp);","highlight_start":1,"highlight_end":65},{"text":"                assert_eq!(pk_uncomp.is_ok(), true);","highlight_start":1,"highlight_end":53},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut msgs: Vec<Vec<u8>> = vec![vec![]; num_msgs];","highlight_start":1,"highlight_end":69},{"text":"                for i in 0..num_msgs {","highlight_start":1,"highlight_end":39},{"text":"                    let msg_len = (rng.next_u64() & 0x3F) + 1;","highlight_start":1,"highlight_end":63},{"text":"                    msgs[i] = vec![0u8; msg_len as usize];","highlight_start":1,"highlight_end":59},{"text":"                    rng.fill_bytes(&mut msgs[i]);","highlight_start":1,"highlight_end":50},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let msgs_refs: Vec<&[u8]> =","highlight_start":1,"highlight_end":44},{"text":"                    msgs.iter().map(|m| m.as_slice()).collect();","highlight_start":1,"highlight_end":65},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sigs = sks","highlight_start":1,"highlight_end":31},{"text":"                    .iter()","highlight_start":1,"highlight_end":28},{"text":"                    .zip(msgs.iter())","highlight_start":1,"highlight_end":38},{"text":"                    .map(|(sk, m)| (sk.sign(m, dst, &[])))","highlight_start":1,"highlight_end":59},{"text":"                    .collect::<Vec<Signature>>();","highlight_start":1,"highlight_end":50},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut errs = sigs","highlight_start":1,"highlight_end":36},{"text":"                    .iter()","highlight_start":1,"highlight_end":28},{"text":"                    .zip(msgs.iter())","highlight_start":1,"highlight_end":38},{"text":"                    .zip(pks.iter())","highlight_start":1,"highlight_end":37},{"text":"                    .map(|((s, m), pk)| (s.verify(true, m, dst, &[], pk, true)))","highlight_start":1,"highlight_end":81},{"text":"                    .collect::<Vec<BLST_ERROR>>();","highlight_start":1,"highlight_end":51},{"text":"                assert_eq!(errs, vec![BLST_ERROR::BLST_SUCCESS; num_msgs]);","highlight_start":1,"highlight_end":76},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Swap message/public key pairs to create bad signature","highlight_start":1,"highlight_end":73},{"text":"                errs = sigs","highlight_start":1,"highlight_end":28},{"text":"                    .iter()","highlight_start":1,"highlight_end":28},{"text":"                    .zip(msgs.iter())","highlight_start":1,"highlight_end":38},{"text":"                    .zip(pks.iter().rev())","highlight_start":1,"highlight_end":43},{"text":"                    .map(|((s, m), pk)| (s.verify(true, m, dst, &[], pk, true)))","highlight_start":1,"highlight_end":81},{"text":"                    .collect::<Vec<BLST_ERROR>>();","highlight_start":1,"highlight_end":51},{"text":"                assert_ne!(errs, vec![BLST_ERROR::BLST_SUCCESS; num_msgs]);","highlight_start":1,"highlight_end":76},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sig_refs =","highlight_start":1,"highlight_end":31},{"text":"                    sigs.iter().map(|s| s).collect::<Vec<&Signature>>();","highlight_start":1,"highlight_end":73},{"text":"                let agg = match AggregateSignature::aggregate(&sig_refs, true) {","highlight_start":1,"highlight_end":81},{"text":"                    Ok(agg) => agg,","highlight_start":1,"highlight_end":36},{"text":"                    Err(err) => panic!(\"aggregate failure: {:?}\", err),","highlight_start":1,"highlight_end":72},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let agg_sig = agg.to_signature();","highlight_start":1,"highlight_end":50},{"text":"                let mut result = agg_sig","highlight_start":1,"highlight_end":41},{"text":"                    .aggregate_verify(false, &msgs_refs, dst, &pks_refs, false);","highlight_start":1,"highlight_end":81},{"text":"                assert_eq!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Swap message/public key pairs to create bad signature","highlight_start":1,"highlight_end":73},{"text":"                result = agg_sig","highlight_start":1,"highlight_end":33},{"text":"                    .aggregate_verify(false, &msgs_refs, dst, &pks_rev, false);","highlight_start":1,"highlight_end":80},{"text":"                assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[test]","highlight_start":1,"highlight_end":20},{"text":"            fn test_multiple_agg_sigs() {","highlight_start":1,"highlight_end":42},{"text":"                let dst = b\"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_\";","highlight_start":1,"highlight_end":74},{"text":"                let num_pks_per_sig = 10;","highlight_start":1,"highlight_end":42},{"text":"                let num_sigs = 10;","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let seed = [0u8; 32];","highlight_start":1,"highlight_end":38},{"text":"                let mut rng = ChaCha20Rng::from_seed(seed);","highlight_start":1,"highlight_end":60},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut msgs: Vec<Vec<u8>> = vec![vec![]; num_sigs];","highlight_start":1,"highlight_end":69},{"text":"                let mut sigs: Vec<Signature> = Vec::with_capacity(num_sigs);","highlight_start":1,"highlight_end":77},{"text":"                let mut pks: Vec<PublicKey> = Vec::with_capacity(num_sigs);","highlight_start":1,"highlight_end":76},{"text":"                let mut rands: Vec<blst_scalar> = Vec::with_capacity(num_sigs);","highlight_start":1,"highlight_end":80},{"text":"                for i in 0..num_sigs {","highlight_start":1,"highlight_end":39},{"text":"                    // Create public keys","highlight_start":1,"highlight_end":42},{"text":"                    let sks_i: Vec<_> = (0..num_pks_per_sig)","highlight_start":1,"highlight_end":61},{"text":"                        .map(|_| gen_random_key(&mut rng))","highlight_start":1,"highlight_end":59},{"text":"                        .collect();","highlight_start":1,"highlight_end":36},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let pks_i = sks_i","highlight_start":1,"highlight_end":38},{"text":"                        .iter()","highlight_start":1,"highlight_end":32},{"text":"                        .map(|sk| sk.sk_to_pk())","highlight_start":1,"highlight_end":49},{"text":"                        .collect::<Vec<_>>();","highlight_start":1,"highlight_end":46},{"text":"                    let pks_refs_i: Vec<&PublicKey> =","highlight_start":1,"highlight_end":54},{"text":"                        pks_i.iter().map(|pk| pk).collect();","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Create random message for pks to all sign","highlight_start":1,"highlight_end":65},{"text":"                    let msg_len = (rng.next_u64() & 0x3F) + 1;","highlight_start":1,"highlight_end":63},{"text":"                    msgs[i] = vec![0u8; msg_len as usize];","highlight_start":1,"highlight_end":59},{"text":"                    rng.fill_bytes(&mut msgs[i]);","highlight_start":1,"highlight_end":50},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Generate signature for each key pair","highlight_start":1,"highlight_end":60},{"text":"                    let sigs_i = sks_i","highlight_start":1,"highlight_end":39},{"text":"                        .iter()","highlight_start":1,"highlight_end":32},{"text":"                        .map(|sk| sk.sign(&msgs[i], dst, &[]))","highlight_start":1,"highlight_end":63},{"text":"                        .collect::<Vec<Signature>>();","highlight_start":1,"highlight_end":54},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Test each current single signature","highlight_start":1,"highlight_end":58},{"text":"                    let errs = sigs_i","highlight_start":1,"highlight_end":38},{"text":"                        .iter()","highlight_start":1,"highlight_end":32},{"text":"                        .zip(pks_i.iter())","highlight_start":1,"highlight_end":43},{"text":"                        .map(|(s, pk)| {","highlight_start":1,"highlight_end":41},{"text":"                            (s.verify(true, &msgs[i], dst, &[], pk, true))","highlight_start":1,"highlight_end":75},{"text":"                        })","highlight_start":1,"highlight_end":27},{"text":"                        .collect::<Vec<BLST_ERROR>>();","highlight_start":1,"highlight_end":55},{"text":"                    assert_eq!(","highlight_start":1,"highlight_end":32},{"text":"                        errs,","highlight_start":1,"highlight_end":30},{"text":"                        vec![BLST_ERROR::BLST_SUCCESS; num_pks_per_sig]","highlight_start":1,"highlight_end":72},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let sig_refs_i =","highlight_start":1,"highlight_end":37},{"text":"                        sigs_i.iter().map(|s| s).collect::<Vec<&Signature>>();","highlight_start":1,"highlight_end":79},{"text":"                    let agg_i =","highlight_start":1,"highlight_end":32},{"text":"                        match AggregateSignature::aggregate(&sig_refs_i, false)","highlight_start":1,"highlight_end":80},{"text":"                        {","highlight_start":1,"highlight_end":26},{"text":"                            Ok(agg_i) => agg_i,","highlight_start":1,"highlight_end":48},{"text":"                            Err(err) => panic!(\"aggregate failure: {:?}\", err),","highlight_start":1,"highlight_end":80},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Test current aggregate signature","highlight_start":1,"highlight_end":56},{"text":"                    sigs.push(agg_i.to_signature());","highlight_start":1,"highlight_end":53},{"text":"                    let mut result = sigs[i].fast_aggregate_verify(","highlight_start":1,"highlight_end":68},{"text":"                        false,","highlight_start":1,"highlight_end":31},{"text":"                        &msgs[i],","highlight_start":1,"highlight_end":34},{"text":"                        dst,","highlight_start":1,"highlight_end":29},{"text":"                        &pks_refs_i,","highlight_start":1,"highlight_end":37},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                    assert_eq!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":66},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // negative test","highlight_start":1,"highlight_end":37},{"text":"                    if i != 0 {","highlight_start":1,"highlight_end":32},{"text":"                        result = sigs[i - 1].fast_aggregate_verify(","highlight_start":1,"highlight_end":68},{"text":"                            false,","highlight_start":1,"highlight_end":35},{"text":"                            &msgs[i],","highlight_start":1,"highlight_end":38},{"text":"                            dst,","highlight_start":1,"highlight_end":33},{"text":"                            &pks_refs_i,","highlight_start":1,"highlight_end":41},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                        assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":70},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // aggregate public keys and push into vec","highlight_start":1,"highlight_end":63},{"text":"                    let agg_pk_i =","highlight_start":1,"highlight_end":35},{"text":"                        match AggregatePublicKey::aggregate(&pks_refs_i, false)","highlight_start":1,"highlight_end":80},{"text":"                        {","highlight_start":1,"highlight_end":26},{"text":"                            Ok(agg_pk_i) => agg_pk_i,","highlight_start":1,"highlight_end":54},{"text":"                            Err(err) => panic!(\"aggregate failure: {:?}\", err),","highlight_start":1,"highlight_end":80},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                    pks.push(agg_pk_i.to_public_key());","highlight_start":1,"highlight_end":56},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Test current aggregate signature with aggregated pks","highlight_start":1,"highlight_end":76},{"text":"                    result = sigs[i].fast_aggregate_verify_pre_aggregated(","highlight_start":1,"highlight_end":75},{"text":"                        false, &msgs[i], dst, &pks[i],","highlight_start":1,"highlight_end":55},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                    assert_eq!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":66},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // negative test","highlight_start":1,"highlight_end":37},{"text":"                    if i != 0 {","highlight_start":1,"highlight_end":32},{"text":"                        result = sigs[i - 1]","highlight_start":1,"highlight_end":45},{"text":"                            .fast_aggregate_verify_pre_aggregated(","highlight_start":1,"highlight_end":67},{"text":"                                false, &msgs[i], dst, &pks[i],","highlight_start":1,"highlight_end":63},{"text":"                            );","highlight_start":1,"highlight_end":31},{"text":"                        assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":70},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // create random values","highlight_start":1,"highlight_end":44},{"text":"                    let mut vals = [0u64; 4];","highlight_start":1,"highlight_end":46},{"text":"                    vals[0] = rng.next_u64();","highlight_start":1,"highlight_end":46},{"text":"                    while vals[0] == 0 {","highlight_start":1,"highlight_end":41},{"text":"                        // Reject zero as it is used for multiplication.","highlight_start":1,"highlight_end":73},{"text":"                        vals[0] = rng.next_u64();","highlight_start":1,"highlight_end":50},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    let mut rand_i =","highlight_start":1,"highlight_end":37},{"text":"                        std::mem::MaybeUninit::<blst_scalar>::uninit();","highlight_start":1,"highlight_end":72},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        blst_scalar_from_uint64(","highlight_start":1,"highlight_end":49},{"text":"                            rand_i.as_mut_ptr(),","highlight_start":1,"highlight_end":49},{"text":"                            vals.as_ptr(),","highlight_start":1,"highlight_end":43},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                        rands.push(rand_i.assume_init());","highlight_start":1,"highlight_end":58},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let msgs_refs: Vec<&[u8]> =","highlight_start":1,"highlight_end":44},{"text":"                    msgs.iter().map(|m| m.as_slice()).collect();","highlight_start":1,"highlight_end":65},{"text":"                let sig_refs =","highlight_start":1,"highlight_end":31},{"text":"                    sigs.iter().map(|s| s).collect::<Vec<&Signature>>();","highlight_start":1,"highlight_end":73},{"text":"                let pks_refs: Vec<&PublicKey> =","highlight_start":1,"highlight_end":48},{"text":"                    pks.iter().map(|pk| pk).collect();","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let msgs_rev: Vec<&[u8]> =","highlight_start":1,"highlight_end":43},{"text":"                    msgs.iter().rev().map(|m| m.as_slice()).collect();","highlight_start":1,"highlight_end":71},{"text":"                let sig_rev =","highlight_start":1,"highlight_end":30},{"text":"                    sigs.iter().rev().map(|s| s).collect::<Vec<&Signature>>();","highlight_start":1,"highlight_end":79},{"text":"                let pks_rev: Vec<&PublicKey> =","highlight_start":1,"highlight_end":47},{"text":"                    pks.iter().rev().map(|pk| pk).collect();","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut result =","highlight_start":1,"highlight_end":33},{"text":"                    Signature::verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":69},{"text":"                        &msgs_refs, dst, &pks_refs, false, &sig_refs, true,","highlight_start":1,"highlight_end":76},{"text":"                        &rands, 64,","highlight_start":1,"highlight_end":36},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                assert_eq!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // negative tests (use reverse msgs, pks, and sigs)","highlight_start":1,"highlight_end":68},{"text":"                result = Signature::verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":74},{"text":"                    &msgs_rev, dst, &pks_refs, false, &sig_refs, true, &rands,","highlight_start":1,"highlight_end":79},{"text":"                    64,","highlight_start":1,"highlight_end":24},{"text":"                );","highlight_start":1,"highlight_end":19},{"text":"                assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                result = Signature::verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":74},{"text":"                    &msgs_refs, dst, &pks_rev, false, &sig_refs, true, &rands,","highlight_start":1,"highlight_end":79},{"text":"                    64,","highlight_start":1,"highlight_end":24},{"text":"                );","highlight_start":1,"highlight_end":19},{"text":"                assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                result = Signature::verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":74},{"text":"                    &msgs_refs, dst, &pks_refs, false, &sig_rev, true, &rands,","highlight_start":1,"highlight_end":79},{"text":"                    64,","highlight_start":1,"highlight_end":24},{"text":"                );","highlight_start":1,"highlight_end":19},{"text":"                assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[test]","highlight_start":1,"highlight_end":20},{"text":"            fn test_serialization() {","highlight_start":1,"highlight_end":38},{"text":"                let seed = [0u8; 32];","highlight_start":1,"highlight_end":38},{"text":"                let mut rng = ChaCha20Rng::from_seed(seed);","highlight_start":1,"highlight_end":60},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sk = gen_random_key(&mut rng);","highlight_start":1,"highlight_end":51},{"text":"                let sk2 = gen_random_key(&mut rng);","highlight_start":1,"highlight_end":52},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk = sk.sk_to_pk();","highlight_start":1,"highlight_end":40},{"text":"                let pk_comp = pk.compress();","highlight_start":1,"highlight_end":45},{"text":"                let pk_ser = pk.serialize();","highlight_start":1,"highlight_end":45},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_uncomp = PublicKey::uncompress(&pk_comp);","highlight_start":1,"highlight_end":65},{"text":"                assert_eq!(pk_uncomp.is_ok(), true);","highlight_start":1,"highlight_end":53},{"text":"                assert_eq!(pk_uncomp.unwrap(), pk);","highlight_start":1,"highlight_end":52},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_deser = PublicKey::deserialize(&pk_ser);","highlight_start":1,"highlight_end":64},{"text":"                assert_eq!(pk_deser.is_ok(), true);","highlight_start":1,"highlight_end":52},{"text":"                assert_eq!(pk_deser.unwrap(), pk);","highlight_start":1,"highlight_end":51},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk2 = sk2.sk_to_pk();","highlight_start":1,"highlight_end":42},{"text":"                let pk_comp2 = pk2.compress();","highlight_start":1,"highlight_end":47},{"text":"                let pk_ser2 = pk2.serialize();","highlight_start":1,"highlight_end":47},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_uncomp2 = PublicKey::uncompress(&pk_comp2);","highlight_start":1,"highlight_end":67},{"text":"                assert_eq!(pk_uncomp2.is_ok(), true);","highlight_start":1,"highlight_end":54},{"text":"                assert_eq!(pk_uncomp2.unwrap(), pk2);","highlight_start":1,"highlight_end":54},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_deser2 = PublicKey::deserialize(&pk_ser2);","highlight_start":1,"highlight_end":66},{"text":"                assert_eq!(pk_deser2.is_ok(), true);","highlight_start":1,"highlight_end":53},{"text":"                assert_eq!(pk_deser2.unwrap(), pk2);","highlight_start":1,"highlight_end":53},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                assert_ne!(pk, pk2);","highlight_start":1,"highlight_end":37},{"text":"                assert_ne!(pk_uncomp.unwrap(), pk2);","highlight_start":1,"highlight_end":53},{"text":"                assert_ne!(pk_deser.unwrap(), pk2);","highlight_start":1,"highlight_end":52},{"text":"                assert_ne!(pk_uncomp2.unwrap(), pk);","highlight_start":1,"highlight_end":53},{"text":"                assert_ne!(pk_deser2.unwrap(), pk);","highlight_start":1,"highlight_end":52},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"remove this `mut`","code":null,"level":"help","spans":[{"file_name":"/home/azureuser/blst/bindings/rust/src/lib.rs","byte_start":31357,"byte_end":31361,"line_start":935,"line_end":935,"column_start":21,"column_end":25,"is_primary":true,"text":[{"text":"                let mut acc = rx.recv().unwrap();","highlight_start":21,"highlight_end":25}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"/home/azureuser/blst/bindings/rust/src/lib.rs","byte_start":51945,"byte_end":52960,"line_start":1472,"line_end":1510,"column_start":5,"column_end":7,"is_primary":false,"text":[{"text":"    sig_variant_impl!(","highlight_start":5,"highlight_end":23},{"text":"        \"MinPk\",","highlight_start":1,"highlight_end":17},{"text":"        blst_p1,","highlight_start":1,"highlight_end":17},{"text":"        blst_p1_affine,","highlight_start":1,"highlight_end":24},{"text":"        blst_p2,","highlight_start":1,"highlight_end":17},{"text":"        blst_p2_affine,","highlight_start":1,"highlight_end":24},{"text":"        blst_sk_to_pk2_in_g1,","highlight_start":1,"highlight_end":30},{"text":"        true,","highlight_start":1,"highlight_end":14},{"text":"        blst_hash_to_g2,","highlight_start":1,"highlight_end":25},{"text":"        blst_sign_pk2_in_g1,","highlight_start":1,"highlight_end":29},{"text":"        blst_p1_affine_is_equal,","highlight_start":1,"highlight_end":33},{"text":"        blst_p2_affine_is_equal,","highlight_start":1,"highlight_end":33},{"text":"        blst_core_verify_pk_in_g1,","highlight_start":1,"highlight_end":35},{"text":"        blst_p1_affine_in_g1,","highlight_start":1,"highlight_end":30},{"text":"        blst_p1_to_affine,","highlight_start":1,"highlight_end":27},{"text":"        blst_p1_from_affine,","highlight_start":1,"highlight_end":29},{"text":"        blst_p1_affine_serialize,","highlight_start":1,"highlight_end":34},{"text":"        blst_p1_affine_compress,","highlight_start":1,"highlight_end":33},{"text":"        blst_p1_deserialize,","highlight_start":1,"highlight_end":29},{"text":"        blst_p1_uncompress,","highlight_start":1,"highlight_end":28},{"text":"        48,","highlight_start":1,"highlight_end":12},{"text":"        96,","highlight_start":1,"highlight_end":12},{"text":"        blst_p2_affine_in_g2,","highlight_start":1,"highlight_end":30},{"text":"        blst_p2_to_affine,","highlight_start":1,"highlight_end":27},{"text":"        blst_p2_from_affine,","highlight_start":1,"highlight_end":29},{"text":"        blst_p2_affine_serialize,","highlight_start":1,"highlight_end":34},{"text":"        blst_p2_affine_compress,","highlight_start":1,"highlight_end":33},{"text":"        blst_p2_deserialize,","highlight_start":1,"highlight_end":29},{"text":"        blst_p2_uncompress,","highlight_start":1,"highlight_end":28},{"text":"        96,","highlight_start":1,"highlight_end":12},{"text":"        192,","highlight_start":1,"highlight_end":13},{"text":"        blst_p1_add_or_double,","highlight_start":1,"highlight_end":31},{"text":"        blst_p1_add_or_double_affine,","highlight_start":1,"highlight_end":38},{"text":"        blst_p2_add_or_double,","highlight_start":1,"highlight_end":31},{"text":"        blst_p2_add_or_double_affine,","highlight_start":1,"highlight_end":38},{"text":"        blst_p1_affine_is_inf,","highlight_start":1,"highlight_end":31},{"text":"        blst_p2_affine_is_inf,","highlight_start":1,"highlight_end":31},{"text":"        blst_p2_in_g2,","highlight_start":1,"highlight_end":23},{"text":"    );","highlight_start":1,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"sig_variant_impl!","def_site_span":{"file_name":"/home/azureuser/blst/bindings/rust/src/lib.rs","byte_start":7790,"byte_end":51903,"line_start":283,"line_end":1467,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! sig_variant_impl {","highlight_start":1,"highlight_end":32},{"text":"    (","highlight_start":1,"highlight_end":6},{"text":"        $name:expr,","highlight_start":1,"highlight_end":20},{"text":"        $pk:ty,","highlight_start":1,"highlight_end":16},{"text":"        $pk_aff:ty,","highlight_start":1,"highlight_end":20},{"text":"        $sig:ty,","highlight_start":1,"highlight_end":17},{"text":"        $sig_aff:ty,","highlight_start":1,"highlight_end":21},{"text":"        $sk_to_pk:ident,","highlight_start":1,"highlight_end":25},{"text":"        $hash_or_encode:expr,","highlight_start":1,"highlight_end":30},{"text":"        $hash_or_encode_to:ident,","highlight_start":1,"highlight_end":34},{"text":"        $sign:ident,","highlight_start":1,"highlight_end":21},{"text":"        $pk_eq:ident,","highlight_start":1,"highlight_end":22},{"text":"        $sig_eq:ident,","highlight_start":1,"highlight_end":23},{"text":"        $verify:ident,","highlight_start":1,"highlight_end":23},{"text":"        $pk_in_group:ident,","highlight_start":1,"highlight_end":28},{"text":"        $pk_to_aff:ident,","highlight_start":1,"highlight_end":26},{"text":"        $pk_from_aff:ident,","highlight_start":1,"highlight_end":28},{"text":"        $pk_ser:ident,","highlight_start":1,"highlight_end":23},{"text":"        $pk_comp:ident,","highlight_start":1,"highlight_end":24},{"text":"        $pk_deser:ident,","highlight_start":1,"highlight_end":25},{"text":"        $pk_uncomp:ident,","highlight_start":1,"highlight_end":26},{"text":"        $pk_comp_size:expr,","highlight_start":1,"highlight_end":28},{"text":"        $pk_ser_size:expr,","highlight_start":1,"highlight_end":27},{"text":"        $sig_in_group:ident,","highlight_start":1,"highlight_end":29},{"text":"        $sig_to_aff:ident,","highlight_start":1,"highlight_end":27},{"text":"        $sig_from_aff:ident,","highlight_start":1,"highlight_end":29},{"text":"        $sig_ser:ident,","highlight_start":1,"highlight_end":24},{"text":"        $sig_comp:ident,","highlight_start":1,"highlight_end":25},{"text":"        $sig_deser:ident,","highlight_start":1,"highlight_end":26},{"text":"        $sig_uncomp:ident,","highlight_start":1,"highlight_end":27},{"text":"        $sig_comp_size:expr,","highlight_start":1,"highlight_end":29},{"text":"        $sig_ser_size:expr,","highlight_start":1,"highlight_end":28},{"text":"        $pk_add_or_dbl:ident,","highlight_start":1,"highlight_end":30},{"text":"        $pk_add_or_dbl_aff:ident,","highlight_start":1,"highlight_end":34},{"text":"        $sig_add_or_dbl:ident,","highlight_start":1,"highlight_end":31},{"text":"        $sig_add_or_dbl_aff:ident,","highlight_start":1,"highlight_end":35},{"text":"        $pk_is_inf:ident,","highlight_start":1,"highlight_end":26},{"text":"        $sig_is_inf:ident,","highlight_start":1,"highlight_end":27},{"text":"        $sig_aggr_in_group:ident,","highlight_start":1,"highlight_end":34},{"text":"    ) => {","highlight_start":1,"highlight_end":11},{"text":"        /// Secret Key","highlight_start":1,"highlight_end":23},{"text":"        #[derive(Default, Debug, Clone, Zeroize)]","highlight_start":1,"highlight_end":50},{"text":"        #[zeroize(drop)]","highlight_start":1,"highlight_end":25},{"text":"        pub struct SecretKey {","highlight_start":1,"highlight_end":31},{"text":"            value: blst_scalar,","highlight_start":1,"highlight_end":32},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl SecretKey {","highlight_start":1,"highlight_end":25},{"text":"            /// Deterministically generate a secret key from key material","highlight_start":1,"highlight_end":74},{"text":"            pub fn key_gen(","highlight_start":1,"highlight_end":28},{"text":"                ikm: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                key_info: &[u8],","highlight_start":1,"highlight_end":33},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                if ikm.len() < 32 {","highlight_start":1,"highlight_end":36},{"text":"                    return Err(BLST_ERROR::BLST_BAD_ENCODING);","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut sk = SecretKey::default();","highlight_start":1,"highlight_end":51},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    blst_keygen(","highlight_start":1,"highlight_end":33},{"text":"                        &mut sk.value,","highlight_start":1,"highlight_end":39},{"text":"                        ikm.as_ptr(),","highlight_start":1,"highlight_end":38},{"text":"                        ikm.len(),","highlight_start":1,"highlight_end":35},{"text":"                        key_info.as_ptr(),","highlight_start":1,"highlight_end":43},{"text":"                        key_info.len(),","highlight_start":1,"highlight_end":40},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(sk)","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // sk_to_pk","highlight_start":1,"highlight_end":24},{"text":"            pub fn sk_to_pk(&self) -> PublicKey {","highlight_start":1,"highlight_end":50},{"text":"                // TODO - would the user like the serialized/compressed pk as well?","highlight_start":1,"highlight_end":84},{"text":"                let mut pk_aff = PublicKey::default();","highlight_start":1,"highlight_end":55},{"text":"                //let mut pk_ser = [0u8; $pk_ser_size];","highlight_start":1,"highlight_end":56},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sk_to_pk(","highlight_start":1,"highlight_end":31},{"text":"                        //pk_ser.as_mut_ptr(),","highlight_start":1,"highlight_end":47},{"text":"                        ptr::null_mut(),","highlight_start":1,"highlight_end":41},{"text":"                        &mut pk_aff.point,","highlight_start":1,"highlight_end":43},{"text":"                        &self.value,","highlight_start":1,"highlight_end":37},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                pk_aff","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Sign","highlight_start":1,"highlight_end":20},{"text":"            pub fn sign(","highlight_start":1,"highlight_end":25},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                msg: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                aug: &[u8],","highlight_start":1,"highlight_end":28},{"text":"            ) -> Signature {","highlight_start":1,"highlight_end":29},{"text":"                // TODO - would the user like the serialized/compressed sig as well?","highlight_start":1,"highlight_end":85},{"text":"                let mut q = <$sig>::default();","highlight_start":1,"highlight_end":47},{"text":"                let mut sig_aff = <$sig_aff>::default();","highlight_start":1,"highlight_end":57},{"text":"                //let mut sig_ser = [0u8; $sig_ser_size];","highlight_start":1,"highlight_end":58},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $hash_or_encode_to(","highlight_start":1,"highlight_end":40},{"text":"                        &mut q,","highlight_start":1,"highlight_end":32},{"text":"                        msg.as_ptr(),","highlight_start":1,"highlight_end":38},{"text":"                        msg.len(),","highlight_start":1,"highlight_end":35},{"text":"                        dst.as_ptr(),","highlight_start":1,"highlight_end":38},{"text":"                        dst.len(),","highlight_start":1,"highlight_end":35},{"text":"                        aug.as_ptr(),","highlight_start":1,"highlight_end":38},{"text":"                        aug.len(),","highlight_start":1,"highlight_end":35},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                    $sign(ptr::null_mut(), &mut sig_aff, &q, &self.value);","highlight_start":1,"highlight_end":75},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Signature { point: sig_aff }","highlight_start":1,"highlight_end":45},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // TODO - formally speaking application is entitled to have","highlight_start":1,"highlight_end":72},{"text":"            // ultimate control over secret key storage, which means that","highlight_start":1,"highlight_end":74},{"text":"            // corresponding serialization/deserialization subroutines","highlight_start":1,"highlight_end":71},{"text":"            // should accept reference to where to store the result, as","highlight_start":1,"highlight_end":72},{"text":"            // opposite to returning one.","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // serialize","highlight_start":1,"highlight_end":25},{"text":"            pub fn serialize(&self) -> [u8; 32] {","highlight_start":1,"highlight_end":50},{"text":"                let mut sk_out = [0; 32];","highlight_start":1,"highlight_end":42},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    blst_bendian_from_scalar(sk_out.as_mut_ptr(), &self.value);","highlight_start":1,"highlight_end":80},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                sk_out","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // deserialize","highlight_start":1,"highlight_end":27},{"text":"            pub fn deserialize(sk_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":75},{"text":"                let mut sk = blst_scalar::default();","highlight_start":1,"highlight_end":53},{"text":"                if sk_in.len() != 32 {","highlight_start":1,"highlight_end":39},{"text":"                    return Err(BLST_ERROR::BLST_BAD_ENCODING);","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    blst_scalar_from_bendian(&mut sk, sk_in.as_ptr());","highlight_start":1,"highlight_end":71},{"text":"                    if !blst_sk_check(&sk) {","highlight_start":1,"highlight_end":45},{"text":"                        return Err(BLST_ERROR::BLST_BAD_ENCODING);","highlight_start":1,"highlight_end":67},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(Self { value: sk })","highlight_start":1,"highlight_end":39},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_bytes(&self) -> [u8; 32] {","highlight_start":1,"highlight_end":49},{"text":"                SecretKey::serialize(&self)","highlight_start":1,"highlight_end":44},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_bytes(sk_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":74},{"text":"                SecretKey::deserialize(sk_in)","highlight_start":1,"highlight_end":46},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[derive(Default, Debug, Clone, Copy)]","highlight_start":1,"highlight_end":47},{"text":"        pub struct PublicKey {","highlight_start":1,"highlight_end":31},{"text":"            point: $pk_aff,","highlight_start":1,"highlight_end":28},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl PublicKey {","highlight_start":1,"highlight_end":25},{"text":"            // Core operations","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // key_validate","highlight_start":1,"highlight_end":28},{"text":"            pub fn validate(&self) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":63},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    if $pk_is_inf(&self.point) {","highlight_start":1,"highlight_end":49},{"text":"                        return Err(BLST_ERROR::BLST_PK_IS_INFINITY);","highlight_start":1,"highlight_end":69},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    if !$pk_in_group(&self.point) {","highlight_start":1,"highlight_end":52},{"text":"                        return Err(BLST_ERROR::BLST_POINT_NOT_IN_GROUP);","highlight_start":1,"highlight_end":73},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn key_validate(key: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":74},{"text":"                let pk = PublicKey::from_bytes(key)?;","highlight_start":1,"highlight_end":54},{"text":"                pk.validate()?;","highlight_start":1,"highlight_end":32},{"text":"                Ok(pk)","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_aggregate(agg_pk: &AggregatePublicKey) -> Self {","highlight_start":1,"highlight_end":73},{"text":"                let mut pk_aff = <$pk_aff>::default();","highlight_start":1,"highlight_end":55},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_to_aff(&mut pk_aff, &agg_pk.point);","highlight_start":1,"highlight_end":60},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Self { point: pk_aff }","highlight_start":1,"highlight_end":39},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Serdes","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn compress(&self) -> [u8; $pk_comp_size] {","highlight_start":1,"highlight_end":60},{"text":"                let mut pk_comp = [0u8; $pk_comp_size];","highlight_start":1,"highlight_end":56},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_comp(pk_comp.as_mut_ptr(), &self.point);","highlight_start":1,"highlight_end":65},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                pk_comp","highlight_start":1,"highlight_end":24},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn serialize(&self) -> [u8; $pk_ser_size] {","highlight_start":1,"highlight_end":60},{"text":"                let mut pk_out = [0u8; $pk_ser_size];","highlight_start":1,"highlight_end":54},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_ser(pk_out.as_mut_ptr(), &self.point);","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                pk_out","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn uncompress(pk_comp: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":76},{"text":"                if pk_comp.len() == $pk_comp_size && (pk_comp[0] & 0x80) != 0 {","highlight_start":1,"highlight_end":80},{"text":"                    let mut pk = <$pk_aff>::default();","highlight_start":1,"highlight_end":55},{"text":"                    let err = unsafe { $pk_uncomp(&mut pk, pk_comp.as_ptr()) };","highlight_start":1,"highlight_end":80},{"text":"                    if err != BLST_ERROR::BLST_SUCCESS {","highlight_start":1,"highlight_end":57},{"text":"                        return Err(err);","highlight_start":1,"highlight_end":41},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(Self { point: pk })","highlight_start":1,"highlight_end":43},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Err(BLST_ERROR::BLST_BAD_ENCODING)","highlight_start":1,"highlight_end":55},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn deserialize(pk_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":75},{"text":"                if (pk_in.len() == $pk_ser_size && (pk_in[0] & 0x80) == 0)","highlight_start":1,"highlight_end":75},{"text":"                    || (pk_in.len() == $pk_comp_size && (pk_in[0] & 0x80) != 0)","highlight_start":1,"highlight_end":80},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    let mut pk = <$pk_aff>::default();","highlight_start":1,"highlight_end":55},{"text":"                    let err = unsafe { $pk_deser(&mut pk, pk_in.as_ptr()) };","highlight_start":1,"highlight_end":77},{"text":"                    if err != BLST_ERROR::BLST_SUCCESS {","highlight_start":1,"highlight_end":57},{"text":"                        return Err(err);","highlight_start":1,"highlight_end":41},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(Self { point: pk })","highlight_start":1,"highlight_end":43},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Err(BLST_ERROR::BLST_BAD_ENCODING)","highlight_start":1,"highlight_end":55},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_bytes(pk_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":74},{"text":"                PublicKey::deserialize(pk_in)","highlight_start":1,"highlight_end":46},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_bytes(&self) -> [u8; $pk_comp_size] {","highlight_start":1,"highlight_end":60},{"text":"                self.compress()","highlight_start":1,"highlight_end":32},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Trait for equality comparisons which are equivalence relations.","highlight_start":1,"highlight_end":75},{"text":"        //","highlight_start":1,"highlight_end":11},{"text":"        // This means, that in addition to a == b and a != b being strict","highlight_start":1,"highlight_end":74},{"text":"        // inverses, the equality must be reflexive, symmetric and transitive.","highlight_start":1,"highlight_end":79},{"text":"        impl Eq for PublicKey {}","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl PartialEq for PublicKey {","highlight_start":1,"highlight_end":39},{"text":"            fn eq(&self, other: &Self) -> bool {","highlight_start":1,"highlight_end":49},{"text":"                unsafe { $pk_eq(&self.point, &other.point) }","highlight_start":1,"highlight_end":61},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[derive(Debug, Clone, Copy)]","highlight_start":1,"highlight_end":38},{"text":"        pub struct AggregatePublicKey {","highlight_start":1,"highlight_end":40},{"text":"            point: $pk,","highlight_start":1,"highlight_end":24},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl AggregatePublicKey {","highlight_start":1,"highlight_end":34},{"text":"            pub fn from_public_key(pk: &PublicKey) -> Self {","highlight_start":1,"highlight_end":61},{"text":"                let mut agg_pk = <$pk>::default();","highlight_start":1,"highlight_end":51},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_from_aff(&mut agg_pk, &pk.point);","highlight_start":1,"highlight_end":58},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Self { point: agg_pk }","highlight_start":1,"highlight_end":39},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_public_key(&self) -> PublicKey {","highlight_start":1,"highlight_end":55},{"text":"                let mut pk = <$pk_aff>::default();","highlight_start":1,"highlight_end":51},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_to_aff(&mut pk, &self.point);","highlight_start":1,"highlight_end":54},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                PublicKey { point: pk }","highlight_start":1,"highlight_end":40},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Aggregate","highlight_start":1,"highlight_end":25},{"text":"            pub fn aggregate(","highlight_start":1,"highlight_end":30},{"text":"                pks: &[&PublicKey],","highlight_start":1,"highlight_end":36},{"text":"                pks_validate: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                if pks.len() == 0 {","highlight_start":1,"highlight_end":36},{"text":"                    return Err(BLST_ERROR::BLST_AGGR_TYPE_MISMATCH);","highlight_start":1,"highlight_end":69},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if pks_validate {","highlight_start":1,"highlight_end":34},{"text":"                    pks[0].validate()?;","highlight_start":1,"highlight_end":40},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut agg_pk = AggregatePublicKey::from_public_key(pks[0]);","highlight_start":1,"highlight_end":78},{"text":"                for s in pks.iter().skip(1) {","highlight_start":1,"highlight_end":46},{"text":"                    if pks_validate {","highlight_start":1,"highlight_end":38},{"text":"                        s.validate()?;","highlight_start":1,"highlight_end":39},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        $pk_add_or_dbl_aff(","highlight_start":1,"highlight_end":44},{"text":"                            &mut agg_pk.point,","highlight_start":1,"highlight_end":47},{"text":"                            &agg_pk.point,","highlight_start":1,"highlight_end":43},{"text":"                            &s.point,","highlight_start":1,"highlight_end":38},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(agg_pk)","highlight_start":1,"highlight_end":27},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn aggregate_serialized(","highlight_start":1,"highlight_end":41},{"text":"                pks: &[&[u8]],","highlight_start":1,"highlight_end":31},{"text":"                pks_validate: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                // TODO - threading","highlight_start":1,"highlight_end":36},{"text":"                if pks.len() == 0 {","highlight_start":1,"highlight_end":36},{"text":"                    return Err(BLST_ERROR::BLST_AGGR_TYPE_MISMATCH);","highlight_start":1,"highlight_end":69},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut pk = if pks_validate {","highlight_start":1,"highlight_end":47},{"text":"                    PublicKey::key_validate(pks[0])?","highlight_start":1,"highlight_end":53},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    PublicKey::from_bytes(pks[0])?","highlight_start":1,"highlight_end":51},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut agg_pk = AggregatePublicKey::from_public_key(&pk);","highlight_start":1,"highlight_end":75},{"text":"                for s in pks.iter().skip(1) {","highlight_start":1,"highlight_end":46},{"text":"                    pk = if pks_validate {","highlight_start":1,"highlight_end":43},{"text":"                        PublicKey::key_validate(s)?","highlight_start":1,"highlight_end":52},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        PublicKey::from_bytes(s)?","highlight_start":1,"highlight_end":50},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        $pk_add_or_dbl_aff(","highlight_start":1,"highlight_end":44},{"text":"                            &mut agg_pk.point,","highlight_start":1,"highlight_end":47},{"text":"                            &agg_pk.point,","highlight_start":1,"highlight_end":43},{"text":"                            &pk.point,","highlight_start":1,"highlight_end":39},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(agg_pk)","highlight_start":1,"highlight_end":27},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn add_aggregate(&mut self, agg_pk: &AggregatePublicKey) {","highlight_start":1,"highlight_end":75},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_add_or_dbl(&mut self.point, &self.point, &agg_pk.point);","highlight_start":1,"highlight_end":81},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn add_public_key(","highlight_start":1,"highlight_end":35},{"text":"                &mut self,","highlight_start":1,"highlight_end":27},{"text":"                pk: &PublicKey,","highlight_start":1,"highlight_end":32},{"text":"                pk_validate: bool,","highlight_start":1,"highlight_end":35},{"text":"            ) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":42},{"text":"                if pk_validate {","highlight_start":1,"highlight_end":33},{"text":"                    pk.validate()?;","highlight_start":1,"highlight_end":36},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_add_or_dbl_aff(&mut self.point, &self.point, &pk.point);","highlight_start":1,"highlight_end":81},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[derive(Debug, Clone, Copy)]","highlight_start":1,"highlight_end":38},{"text":"        pub struct Signature {","highlight_start":1,"highlight_end":31},{"text":"            point: $sig_aff,","highlight_start":1,"highlight_end":29},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl Signature {","highlight_start":1,"highlight_end":25},{"text":"            // sig_infcheck, check for infinity, is a way to avoid going","highlight_start":1,"highlight_end":73},{"text":"            // into resource-consuming verification. Passing 'false' is","highlight_start":1,"highlight_end":72},{"text":"            // always cryptographically safe, but application might want","highlight_start":1,"highlight_end":73},{"text":"            // to guard against obviously bogus individual[!] signatures.","highlight_start":1,"highlight_end":74},{"text":"            pub fn validate(","highlight_start":1,"highlight_end":29},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_infcheck: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":42},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    if sig_infcheck && $sig_is_inf(&self.point) {","highlight_start":1,"highlight_end":66},{"text":"                        return Err(BLST_ERROR::BLST_PK_IS_INFINITY);","highlight_start":1,"highlight_end":69},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    if !$sig_in_group(&self.point) {","highlight_start":1,"highlight_end":53},{"text":"                        return Err(BLST_ERROR::BLST_POINT_NOT_IN_GROUP);","highlight_start":1,"highlight_end":73},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn sig_validate(","highlight_start":1,"highlight_end":33},{"text":"                sig: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                sig_infcheck: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                let sig = Signature::from_bytes(sig)?;","highlight_start":1,"highlight_end":55},{"text":"                sig.validate(sig_infcheck)?;","highlight_start":1,"highlight_end":45},{"text":"                Ok(sig)","highlight_start":1,"highlight_end":24},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn verify(","highlight_start":1,"highlight_end":27},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"                msg: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                aug: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pk: &PublicKey,","highlight_start":1,"highlight_end":32},{"text":"                pk_validate: bool,","highlight_start":1,"highlight_end":35},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                let aug_msg = [aug, msg].concat();","highlight_start":1,"highlight_end":51},{"text":"                self.aggregate_verify(","highlight_start":1,"highlight_end":39},{"text":"                    sig_groupcheck,","highlight_start":1,"highlight_end":36},{"text":"                    &[aug_msg.as_slice()],","highlight_start":1,"highlight_end":43},{"text":"                    dst,","highlight_start":1,"highlight_end":25},{"text":"                    &[pk],","highlight_start":1,"highlight_end":27},{"text":"                    pk_validate,","highlight_start":1,"highlight_end":33},{"text":"                )","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn aggregate_verify(","highlight_start":1,"highlight_end":37},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"                msgs: &[&[u8]],","highlight_start":1,"highlight_end":32},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pks: &[&PublicKey],","highlight_start":1,"highlight_end":36},{"text":"                pks_validate: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                let n_elems = pks.len();","highlight_start":1,"highlight_end":41},{"text":"                if n_elems == 0 || msgs.len() != n_elems {","highlight_start":1,"highlight_end":59},{"text":"                    return BLST_ERROR::BLST_VERIFY_FAIL;","highlight_start":1,"highlight_end":57},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // TODO - check msg uniqueness?","highlight_start":1,"highlight_end":48},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // let pool = da_pool();","highlight_start":1,"highlight_end":41},{"text":"                let (tx, rx) = channel();","highlight_start":1,"highlight_end":42},{"text":"                let counter = Arc::new(AtomicUsize::new(0));","highlight_start":1,"highlight_end":61},{"text":"                let valid = Arc::new(AtomicBool::new(true));","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Bypass 'lifetime limitations by brute force. It works,","highlight_start":1,"highlight_end":74},{"text":"                // because we explicitly join the threads...","highlight_start":1,"highlight_end":61},{"text":"                let raw_pks = unsafe {","highlight_start":1,"highlight_end":39},{"text":"                    transmute::<*const &PublicKey, usize>(pks.as_ptr())","highlight_start":1,"highlight_end":72},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let raw_msgs =","highlight_start":1,"highlight_end":31},{"text":"                    unsafe { transmute::<*const &[u8], usize>(msgs.as_ptr()) };","highlight_start":1,"highlight_end":80},{"text":"                let dst =","highlight_start":1,"highlight_end":26},{"text":"                    unsafe { slice::from_raw_parts(dst.as_ptr(), dst.len()) };","highlight_start":1,"highlight_end":79},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // let n_workers = std::cmp::min(pool.max_count(), n_elems);","highlight_start":1,"highlight_end":77},{"text":"                // for _ in 0..n_workers {","highlight_start":1,"highlight_end":43},{"text":"                    let tx = tx.clone();","highlight_start":1,"highlight_end":41},{"text":"                    let counter = counter.clone();","highlight_start":1,"highlight_end":51},{"text":"                    let valid = valid.clone();","highlight_start":1,"highlight_end":47},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // pool.execute(move || {","highlight_start":1,"highlight_end":46},{"text":"                        let mut pairing = Pairing::new($hash_or_encode, dst);","highlight_start":1,"highlight_end":78},{"text":"                        // reconstruct input slices...","highlight_start":1,"highlight_end":55},{"text":"                        let msgs = unsafe {","highlight_start":1,"highlight_end":44},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &[u8]>(raw_msgs),","highlight_start":1,"highlight_end":76},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                        let pks = unsafe {","highlight_start":1,"highlight_end":43},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &PublicKey>(raw_pks),","highlight_start":1,"highlight_end":80},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        while valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":62},{"text":"                            let work = counter.fetch_add(1, Ordering::Relaxed);","highlight_start":1,"highlight_end":80},{"text":"                            if work >= n_elems {","highlight_start":1,"highlight_end":49},{"text":"                                break;","highlight_start":1,"highlight_end":39},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                            if pairing.aggregate(","highlight_start":1,"highlight_end":50},{"text":"                                &pks[work].point,","highlight_start":1,"highlight_end":50},{"text":"                                pks_validate,","highlight_start":1,"highlight_end":46},{"text":"                                &unsafe { ptr::null::<$sig_aff>().as_ref() },","highlight_start":1,"highlight_end":78},{"text":"                                false,","highlight_start":1,"highlight_end":39},{"text":"                                &msgs[work],","highlight_start":1,"highlight_end":45},{"text":"                                &[],","highlight_start":1,"highlight_end":37},{"text":"                            ) != BLST_ERROR::BLST_SUCCESS","highlight_start":1,"highlight_end":58},{"text":"                            {","highlight_start":1,"highlight_end":30},{"text":"                                valid.store(false, Ordering::Relaxed);","highlight_start":1,"highlight_end":71},{"text":"                                break;","highlight_start":1,"highlight_end":39},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        if valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":59},{"text":"                            pairing.commit();","highlight_start":1,"highlight_end":46},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        tx.send(pairing).expect(\"disaster\");","highlight_start":1,"highlight_end":61},{"text":"                    // });","highlight_start":1,"highlight_end":27},{"text":"                // }","highlight_start":1,"highlight_end":21},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                if sig_groupcheck && valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":69},{"text":"                    match self.validate(false) {","highlight_start":1,"highlight_end":49},{"text":"                        Err(_err) => valid.store(false, Ordering::Relaxed),","highlight_start":1,"highlight_end":76},{"text":"                        _ => (),","highlight_start":1,"highlight_end":33},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut gtsig = blst_fp12::default();","highlight_start":1,"highlight_end":54},{"text":"                if valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":51},{"text":"                    Pairing::aggregated(&mut gtsig, &self.point);","highlight_start":1,"highlight_end":66},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut acc = rx.recv().unwrap();","highlight_start":1,"highlight_end":50},{"text":"                // for _ in 1..n_workers {","highlight_start":1,"highlight_end":43},{"text":"                    // acc.merge(&rx.recv().unwrap());","highlight_start":1,"highlight_end":55},{"text":"                // }","highlight_start":1,"highlight_end":21},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                if valid.load(Ordering::Relaxed)","highlight_start":1,"highlight_end":49},{"text":"                    && acc.finalverify(Some(&gtsig))","highlight_start":1,"highlight_end":53},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    BLST_ERROR::BLST_SUCCESS","highlight_start":1,"highlight_end":45},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    BLST_ERROR::BLST_VERIFY_FAIL","highlight_start":1,"highlight_end":49},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // pks are assumed to be verified for proof of possession,","highlight_start":1,"highlight_end":71},{"text":"            // which implies that they are already group-checked","highlight_start":1,"highlight_end":65},{"text":"            pub fn fast_aggregate_verify(","highlight_start":1,"highlight_end":42},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"                msg: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pks: &[&PublicKey],","highlight_start":1,"highlight_end":36},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                let agg_pk = match AggregatePublicKey::aggregate(pks, false) {","highlight_start":1,"highlight_end":79},{"text":"                    Ok(agg_sig) => agg_sig,","highlight_start":1,"highlight_end":44},{"text":"                    Err(err) => return err,","highlight_start":1,"highlight_end":44},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let pk = agg_pk.to_public_key();","highlight_start":1,"highlight_end":49},{"text":"                self.aggregate_verify(","highlight_start":1,"highlight_end":39},{"text":"                    sig_groupcheck,","highlight_start":1,"highlight_end":36},{"text":"                    &[msg],","highlight_start":1,"highlight_end":28},{"text":"                    dst,","highlight_start":1,"highlight_end":25},{"text":"                    &[&pk],","highlight_start":1,"highlight_end":28},{"text":"                    false,","highlight_start":1,"highlight_end":27},{"text":"                )","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn fast_aggregate_verify_pre_aggregated(","highlight_start":1,"highlight_end":57},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"                msg: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pk: &PublicKey,","highlight_start":1,"highlight_end":32},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                self.aggregate_verify(sig_groupcheck, &[msg], dst, &[pk], false)","highlight_start":1,"highlight_end":81},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // https://ethresear.ch/t/fast-verification-of-multiple-bls-signatures/5407","highlight_start":1,"highlight_end":88},{"text":"            pub fn verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":57},{"text":"                msgs: &[&[u8]],","highlight_start":1,"highlight_end":32},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pks: &[&PublicKey],","highlight_start":1,"highlight_end":36},{"text":"                pks_validate: bool,","highlight_start":1,"highlight_end":36},{"text":"                sigs: &[&Signature],","highlight_start":1,"highlight_end":37},{"text":"                sigs_groupcheck: bool,","highlight_start":1,"highlight_end":39},{"text":"                rands: &[blst_scalar],","highlight_start":1,"highlight_end":39},{"text":"                rand_bits: usize,","highlight_start":1,"highlight_end":34},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                let n_elems = pks.len();","highlight_start":1,"highlight_end":41},{"text":"                if n_elems == 0","highlight_start":1,"highlight_end":32},{"text":"                    || msgs.len() != n_elems","highlight_start":1,"highlight_end":45},{"text":"                    || sigs.len() != n_elems","highlight_start":1,"highlight_end":45},{"text":"                    || rands.len() != n_elems","highlight_start":1,"highlight_end":46},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    return BLST_ERROR::BLST_VERIFY_FAIL;","highlight_start":1,"highlight_end":57},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // TODO - check msg uniqueness?","highlight_start":1,"highlight_end":48},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // let pool = da_pool();","highlight_start":1,"highlight_end":41},{"text":"                let (tx, rx) = channel();","highlight_start":1,"highlight_end":42},{"text":"                let counter = Arc::new(AtomicUsize::new(0));","highlight_start":1,"highlight_end":61},{"text":"                let valid = Arc::new(AtomicBool::new(true));","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Bypass 'lifetime limitations by brute force. It works,","highlight_start":1,"highlight_end":74},{"text":"                // because we explicitly join the threads...","highlight_start":1,"highlight_end":61},{"text":"                let raw_pks = unsafe {","highlight_start":1,"highlight_end":39},{"text":"                    transmute::<*const &PublicKey, usize>(pks.as_ptr())","highlight_start":1,"highlight_end":72},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let raw_sigs = unsafe {","highlight_start":1,"highlight_end":40},{"text":"                    transmute::<*const &Signature, usize>(sigs.as_ptr())","highlight_start":1,"highlight_end":73},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let raw_rands = unsafe {","highlight_start":1,"highlight_end":41},{"text":"                    transmute::<*const blst_scalar, usize>(rands.as_ptr())","highlight_start":1,"highlight_end":75},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let raw_msgs =","highlight_start":1,"highlight_end":31},{"text":"                    unsafe { transmute::<*const &[u8], usize>(msgs.as_ptr()) };","highlight_start":1,"highlight_end":80},{"text":"                let dst =","highlight_start":1,"highlight_end":26},{"text":"                    unsafe { slice::from_raw_parts(dst.as_ptr(), dst.len()) };","highlight_start":1,"highlight_end":79},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // let n_workers = std::cmp::min(pool.max_count(), n_elems);","highlight_start":1,"highlight_end":77},{"text":"                //for _ in 0..n_workers {","highlight_start":1,"highlight_end":42},{"text":"                    let tx = tx.clone();","highlight_start":1,"highlight_end":41},{"text":"                    let counter = counter.clone();","highlight_start":1,"highlight_end":51},{"text":"                    let valid = valid.clone();","highlight_start":1,"highlight_end":47},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // pool.execute(move || {","highlight_start":1,"highlight_end":46},{"text":"                        let mut pairing = Pairing::new($hash_or_encode, dst);","highlight_start":1,"highlight_end":78},{"text":"                        // reconstruct input slices...","highlight_start":1,"highlight_end":55},{"text":"                        let rands = unsafe {","highlight_start":1,"highlight_end":45},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const blst_scalar>(","highlight_start":1,"highlight_end":72},{"text":"                                    raw_rands,","highlight_start":1,"highlight_end":47},{"text":"                                ),","highlight_start":1,"highlight_end":35},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                        let msgs = unsafe {","highlight_start":1,"highlight_end":44},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &[u8]>(raw_msgs),","highlight_start":1,"highlight_end":76},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                        let sigs = unsafe {","highlight_start":1,"highlight_end":44},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &Signature>(raw_sigs),","highlight_start":1,"highlight_end":81},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                        let pks = unsafe {","highlight_start":1,"highlight_end":43},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &PublicKey>(raw_pks),","highlight_start":1,"highlight_end":80},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        // TODO - engage multi-point mul-n-add for larger","highlight_start":1,"highlight_end":74},{"text":"                        // amount of inputs...","highlight_start":1,"highlight_end":47},{"text":"                        while valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":62},{"text":"                            let work = counter.fetch_add(1, Ordering::Relaxed);","highlight_start":1,"highlight_end":80},{"text":"                            if work >= n_elems {","highlight_start":1,"highlight_end":49},{"text":"                                break;","highlight_start":1,"highlight_end":39},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            if pairing.mul_n_aggregate(","highlight_start":1,"highlight_end":56},{"text":"                                &pks[work].point,","highlight_start":1,"highlight_end":50},{"text":"                                pks_validate,","highlight_start":1,"highlight_end":46},{"text":"                                &sigs[work].point,","highlight_start":1,"highlight_end":51},{"text":"                                sigs_groupcheck,","highlight_start":1,"highlight_end":49},{"text":"                                &rands[work].b,","highlight_start":1,"highlight_end":48},{"text":"                                rand_bits,","highlight_start":1,"highlight_end":43},{"text":"                                msgs[work],","highlight_start":1,"highlight_end":44},{"text":"                                &[],","highlight_start":1,"highlight_end":37},{"text":"                            ) != BLST_ERROR::BLST_SUCCESS","highlight_start":1,"highlight_end":58},{"text":"                            {","highlight_start":1,"highlight_end":30},{"text":"                                valid.store(false, Ordering::Relaxed);","highlight_start":1,"highlight_end":71},{"text":"                                break;","highlight_start":1,"highlight_end":39},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        if valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":59},{"text":"                            pairing.commit();","highlight_start":1,"highlight_end":46},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        tx.send(pairing).expect(\"disaster\");","highlight_start":1,"highlight_end":61},{"text":"                    // });","highlight_start":1,"highlight_end":27},{"text":"                //}","highlight_start":1,"highlight_end":20},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut acc = rx.recv().unwrap();","highlight_start":1,"highlight_end":50},{"text":"                //for _ in 1..n_workers {","highlight_start":1,"highlight_end":42},{"text":"                    // acc.merge(&rx.recv().unwrap());","highlight_start":1,"highlight_end":55},{"text":"                //}","highlight_start":1,"highlight_end":20},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                if valid.load(Ordering::Relaxed) && acc.finalverify(None) {","highlight_start":1,"highlight_end":76},{"text":"                    BLST_ERROR::BLST_SUCCESS","highlight_start":1,"highlight_end":45},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    BLST_ERROR::BLST_VERIFY_FAIL","highlight_start":1,"highlight_end":49},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_aggregate(agg_sig: &AggregateSignature) -> Self {","highlight_start":1,"highlight_end":74},{"text":"                let mut sig_aff = <$sig_aff>::default();","highlight_start":1,"highlight_end":57},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_to_aff(&mut sig_aff, &agg_sig.point);","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Self { point: sig_aff }","highlight_start":1,"highlight_end":40},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn compress(&self) -> [u8; $sig_comp_size] {","highlight_start":1,"highlight_end":61},{"text":"                let mut sig_comp = [0; $sig_comp_size];","highlight_start":1,"highlight_end":56},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_comp(sig_comp.as_mut_ptr(), &self.point);","highlight_start":1,"highlight_end":67},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                sig_comp","highlight_start":1,"highlight_end":25},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn serialize(&self) -> [u8; $sig_ser_size] {","highlight_start":1,"highlight_end":61},{"text":"                let mut sig_out = [0; $sig_ser_size];","highlight_start":1,"highlight_end":54},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_ser(sig_out.as_mut_ptr(), &self.point);","highlight_start":1,"highlight_end":65},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                sig_out","highlight_start":1,"highlight_end":24},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn uncompress(sig_comp: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":77},{"text":"                if sig_comp.len() == $sig_comp_size && (sig_comp[0] & 0x80) != 0","highlight_start":1,"highlight_end":81},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    let mut sig = <$sig_aff>::default();","highlight_start":1,"highlight_end":57},{"text":"                    let err =","highlight_start":1,"highlight_end":30},{"text":"                        unsafe { $sig_uncomp(&mut sig, sig_comp.as_ptr()) };","highlight_start":1,"highlight_end":77},{"text":"                    if err != BLST_ERROR::BLST_SUCCESS {","highlight_start":1,"highlight_end":57},{"text":"                        return Err(err);","highlight_start":1,"highlight_end":41},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(Self { point: sig })","highlight_start":1,"highlight_end":44},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Err(BLST_ERROR::BLST_BAD_ENCODING)","highlight_start":1,"highlight_end":55},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn deserialize(sig_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":76},{"text":"                if (sig_in.len() == $sig_ser_size && (sig_in[0] & 0x80) == 0)","highlight_start":1,"highlight_end":78},{"text":"                    || (sig_in.len() == $sig_comp_size","highlight_start":1,"highlight_end":55},{"text":"                        && (sig_in[0] & 0x80) != 0)","highlight_start":1,"highlight_end":52},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    let mut sig = <$sig_aff>::default();","highlight_start":1,"highlight_end":57},{"text":"                    let err = unsafe { $sig_deser(&mut sig, sig_in.as_ptr()) };","highlight_start":1,"highlight_end":80},{"text":"                    if err != BLST_ERROR::BLST_SUCCESS {","highlight_start":1,"highlight_end":57},{"text":"                        return Err(err);","highlight_start":1,"highlight_end":41},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(Self { point: sig })","highlight_start":1,"highlight_end":44},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Err(BLST_ERROR::BLST_BAD_ENCODING)","highlight_start":1,"highlight_end":55},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_bytes(sig_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":75},{"text":"                Signature::deserialize(sig_in)","highlight_start":1,"highlight_end":47},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_bytes(&self) -> [u8; $sig_comp_size] {","highlight_start":1,"highlight_end":61},{"text":"                self.compress()","highlight_start":1,"highlight_end":32},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn subgroup_check(&self) -> bool {","highlight_start":1,"highlight_end":51},{"text":"                unsafe { $sig_in_group(&self.point) }","highlight_start":1,"highlight_end":54},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Trait for equality comparisons which are equivalence relations.","highlight_start":1,"highlight_end":75},{"text":"        //","highlight_start":1,"highlight_end":11},{"text":"        // This means, that in addition to a == b and a != b being strict","highlight_start":1,"highlight_end":74},{"text":"        // inverses, the equality must be reflexive, symmetric and transitive.","highlight_start":1,"highlight_end":79},{"text":"        impl Eq for Signature {}","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl PartialEq for Signature {","highlight_start":1,"highlight_end":39},{"text":"            fn eq(&self, other: &Self) -> bool {","highlight_start":1,"highlight_end":49},{"text":"                unsafe { $sig_eq(&self.point, &other.point) }","highlight_start":1,"highlight_end":62},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[derive(Debug, Clone, Copy)]","highlight_start":1,"highlight_end":38},{"text":"        pub struct AggregateSignature {","highlight_start":1,"highlight_end":40},{"text":"            point: $sig,","highlight_start":1,"highlight_end":25},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl AggregateSignature {","highlight_start":1,"highlight_end":34},{"text":"            pub fn validate(&self) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":63},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    if !$sig_aggr_in_group(&self.point) {","highlight_start":1,"highlight_end":58},{"text":"                        return Err(BLST_ERROR::BLST_POINT_NOT_IN_GROUP);","highlight_start":1,"highlight_end":73},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_signature(sig: &Signature) -> Self {","highlight_start":1,"highlight_end":61},{"text":"                let mut agg_sig = <$sig>::default();","highlight_start":1,"highlight_end":53},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_from_aff(&mut agg_sig, &sig.point);","highlight_start":1,"highlight_end":61},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Self { point: agg_sig }","highlight_start":1,"highlight_end":40},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_signature(&self) -> Signature {","highlight_start":1,"highlight_end":54},{"text":"                let mut sig = <$sig_aff>::default();","highlight_start":1,"highlight_end":53},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_to_aff(&mut sig, &self.point);","highlight_start":1,"highlight_end":56},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Signature { point: sig }","highlight_start":1,"highlight_end":41},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Aggregate","highlight_start":1,"highlight_end":25},{"text":"            pub fn aggregate(","highlight_start":1,"highlight_end":30},{"text":"                sigs: &[&Signature],","highlight_start":1,"highlight_end":37},{"text":"                sigs_groupcheck: bool,","highlight_start":1,"highlight_end":39},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                if sigs.len() == 0 {","highlight_start":1,"highlight_end":37},{"text":"                    return Err(BLST_ERROR::BLST_AGGR_TYPE_MISMATCH);","highlight_start":1,"highlight_end":69},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if sigs_groupcheck {","highlight_start":1,"highlight_end":37},{"text":"                    // We can't actually judge if input is individual or","highlight_start":1,"highlight_end":73},{"text":"                    // aggregated signature, so we can't enforce infinitiy","highlight_start":1,"highlight_end":75},{"text":"                    // check.","highlight_start":1,"highlight_end":30},{"text":"                    sigs[0].validate(false)?;","highlight_start":1,"highlight_end":46},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut agg_sig = AggregateSignature::from_signature(sigs[0]);","highlight_start":1,"highlight_end":79},{"text":"                for s in sigs.iter().skip(1) {","highlight_start":1,"highlight_end":47},{"text":"                    if sigs_groupcheck {","highlight_start":1,"highlight_end":41},{"text":"                        s.validate(false)?;","highlight_start":1,"highlight_end":44},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        $sig_add_or_dbl_aff(","highlight_start":1,"highlight_end":45},{"text":"                            &mut agg_sig.point,","highlight_start":1,"highlight_end":48},{"text":"                            &agg_sig.point,","highlight_start":1,"highlight_end":44},{"text":"                            &s.point,","highlight_start":1,"highlight_end":38},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(agg_sig)","highlight_start":1,"highlight_end":28},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn aggregate_serialized(","highlight_start":1,"highlight_end":41},{"text":"                sigs: &[&[u8]],","highlight_start":1,"highlight_end":32},{"text":"                sigs_groupcheck: bool,","highlight_start":1,"highlight_end":39},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                // TODO - threading","highlight_start":1,"highlight_end":36},{"text":"                if sigs.len() == 0 {","highlight_start":1,"highlight_end":37},{"text":"                    return Err(BLST_ERROR::BLST_AGGR_TYPE_MISMATCH);","highlight_start":1,"highlight_end":69},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut sig = if sigs_groupcheck {","highlight_start":1,"highlight_end":51},{"text":"                    Signature::sig_validate(sigs[0], false)?","highlight_start":1,"highlight_end":61},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Signature::from_bytes(sigs[0])?","highlight_start":1,"highlight_end":52},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut agg_sig = AggregateSignature::from_signature(&sig);","highlight_start":1,"highlight_end":76},{"text":"                for s in sigs.iter().skip(1) {","highlight_start":1,"highlight_end":47},{"text":"                    sig = if sigs_groupcheck {","highlight_start":1,"highlight_end":47},{"text":"                        Signature::sig_validate(s, false)?","highlight_start":1,"highlight_end":59},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        Signature::from_bytes(s)?","highlight_start":1,"highlight_end":50},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        $sig_add_or_dbl_aff(","highlight_start":1,"highlight_end":45},{"text":"                            &mut agg_sig.point,","highlight_start":1,"highlight_end":48},{"text":"                            &agg_sig.point,","highlight_start":1,"highlight_end":44},{"text":"                            &sig.point,","highlight_start":1,"highlight_end":40},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(agg_sig)","highlight_start":1,"highlight_end":28},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn add_aggregate(&mut self, agg_sig: &AggregateSignature) {","highlight_start":1,"highlight_end":76},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_add_or_dbl(","highlight_start":1,"highlight_end":37},{"text":"                        &mut self.point,","highlight_start":1,"highlight_end":41},{"text":"                        &self.point,","highlight_start":1,"highlight_end":37},{"text":"                        &agg_sig.point,","highlight_start":1,"highlight_end":40},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn add_signature(","highlight_start":1,"highlight_end":34},{"text":"                &mut self,","highlight_start":1,"highlight_end":27},{"text":"                sig: &Signature,","highlight_start":1,"highlight_end":33},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"            ) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":42},{"text":"                if sig_groupcheck {","highlight_start":1,"highlight_end":36},{"text":"                    sig.validate(false)?;","highlight_start":1,"highlight_end":42},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_add_or_dbl_aff(","highlight_start":1,"highlight_end":41},{"text":"                        &mut self.point,","highlight_start":1,"highlight_end":41},{"text":"                        &self.point,","highlight_start":1,"highlight_end":37},{"text":"                        &sig.point,","highlight_start":1,"highlight_end":36},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn subgroup_check(&self) -> bool {","highlight_start":1,"highlight_end":51},{"text":"                unsafe { $sig_aggr_in_group(&self.point) }","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[cfg(test)]","highlight_start":1,"highlight_end":21},{"text":"        mod tests {","highlight_start":1,"highlight_end":20},{"text":"            use super::*;","highlight_start":1,"highlight_end":26},{"text":"            use rand::{RngCore, SeedableRng};","highlight_start":1,"highlight_end":46},{"text":"            use rand_chacha::ChaCha20Rng;","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Testing only - do not use for production","highlight_start":1,"highlight_end":56},{"text":"            pub fn gen_random_key(","highlight_start":1,"highlight_end":35},{"text":"                rng: &mut rand_chacha::ChaCha20Rng,","highlight_start":1,"highlight_end":52},{"text":"            ) -> SecretKey {","highlight_start":1,"highlight_end":29},{"text":"                let mut ikm = [0u8; 32];","highlight_start":1,"highlight_end":41},{"text":"                rng.fill_bytes(&mut ikm);","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut sk = <blst_scalar>::default();","highlight_start":1,"highlight_end":55},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    blst_keygen(&mut sk, ikm.as_ptr(), 32, ptr::null(), 0);","highlight_start":1,"highlight_end":76},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                SecretKey { value: sk }","highlight_start":1,"highlight_end":40},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[test]","highlight_start":1,"highlight_end":20},{"text":"            fn test_sign() {","highlight_start":1,"highlight_end":29},{"text":"                let ikm: [u8; 32] = [","highlight_start":1,"highlight_end":38},{"text":"                    0x93, 0xad, 0x7e, 0x65, 0xde, 0xad, 0x05, 0x2a, 0x08, 0x3a,","highlight_start":1,"highlight_end":80},{"text":"                    0x91, 0x0c, 0x8b, 0x72, 0x85, 0x91, 0x46, 0x4c, 0xca, 0x56,","highlight_start":1,"highlight_end":80},{"text":"                    0x60, 0x5b, 0xb0, 0x56, 0xed, 0xfe, 0x2b, 0x60, 0xa6, 0x3c,","highlight_start":1,"highlight_end":80},{"text":"                    0x48, 0x99,","highlight_start":1,"highlight_end":32},{"text":"                ];","highlight_start":1,"highlight_end":19},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sk = SecretKey::key_gen(&ikm, &[]).unwrap();","highlight_start":1,"highlight_end":65},{"text":"                let pk = sk.sk_to_pk();","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let dst = b\"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_\";","highlight_start":1,"highlight_end":74},{"text":"                let msg = b\"hello foo\";","highlight_start":1,"highlight_end":40},{"text":"                let sig = sk.sign(msg, dst, &[]);","highlight_start":1,"highlight_end":50},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let err = sig.verify(true, msg, dst, &[], &pk, true);","highlight_start":1,"highlight_end":70},{"text":"                assert_eq!(err, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[test]","highlight_start":1,"highlight_end":20},{"text":"            fn test_aggregate() {","highlight_start":1,"highlight_end":34},{"text":"                let num_msgs = 10;","highlight_start":1,"highlight_end":35},{"text":"                let dst = b\"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_\";","highlight_start":1,"highlight_end":74},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let seed = [0u8; 32];","highlight_start":1,"highlight_end":38},{"text":"                let mut rng = ChaCha20Rng::from_seed(seed);","highlight_start":1,"highlight_end":60},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sks: Vec<_> =","highlight_start":1,"highlight_end":34},{"text":"                    (0..num_msgs).map(|_| gen_random_key(&mut rng)).collect();","highlight_start":1,"highlight_end":79},{"text":"                let pks =","highlight_start":1,"highlight_end":26},{"text":"                    sks.iter().map(|sk| sk.sk_to_pk()).collect::<Vec<_>>();","highlight_start":1,"highlight_end":76},{"text":"                let pks_refs: Vec<&PublicKey> =","highlight_start":1,"highlight_end":48},{"text":"                    pks.iter().map(|pk| pk).collect();","highlight_start":1,"highlight_end":55},{"text":"                let pks_rev: Vec<&PublicKey> =","highlight_start":1,"highlight_end":47},{"text":"                    pks.iter().rev().map(|pk| pk).collect();","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_comp = pks[0].compress();","highlight_start":1,"highlight_end":49},{"text":"                let pk_uncomp = PublicKey::uncompress(&pk_comp);","highlight_start":1,"highlight_end":65},{"text":"                assert_eq!(pk_uncomp.is_ok(), true);","highlight_start":1,"highlight_end":53},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut msgs: Vec<Vec<u8>> = vec![vec![]; num_msgs];","highlight_start":1,"highlight_end":69},{"text":"                for i in 0..num_msgs {","highlight_start":1,"highlight_end":39},{"text":"                    let msg_len = (rng.next_u64() & 0x3F) + 1;","highlight_start":1,"highlight_end":63},{"text":"                    msgs[i] = vec![0u8; msg_len as usize];","highlight_start":1,"highlight_end":59},{"text":"                    rng.fill_bytes(&mut msgs[i]);","highlight_start":1,"highlight_end":50},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let msgs_refs: Vec<&[u8]> =","highlight_start":1,"highlight_end":44},{"text":"                    msgs.iter().map(|m| m.as_slice()).collect();","highlight_start":1,"highlight_end":65},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sigs = sks","highlight_start":1,"highlight_end":31},{"text":"                    .iter()","highlight_start":1,"highlight_end":28},{"text":"                    .zip(msgs.iter())","highlight_start":1,"highlight_end":38},{"text":"                    .map(|(sk, m)| (sk.sign(m, dst, &[])))","highlight_start":1,"highlight_end":59},{"text":"                    .collect::<Vec<Signature>>();","highlight_start":1,"highlight_end":50},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut errs = sigs","highlight_start":1,"highlight_end":36},{"text":"                    .iter()","highlight_start":1,"highlight_end":28},{"text":"                    .zip(msgs.iter())","highlight_start":1,"highlight_end":38},{"text":"                    .zip(pks.iter())","highlight_start":1,"highlight_end":37},{"text":"                    .map(|((s, m), pk)| (s.verify(true, m, dst, &[], pk, true)))","highlight_start":1,"highlight_end":81},{"text":"                    .collect::<Vec<BLST_ERROR>>();","highlight_start":1,"highlight_end":51},{"text":"                assert_eq!(errs, vec![BLST_ERROR::BLST_SUCCESS; num_msgs]);","highlight_start":1,"highlight_end":76},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Swap message/public key pairs to create bad signature","highlight_start":1,"highlight_end":73},{"text":"                errs = sigs","highlight_start":1,"highlight_end":28},{"text":"                    .iter()","highlight_start":1,"highlight_end":28},{"text":"                    .zip(msgs.iter())","highlight_start":1,"highlight_end":38},{"text":"                    .zip(pks.iter().rev())","highlight_start":1,"highlight_end":43},{"text":"                    .map(|((s, m), pk)| (s.verify(true, m, dst, &[], pk, true)))","highlight_start":1,"highlight_end":81},{"text":"                    .collect::<Vec<BLST_ERROR>>();","highlight_start":1,"highlight_end":51},{"text":"                assert_ne!(errs, vec![BLST_ERROR::BLST_SUCCESS; num_msgs]);","highlight_start":1,"highlight_end":76},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sig_refs =","highlight_start":1,"highlight_end":31},{"text":"                    sigs.iter().map(|s| s).collect::<Vec<&Signature>>();","highlight_start":1,"highlight_end":73},{"text":"                let agg = match AggregateSignature::aggregate(&sig_refs, true) {","highlight_start":1,"highlight_end":81},{"text":"                    Ok(agg) => agg,","highlight_start":1,"highlight_end":36},{"text":"                    Err(err) => panic!(\"aggregate failure: {:?}\", err),","highlight_start":1,"highlight_end":72},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let agg_sig = agg.to_signature();","highlight_start":1,"highlight_end":50},{"text":"                let mut result = agg_sig","highlight_start":1,"highlight_end":41},{"text":"                    .aggregate_verify(false, &msgs_refs, dst, &pks_refs, false);","highlight_start":1,"highlight_end":81},{"text":"                assert_eq!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Swap message/public key pairs to create bad signature","highlight_start":1,"highlight_end":73},{"text":"                result = agg_sig","highlight_start":1,"highlight_end":33},{"text":"                    .aggregate_verify(false, &msgs_refs, dst, &pks_rev, false);","highlight_start":1,"highlight_end":80},{"text":"                assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[test]","highlight_start":1,"highlight_end":20},{"text":"            fn test_multiple_agg_sigs() {","highlight_start":1,"highlight_end":42},{"text":"                let dst = b\"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_\";","highlight_start":1,"highlight_end":74},{"text":"                let num_pks_per_sig = 10;","highlight_start":1,"highlight_end":42},{"text":"                let num_sigs = 10;","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let seed = [0u8; 32];","highlight_start":1,"highlight_end":38},{"text":"                let mut rng = ChaCha20Rng::from_seed(seed);","highlight_start":1,"highlight_end":60},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut msgs: Vec<Vec<u8>> = vec![vec![]; num_sigs];","highlight_start":1,"highlight_end":69},{"text":"                let mut sigs: Vec<Signature> = Vec::with_capacity(num_sigs);","highlight_start":1,"highlight_end":77},{"text":"                let mut pks: Vec<PublicKey> = Vec::with_capacity(num_sigs);","highlight_start":1,"highlight_end":76},{"text":"                let mut rands: Vec<blst_scalar> = Vec::with_capacity(num_sigs);","highlight_start":1,"highlight_end":80},{"text":"                for i in 0..num_sigs {","highlight_start":1,"highlight_end":39},{"text":"                    // Create public keys","highlight_start":1,"highlight_end":42},{"text":"                    let sks_i: Vec<_> = (0..num_pks_per_sig)","highlight_start":1,"highlight_end":61},{"text":"                        .map(|_| gen_random_key(&mut rng))","highlight_start":1,"highlight_end":59},{"text":"                        .collect();","highlight_start":1,"highlight_end":36},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let pks_i = sks_i","highlight_start":1,"highlight_end":38},{"text":"                        .iter()","highlight_start":1,"highlight_end":32},{"text":"                        .map(|sk| sk.sk_to_pk())","highlight_start":1,"highlight_end":49},{"text":"                        .collect::<Vec<_>>();","highlight_start":1,"highlight_end":46},{"text":"                    let pks_refs_i: Vec<&PublicKey> =","highlight_start":1,"highlight_end":54},{"text":"                        pks_i.iter().map(|pk| pk).collect();","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Create random message for pks to all sign","highlight_start":1,"highlight_end":65},{"text":"                    let msg_len = (rng.next_u64() & 0x3F) + 1;","highlight_start":1,"highlight_end":63},{"text":"                    msgs[i] = vec![0u8; msg_len as usize];","highlight_start":1,"highlight_end":59},{"text":"                    rng.fill_bytes(&mut msgs[i]);","highlight_start":1,"highlight_end":50},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Generate signature for each key pair","highlight_start":1,"highlight_end":60},{"text":"                    let sigs_i = sks_i","highlight_start":1,"highlight_end":39},{"text":"                        .iter()","highlight_start":1,"highlight_end":32},{"text":"                        .map(|sk| sk.sign(&msgs[i], dst, &[]))","highlight_start":1,"highlight_end":63},{"text":"                        .collect::<Vec<Signature>>();","highlight_start":1,"highlight_end":54},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Test each current single signature","highlight_start":1,"highlight_end":58},{"text":"                    let errs = sigs_i","highlight_start":1,"highlight_end":38},{"text":"                        .iter()","highlight_start":1,"highlight_end":32},{"text":"                        .zip(pks_i.iter())","highlight_start":1,"highlight_end":43},{"text":"                        .map(|(s, pk)| {","highlight_start":1,"highlight_end":41},{"text":"                            (s.verify(true, &msgs[i], dst, &[], pk, true))","highlight_start":1,"highlight_end":75},{"text":"                        })","highlight_start":1,"highlight_end":27},{"text":"                        .collect::<Vec<BLST_ERROR>>();","highlight_start":1,"highlight_end":55},{"text":"                    assert_eq!(","highlight_start":1,"highlight_end":32},{"text":"                        errs,","highlight_start":1,"highlight_end":30},{"text":"                        vec![BLST_ERROR::BLST_SUCCESS; num_pks_per_sig]","highlight_start":1,"highlight_end":72},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let sig_refs_i =","highlight_start":1,"highlight_end":37},{"text":"                        sigs_i.iter().map(|s| s).collect::<Vec<&Signature>>();","highlight_start":1,"highlight_end":79},{"text":"                    let agg_i =","highlight_start":1,"highlight_end":32},{"text":"                        match AggregateSignature::aggregate(&sig_refs_i, false)","highlight_start":1,"highlight_end":80},{"text":"                        {","highlight_start":1,"highlight_end":26},{"text":"                            Ok(agg_i) => agg_i,","highlight_start":1,"highlight_end":48},{"text":"                            Err(err) => panic!(\"aggregate failure: {:?}\", err),","highlight_start":1,"highlight_end":80},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Test current aggregate signature","highlight_start":1,"highlight_end":56},{"text":"                    sigs.push(agg_i.to_signature());","highlight_start":1,"highlight_end":53},{"text":"                    let mut result = sigs[i].fast_aggregate_verify(","highlight_start":1,"highlight_end":68},{"text":"                        false,","highlight_start":1,"highlight_end":31},{"text":"                        &msgs[i],","highlight_start":1,"highlight_end":34},{"text":"                        dst,","highlight_start":1,"highlight_end":29},{"text":"                        &pks_refs_i,","highlight_start":1,"highlight_end":37},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                    assert_eq!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":66},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // negative test","highlight_start":1,"highlight_end":37},{"text":"                    if i != 0 {","highlight_start":1,"highlight_end":32},{"text":"                        result = sigs[i - 1].fast_aggregate_verify(","highlight_start":1,"highlight_end":68},{"text":"                            false,","highlight_start":1,"highlight_end":35},{"text":"                            &msgs[i],","highlight_start":1,"highlight_end":38},{"text":"                            dst,","highlight_start":1,"highlight_end":33},{"text":"                            &pks_refs_i,","highlight_start":1,"highlight_end":41},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                        assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":70},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // aggregate public keys and push into vec","highlight_start":1,"highlight_end":63},{"text":"                    let agg_pk_i =","highlight_start":1,"highlight_end":35},{"text":"                        match AggregatePublicKey::aggregate(&pks_refs_i, false)","highlight_start":1,"highlight_end":80},{"text":"                        {","highlight_start":1,"highlight_end":26},{"text":"                            Ok(agg_pk_i) => agg_pk_i,","highlight_start":1,"highlight_end":54},{"text":"                            Err(err) => panic!(\"aggregate failure: {:?}\", err),","highlight_start":1,"highlight_end":80},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                    pks.push(agg_pk_i.to_public_key());","highlight_start":1,"highlight_end":56},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Test current aggregate signature with aggregated pks","highlight_start":1,"highlight_end":76},{"text":"                    result = sigs[i].fast_aggregate_verify_pre_aggregated(","highlight_start":1,"highlight_end":75},{"text":"                        false, &msgs[i], dst, &pks[i],","highlight_start":1,"highlight_end":55},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                    assert_eq!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":66},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // negative test","highlight_start":1,"highlight_end":37},{"text":"                    if i != 0 {","highlight_start":1,"highlight_end":32},{"text":"                        result = sigs[i - 1]","highlight_start":1,"highlight_end":45},{"text":"                            .fast_aggregate_verify_pre_aggregated(","highlight_start":1,"highlight_end":67},{"text":"                                false, &msgs[i], dst, &pks[i],","highlight_start":1,"highlight_end":63},{"text":"                            );","highlight_start":1,"highlight_end":31},{"text":"                        assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":70},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // create random values","highlight_start":1,"highlight_end":44},{"text":"                    let mut vals = [0u64; 4];","highlight_start":1,"highlight_end":46},{"text":"                    vals[0] = rng.next_u64();","highlight_start":1,"highlight_end":46},{"text":"                    while vals[0] == 0 {","highlight_start":1,"highlight_end":41},{"text":"                        // Reject zero as it is used for multiplication.","highlight_start":1,"highlight_end":73},{"text":"                        vals[0] = rng.next_u64();","highlight_start":1,"highlight_end":50},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    let mut rand_i =","highlight_start":1,"highlight_end":37},{"text":"                        std::mem::MaybeUninit::<blst_scalar>::uninit();","highlight_start":1,"highlight_end":72},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        blst_scalar_from_uint64(","highlight_start":1,"highlight_end":49},{"text":"                            rand_i.as_mut_ptr(),","highlight_start":1,"highlight_end":49},{"text":"                            vals.as_ptr(),","highlight_start":1,"highlight_end":43},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                        rands.push(rand_i.assume_init());","highlight_start":1,"highlight_end":58},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let msgs_refs: Vec<&[u8]> =","highlight_start":1,"highlight_end":44},{"text":"                    msgs.iter().map(|m| m.as_slice()).collect();","highlight_start":1,"highlight_end":65},{"text":"                let sig_refs =","highlight_start":1,"highlight_end":31},{"text":"                    sigs.iter().map(|s| s).collect::<Vec<&Signature>>();","highlight_start":1,"highlight_end":73},{"text":"                let pks_refs: Vec<&PublicKey> =","highlight_start":1,"highlight_end":48},{"text":"                    pks.iter().map(|pk| pk).collect();","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let msgs_rev: Vec<&[u8]> =","highlight_start":1,"highlight_end":43},{"text":"                    msgs.iter().rev().map(|m| m.as_slice()).collect();","highlight_start":1,"highlight_end":71},{"text":"                let sig_rev =","highlight_start":1,"highlight_end":30},{"text":"                    sigs.iter().rev().map(|s| s).collect::<Vec<&Signature>>();","highlight_start":1,"highlight_end":79},{"text":"                let pks_rev: Vec<&PublicKey> =","highlight_start":1,"highlight_end":47},{"text":"                    pks.iter().rev().map(|pk| pk).collect();","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut result =","highlight_start":1,"highlight_end":33},{"text":"                    Signature::verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":69},{"text":"                        &msgs_refs, dst, &pks_refs, false, &sig_refs, true,","highlight_start":1,"highlight_end":76},{"text":"                        &rands, 64,","highlight_start":1,"highlight_end":36},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                assert_eq!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // negative tests (use reverse msgs, pks, and sigs)","highlight_start":1,"highlight_end":68},{"text":"                result = Signature::verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":74},{"text":"                    &msgs_rev, dst, &pks_refs, false, &sig_refs, true, &rands,","highlight_start":1,"highlight_end":79},{"text":"                    64,","highlight_start":1,"highlight_end":24},{"text":"                );","highlight_start":1,"highlight_end":19},{"text":"                assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                result = Signature::verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":74},{"text":"                    &msgs_refs, dst, &pks_rev, false, &sig_refs, true, &rands,","highlight_start":1,"highlight_end":79},{"text":"                    64,","highlight_start":1,"highlight_end":24},{"text":"                );","highlight_start":1,"highlight_end":19},{"text":"                assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                result = Signature::verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":74},{"text":"                    &msgs_refs, dst, &pks_refs, false, &sig_rev, true, &rands,","highlight_start":1,"highlight_end":79},{"text":"                    64,","highlight_start":1,"highlight_end":24},{"text":"                );","highlight_start":1,"highlight_end":19},{"text":"                assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[test]","highlight_start":1,"highlight_end":20},{"text":"            fn test_serialization() {","highlight_start":1,"highlight_end":38},{"text":"                let seed = [0u8; 32];","highlight_start":1,"highlight_end":38},{"text":"                let mut rng = ChaCha20Rng::from_seed(seed);","highlight_start":1,"highlight_end":60},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sk = gen_random_key(&mut rng);","highlight_start":1,"highlight_end":51},{"text":"                let sk2 = gen_random_key(&mut rng);","highlight_start":1,"highlight_end":52},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk = sk.sk_to_pk();","highlight_start":1,"highlight_end":40},{"text":"                let pk_comp = pk.compress();","highlight_start":1,"highlight_end":45},{"text":"                let pk_ser = pk.serialize();","highlight_start":1,"highlight_end":45},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_uncomp = PublicKey::uncompress(&pk_comp);","highlight_start":1,"highlight_end":65},{"text":"                assert_eq!(pk_uncomp.is_ok(), true);","highlight_start":1,"highlight_end":53},{"text":"                assert_eq!(pk_uncomp.unwrap(), pk);","highlight_start":1,"highlight_end":52},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_deser = PublicKey::deserialize(&pk_ser);","highlight_start":1,"highlight_end":64},{"text":"                assert_eq!(pk_deser.is_ok(), true);","highlight_start":1,"highlight_end":52},{"text":"                assert_eq!(pk_deser.unwrap(), pk);","highlight_start":1,"highlight_end":51},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk2 = sk2.sk_to_pk();","highlight_start":1,"highlight_end":42},{"text":"                let pk_comp2 = pk2.compress();","highlight_start":1,"highlight_end":47},{"text":"                let pk_ser2 = pk2.serialize();","highlight_start":1,"highlight_end":47},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_uncomp2 = PublicKey::uncompress(&pk_comp2);","highlight_start":1,"highlight_end":67},{"text":"                assert_eq!(pk_uncomp2.is_ok(), true);","highlight_start":1,"highlight_end":54},{"text":"                assert_eq!(pk_uncomp2.unwrap(), pk2);","highlight_start":1,"highlight_end":54},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_deser2 = PublicKey::deserialize(&pk_ser2);","highlight_start":1,"highlight_end":66},{"text":"                assert_eq!(pk_deser2.is_ok(), true);","highlight_start":1,"highlight_end":53},{"text":"                assert_eq!(pk_deser2.unwrap(), pk2);","highlight_start":1,"highlight_end":53},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                assert_ne!(pk, pk2);","highlight_start":1,"highlight_end":37},{"text":"                assert_ne!(pk_uncomp.unwrap(), pk2);","highlight_start":1,"highlight_end":53},{"text":"                assert_ne!(pk_deser.unwrap(), pk2);","highlight_start":1,"highlight_end":52},{"text":"                assert_ne!(pk_uncomp2.unwrap(), pk);","highlight_start":1,"highlight_end":53},{"text":"                assert_ne!(pk_deser2.unwrap(), pk);","highlight_start":1,"highlight_end":52},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: variable does not need to be mutable\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/azureuser/blst/bindings/rust/src/lib.rs:935:21\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m935\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m                let mut acc = rx.recv().unwrap();\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: remove this `mut`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1472\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    sig_variant_impl!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1473\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"MinPk\",\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1474\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        blst_p1,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1475\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        blst_p1_affine,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1509\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        blst_p2_in_g2,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1510\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    );\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|______-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this warning originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"variable does not need to be mutable","code":{"code":"unused_mut","explanation":null},"level":"warning","spans":[{"file_name":"/home/azureuser/blst/bindings/rust/src/lib.rs","byte_start":31357,"byte_end":31364,"line_start":935,"line_end":935,"column_start":21,"column_end":28,"is_primary":true,"text":[{"text":"                let mut acc = rx.recv().unwrap();","highlight_start":21,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/azureuser/blst/bindings/rust/src/lib.rs","byte_start":53005,"byte_end":54021,"line_start":1516,"line_end":1554,"column_start":5,"column_end":7,"is_primary":false,"text":[{"text":"    sig_variant_impl!(","highlight_start":5,"highlight_end":23},{"text":"        \"MinSig\",","highlight_start":1,"highlight_end":18},{"text":"        blst_p2,","highlight_start":1,"highlight_end":17},{"text":"        blst_p2_affine,","highlight_start":1,"highlight_end":24},{"text":"        blst_p1,","highlight_start":1,"highlight_end":17},{"text":"        blst_p1_affine,","highlight_start":1,"highlight_end":24},{"text":"        blst_sk_to_pk2_in_g2,","highlight_start":1,"highlight_end":30},{"text":"        true,","highlight_start":1,"highlight_end":14},{"text":"        blst_hash_to_g1,","highlight_start":1,"highlight_end":25},{"text":"        blst_sign_pk2_in_g2,","highlight_start":1,"highlight_end":29},{"text":"        blst_p2_affine_is_equal,","highlight_start":1,"highlight_end":33},{"text":"        blst_p1_affine_is_equal,","highlight_start":1,"highlight_end":33},{"text":"        blst_core_verify_pk_in_g2,","highlight_start":1,"highlight_end":35},{"text":"        blst_p2_affine_in_g2,","highlight_start":1,"highlight_end":30},{"text":"        blst_p2_to_affine,","highlight_start":1,"highlight_end":27},{"text":"        blst_p2_from_affine,","highlight_start":1,"highlight_end":29},{"text":"        blst_p2_affine_serialize,","highlight_start":1,"highlight_end":34},{"text":"        blst_p2_affine_compress,","highlight_start":1,"highlight_end":33},{"text":"        blst_p2_deserialize,","highlight_start":1,"highlight_end":29},{"text":"        blst_p2_uncompress,","highlight_start":1,"highlight_end":28},{"text":"        96,","highlight_start":1,"highlight_end":12},{"text":"        192,","highlight_start":1,"highlight_end":13},{"text":"        blst_p1_affine_in_g1,","highlight_start":1,"highlight_end":30},{"text":"        blst_p1_to_affine,","highlight_start":1,"highlight_end":27},{"text":"        blst_p1_from_affine,","highlight_start":1,"highlight_end":29},{"text":"        blst_p1_affine_serialize,","highlight_start":1,"highlight_end":34},{"text":"        blst_p1_affine_compress,","highlight_start":1,"highlight_end":33},{"text":"        blst_p1_deserialize,","highlight_start":1,"highlight_end":29},{"text":"        blst_p1_uncompress,","highlight_start":1,"highlight_end":28},{"text":"        48,","highlight_start":1,"highlight_end":12},{"text":"        96,","highlight_start":1,"highlight_end":12},{"text":"        blst_p2_add_or_double,","highlight_start":1,"highlight_end":31},{"text":"        blst_p2_add_or_double_affine,","highlight_start":1,"highlight_end":38},{"text":"        blst_p1_add_or_double,","highlight_start":1,"highlight_end":31},{"text":"        blst_p1_add_or_double_affine,","highlight_start":1,"highlight_end":38},{"text":"        blst_p2_affine_is_inf,","highlight_start":1,"highlight_end":31},{"text":"        blst_p1_affine_is_inf,","highlight_start":1,"highlight_end":31},{"text":"        blst_p1_in_g1,","highlight_start":1,"highlight_end":23},{"text":"    );","highlight_start":1,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"sig_variant_impl!","def_site_span":{"file_name":"/home/azureuser/blst/bindings/rust/src/lib.rs","byte_start":7790,"byte_end":51903,"line_start":283,"line_end":1467,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! sig_variant_impl {","highlight_start":1,"highlight_end":32},{"text":"    (","highlight_start":1,"highlight_end":6},{"text":"        $name:expr,","highlight_start":1,"highlight_end":20},{"text":"        $pk:ty,","highlight_start":1,"highlight_end":16},{"text":"        $pk_aff:ty,","highlight_start":1,"highlight_end":20},{"text":"        $sig:ty,","highlight_start":1,"highlight_end":17},{"text":"        $sig_aff:ty,","highlight_start":1,"highlight_end":21},{"text":"        $sk_to_pk:ident,","highlight_start":1,"highlight_end":25},{"text":"        $hash_or_encode:expr,","highlight_start":1,"highlight_end":30},{"text":"        $hash_or_encode_to:ident,","highlight_start":1,"highlight_end":34},{"text":"        $sign:ident,","highlight_start":1,"highlight_end":21},{"text":"        $pk_eq:ident,","highlight_start":1,"highlight_end":22},{"text":"        $sig_eq:ident,","highlight_start":1,"highlight_end":23},{"text":"        $verify:ident,","highlight_start":1,"highlight_end":23},{"text":"        $pk_in_group:ident,","highlight_start":1,"highlight_end":28},{"text":"        $pk_to_aff:ident,","highlight_start":1,"highlight_end":26},{"text":"        $pk_from_aff:ident,","highlight_start":1,"highlight_end":28},{"text":"        $pk_ser:ident,","highlight_start":1,"highlight_end":23},{"text":"        $pk_comp:ident,","highlight_start":1,"highlight_end":24},{"text":"        $pk_deser:ident,","highlight_start":1,"highlight_end":25},{"text":"        $pk_uncomp:ident,","highlight_start":1,"highlight_end":26},{"text":"        $pk_comp_size:expr,","highlight_start":1,"highlight_end":28},{"text":"        $pk_ser_size:expr,","highlight_start":1,"highlight_end":27},{"text":"        $sig_in_group:ident,","highlight_start":1,"highlight_end":29},{"text":"        $sig_to_aff:ident,","highlight_start":1,"highlight_end":27},{"text":"        $sig_from_aff:ident,","highlight_start":1,"highlight_end":29},{"text":"        $sig_ser:ident,","highlight_start":1,"highlight_end":24},{"text":"        $sig_comp:ident,","highlight_start":1,"highlight_end":25},{"text":"        $sig_deser:ident,","highlight_start":1,"highlight_end":26},{"text":"        $sig_uncomp:ident,","highlight_start":1,"highlight_end":27},{"text":"        $sig_comp_size:expr,","highlight_start":1,"highlight_end":29},{"text":"        $sig_ser_size:expr,","highlight_start":1,"highlight_end":28},{"text":"        $pk_add_or_dbl:ident,","highlight_start":1,"highlight_end":30},{"text":"        $pk_add_or_dbl_aff:ident,","highlight_start":1,"highlight_end":34},{"text":"        $sig_add_or_dbl:ident,","highlight_start":1,"highlight_end":31},{"text":"        $sig_add_or_dbl_aff:ident,","highlight_start":1,"highlight_end":35},{"text":"        $pk_is_inf:ident,","highlight_start":1,"highlight_end":26},{"text":"        $sig_is_inf:ident,","highlight_start":1,"highlight_end":27},{"text":"        $sig_aggr_in_group:ident,","highlight_start":1,"highlight_end":34},{"text":"    ) => {","highlight_start":1,"highlight_end":11},{"text":"        /// Secret Key","highlight_start":1,"highlight_end":23},{"text":"        #[derive(Default, Debug, Clone, Zeroize)]","highlight_start":1,"highlight_end":50},{"text":"        #[zeroize(drop)]","highlight_start":1,"highlight_end":25},{"text":"        pub struct SecretKey {","highlight_start":1,"highlight_end":31},{"text":"            value: blst_scalar,","highlight_start":1,"highlight_end":32},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl SecretKey {","highlight_start":1,"highlight_end":25},{"text":"            /// Deterministically generate a secret key from key material","highlight_start":1,"highlight_end":74},{"text":"            pub fn key_gen(","highlight_start":1,"highlight_end":28},{"text":"                ikm: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                key_info: &[u8],","highlight_start":1,"highlight_end":33},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                if ikm.len() < 32 {","highlight_start":1,"highlight_end":36},{"text":"                    return Err(BLST_ERROR::BLST_BAD_ENCODING);","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut sk = SecretKey::default();","highlight_start":1,"highlight_end":51},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    blst_keygen(","highlight_start":1,"highlight_end":33},{"text":"                        &mut sk.value,","highlight_start":1,"highlight_end":39},{"text":"                        ikm.as_ptr(),","highlight_start":1,"highlight_end":38},{"text":"                        ikm.len(),","highlight_start":1,"highlight_end":35},{"text":"                        key_info.as_ptr(),","highlight_start":1,"highlight_end":43},{"text":"                        key_info.len(),","highlight_start":1,"highlight_end":40},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(sk)","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // sk_to_pk","highlight_start":1,"highlight_end":24},{"text":"            pub fn sk_to_pk(&self) -> PublicKey {","highlight_start":1,"highlight_end":50},{"text":"                // TODO - would the user like the serialized/compressed pk as well?","highlight_start":1,"highlight_end":84},{"text":"                let mut pk_aff = PublicKey::default();","highlight_start":1,"highlight_end":55},{"text":"                //let mut pk_ser = [0u8; $pk_ser_size];","highlight_start":1,"highlight_end":56},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sk_to_pk(","highlight_start":1,"highlight_end":31},{"text":"                        //pk_ser.as_mut_ptr(),","highlight_start":1,"highlight_end":47},{"text":"                        ptr::null_mut(),","highlight_start":1,"highlight_end":41},{"text":"                        &mut pk_aff.point,","highlight_start":1,"highlight_end":43},{"text":"                        &self.value,","highlight_start":1,"highlight_end":37},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                pk_aff","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Sign","highlight_start":1,"highlight_end":20},{"text":"            pub fn sign(","highlight_start":1,"highlight_end":25},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                msg: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                aug: &[u8],","highlight_start":1,"highlight_end":28},{"text":"            ) -> Signature {","highlight_start":1,"highlight_end":29},{"text":"                // TODO - would the user like the serialized/compressed sig as well?","highlight_start":1,"highlight_end":85},{"text":"                let mut q = <$sig>::default();","highlight_start":1,"highlight_end":47},{"text":"                let mut sig_aff = <$sig_aff>::default();","highlight_start":1,"highlight_end":57},{"text":"                //let mut sig_ser = [0u8; $sig_ser_size];","highlight_start":1,"highlight_end":58},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $hash_or_encode_to(","highlight_start":1,"highlight_end":40},{"text":"                        &mut q,","highlight_start":1,"highlight_end":32},{"text":"                        msg.as_ptr(),","highlight_start":1,"highlight_end":38},{"text":"                        msg.len(),","highlight_start":1,"highlight_end":35},{"text":"                        dst.as_ptr(),","highlight_start":1,"highlight_end":38},{"text":"                        dst.len(),","highlight_start":1,"highlight_end":35},{"text":"                        aug.as_ptr(),","highlight_start":1,"highlight_end":38},{"text":"                        aug.len(),","highlight_start":1,"highlight_end":35},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                    $sign(ptr::null_mut(), &mut sig_aff, &q, &self.value);","highlight_start":1,"highlight_end":75},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Signature { point: sig_aff }","highlight_start":1,"highlight_end":45},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // TODO - formally speaking application is entitled to have","highlight_start":1,"highlight_end":72},{"text":"            // ultimate control over secret key storage, which means that","highlight_start":1,"highlight_end":74},{"text":"            // corresponding serialization/deserialization subroutines","highlight_start":1,"highlight_end":71},{"text":"            // should accept reference to where to store the result, as","highlight_start":1,"highlight_end":72},{"text":"            // opposite to returning one.","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // serialize","highlight_start":1,"highlight_end":25},{"text":"            pub fn serialize(&self) -> [u8; 32] {","highlight_start":1,"highlight_end":50},{"text":"                let mut sk_out = [0; 32];","highlight_start":1,"highlight_end":42},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    blst_bendian_from_scalar(sk_out.as_mut_ptr(), &self.value);","highlight_start":1,"highlight_end":80},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                sk_out","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // deserialize","highlight_start":1,"highlight_end":27},{"text":"            pub fn deserialize(sk_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":75},{"text":"                let mut sk = blst_scalar::default();","highlight_start":1,"highlight_end":53},{"text":"                if sk_in.len() != 32 {","highlight_start":1,"highlight_end":39},{"text":"                    return Err(BLST_ERROR::BLST_BAD_ENCODING);","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    blst_scalar_from_bendian(&mut sk, sk_in.as_ptr());","highlight_start":1,"highlight_end":71},{"text":"                    if !blst_sk_check(&sk) {","highlight_start":1,"highlight_end":45},{"text":"                        return Err(BLST_ERROR::BLST_BAD_ENCODING);","highlight_start":1,"highlight_end":67},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(Self { value: sk })","highlight_start":1,"highlight_end":39},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_bytes(&self) -> [u8; 32] {","highlight_start":1,"highlight_end":49},{"text":"                SecretKey::serialize(&self)","highlight_start":1,"highlight_end":44},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_bytes(sk_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":74},{"text":"                SecretKey::deserialize(sk_in)","highlight_start":1,"highlight_end":46},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[derive(Default, Debug, Clone, Copy)]","highlight_start":1,"highlight_end":47},{"text":"        pub struct PublicKey {","highlight_start":1,"highlight_end":31},{"text":"            point: $pk_aff,","highlight_start":1,"highlight_end":28},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl PublicKey {","highlight_start":1,"highlight_end":25},{"text":"            // Core operations","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // key_validate","highlight_start":1,"highlight_end":28},{"text":"            pub fn validate(&self) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":63},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    if $pk_is_inf(&self.point) {","highlight_start":1,"highlight_end":49},{"text":"                        return Err(BLST_ERROR::BLST_PK_IS_INFINITY);","highlight_start":1,"highlight_end":69},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    if !$pk_in_group(&self.point) {","highlight_start":1,"highlight_end":52},{"text":"                        return Err(BLST_ERROR::BLST_POINT_NOT_IN_GROUP);","highlight_start":1,"highlight_end":73},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn key_validate(key: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":74},{"text":"                let pk = PublicKey::from_bytes(key)?;","highlight_start":1,"highlight_end":54},{"text":"                pk.validate()?;","highlight_start":1,"highlight_end":32},{"text":"                Ok(pk)","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_aggregate(agg_pk: &AggregatePublicKey) -> Self {","highlight_start":1,"highlight_end":73},{"text":"                let mut pk_aff = <$pk_aff>::default();","highlight_start":1,"highlight_end":55},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_to_aff(&mut pk_aff, &agg_pk.point);","highlight_start":1,"highlight_end":60},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Self { point: pk_aff }","highlight_start":1,"highlight_end":39},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Serdes","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn compress(&self) -> [u8; $pk_comp_size] {","highlight_start":1,"highlight_end":60},{"text":"                let mut pk_comp = [0u8; $pk_comp_size];","highlight_start":1,"highlight_end":56},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_comp(pk_comp.as_mut_ptr(), &self.point);","highlight_start":1,"highlight_end":65},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                pk_comp","highlight_start":1,"highlight_end":24},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn serialize(&self) -> [u8; $pk_ser_size] {","highlight_start":1,"highlight_end":60},{"text":"                let mut pk_out = [0u8; $pk_ser_size];","highlight_start":1,"highlight_end":54},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_ser(pk_out.as_mut_ptr(), &self.point);","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                pk_out","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn uncompress(pk_comp: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":76},{"text":"                if pk_comp.len() == $pk_comp_size && (pk_comp[0] & 0x80) != 0 {","highlight_start":1,"highlight_end":80},{"text":"                    let mut pk = <$pk_aff>::default();","highlight_start":1,"highlight_end":55},{"text":"                    let err = unsafe { $pk_uncomp(&mut pk, pk_comp.as_ptr()) };","highlight_start":1,"highlight_end":80},{"text":"                    if err != BLST_ERROR::BLST_SUCCESS {","highlight_start":1,"highlight_end":57},{"text":"                        return Err(err);","highlight_start":1,"highlight_end":41},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(Self { point: pk })","highlight_start":1,"highlight_end":43},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Err(BLST_ERROR::BLST_BAD_ENCODING)","highlight_start":1,"highlight_end":55},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn deserialize(pk_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":75},{"text":"                if (pk_in.len() == $pk_ser_size && (pk_in[0] & 0x80) == 0)","highlight_start":1,"highlight_end":75},{"text":"                    || (pk_in.len() == $pk_comp_size && (pk_in[0] & 0x80) != 0)","highlight_start":1,"highlight_end":80},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    let mut pk = <$pk_aff>::default();","highlight_start":1,"highlight_end":55},{"text":"                    let err = unsafe { $pk_deser(&mut pk, pk_in.as_ptr()) };","highlight_start":1,"highlight_end":77},{"text":"                    if err != BLST_ERROR::BLST_SUCCESS {","highlight_start":1,"highlight_end":57},{"text":"                        return Err(err);","highlight_start":1,"highlight_end":41},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(Self { point: pk })","highlight_start":1,"highlight_end":43},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Err(BLST_ERROR::BLST_BAD_ENCODING)","highlight_start":1,"highlight_end":55},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_bytes(pk_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":74},{"text":"                PublicKey::deserialize(pk_in)","highlight_start":1,"highlight_end":46},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_bytes(&self) -> [u8; $pk_comp_size] {","highlight_start":1,"highlight_end":60},{"text":"                self.compress()","highlight_start":1,"highlight_end":32},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Trait for equality comparisons which are equivalence relations.","highlight_start":1,"highlight_end":75},{"text":"        //","highlight_start":1,"highlight_end":11},{"text":"        // This means, that in addition to a == b and a != b being strict","highlight_start":1,"highlight_end":74},{"text":"        // inverses, the equality must be reflexive, symmetric and transitive.","highlight_start":1,"highlight_end":79},{"text":"        impl Eq for PublicKey {}","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl PartialEq for PublicKey {","highlight_start":1,"highlight_end":39},{"text":"            fn eq(&self, other: &Self) -> bool {","highlight_start":1,"highlight_end":49},{"text":"                unsafe { $pk_eq(&self.point, &other.point) }","highlight_start":1,"highlight_end":61},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[derive(Debug, Clone, Copy)]","highlight_start":1,"highlight_end":38},{"text":"        pub struct AggregatePublicKey {","highlight_start":1,"highlight_end":40},{"text":"            point: $pk,","highlight_start":1,"highlight_end":24},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl AggregatePublicKey {","highlight_start":1,"highlight_end":34},{"text":"            pub fn from_public_key(pk: &PublicKey) -> Self {","highlight_start":1,"highlight_end":61},{"text":"                let mut agg_pk = <$pk>::default();","highlight_start":1,"highlight_end":51},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_from_aff(&mut agg_pk, &pk.point);","highlight_start":1,"highlight_end":58},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Self { point: agg_pk }","highlight_start":1,"highlight_end":39},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_public_key(&self) -> PublicKey {","highlight_start":1,"highlight_end":55},{"text":"                let mut pk = <$pk_aff>::default();","highlight_start":1,"highlight_end":51},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_to_aff(&mut pk, &self.point);","highlight_start":1,"highlight_end":54},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                PublicKey { point: pk }","highlight_start":1,"highlight_end":40},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Aggregate","highlight_start":1,"highlight_end":25},{"text":"            pub fn aggregate(","highlight_start":1,"highlight_end":30},{"text":"                pks: &[&PublicKey],","highlight_start":1,"highlight_end":36},{"text":"                pks_validate: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                if pks.len() == 0 {","highlight_start":1,"highlight_end":36},{"text":"                    return Err(BLST_ERROR::BLST_AGGR_TYPE_MISMATCH);","highlight_start":1,"highlight_end":69},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if pks_validate {","highlight_start":1,"highlight_end":34},{"text":"                    pks[0].validate()?;","highlight_start":1,"highlight_end":40},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut agg_pk = AggregatePublicKey::from_public_key(pks[0]);","highlight_start":1,"highlight_end":78},{"text":"                for s in pks.iter().skip(1) {","highlight_start":1,"highlight_end":46},{"text":"                    if pks_validate {","highlight_start":1,"highlight_end":38},{"text":"                        s.validate()?;","highlight_start":1,"highlight_end":39},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        $pk_add_or_dbl_aff(","highlight_start":1,"highlight_end":44},{"text":"                            &mut agg_pk.point,","highlight_start":1,"highlight_end":47},{"text":"                            &agg_pk.point,","highlight_start":1,"highlight_end":43},{"text":"                            &s.point,","highlight_start":1,"highlight_end":38},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(agg_pk)","highlight_start":1,"highlight_end":27},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn aggregate_serialized(","highlight_start":1,"highlight_end":41},{"text":"                pks: &[&[u8]],","highlight_start":1,"highlight_end":31},{"text":"                pks_validate: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                // TODO - threading","highlight_start":1,"highlight_end":36},{"text":"                if pks.len() == 0 {","highlight_start":1,"highlight_end":36},{"text":"                    return Err(BLST_ERROR::BLST_AGGR_TYPE_MISMATCH);","highlight_start":1,"highlight_end":69},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut pk = if pks_validate {","highlight_start":1,"highlight_end":47},{"text":"                    PublicKey::key_validate(pks[0])?","highlight_start":1,"highlight_end":53},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    PublicKey::from_bytes(pks[0])?","highlight_start":1,"highlight_end":51},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut agg_pk = AggregatePublicKey::from_public_key(&pk);","highlight_start":1,"highlight_end":75},{"text":"                for s in pks.iter().skip(1) {","highlight_start":1,"highlight_end":46},{"text":"                    pk = if pks_validate {","highlight_start":1,"highlight_end":43},{"text":"                        PublicKey::key_validate(s)?","highlight_start":1,"highlight_end":52},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        PublicKey::from_bytes(s)?","highlight_start":1,"highlight_end":50},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        $pk_add_or_dbl_aff(","highlight_start":1,"highlight_end":44},{"text":"                            &mut agg_pk.point,","highlight_start":1,"highlight_end":47},{"text":"                            &agg_pk.point,","highlight_start":1,"highlight_end":43},{"text":"                            &pk.point,","highlight_start":1,"highlight_end":39},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(agg_pk)","highlight_start":1,"highlight_end":27},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn add_aggregate(&mut self, agg_pk: &AggregatePublicKey) {","highlight_start":1,"highlight_end":75},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_add_or_dbl(&mut self.point, &self.point, &agg_pk.point);","highlight_start":1,"highlight_end":81},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn add_public_key(","highlight_start":1,"highlight_end":35},{"text":"                &mut self,","highlight_start":1,"highlight_end":27},{"text":"                pk: &PublicKey,","highlight_start":1,"highlight_end":32},{"text":"                pk_validate: bool,","highlight_start":1,"highlight_end":35},{"text":"            ) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":42},{"text":"                if pk_validate {","highlight_start":1,"highlight_end":33},{"text":"                    pk.validate()?;","highlight_start":1,"highlight_end":36},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_add_or_dbl_aff(&mut self.point, &self.point, &pk.point);","highlight_start":1,"highlight_end":81},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[derive(Debug, Clone, Copy)]","highlight_start":1,"highlight_end":38},{"text":"        pub struct Signature {","highlight_start":1,"highlight_end":31},{"text":"            point: $sig_aff,","highlight_start":1,"highlight_end":29},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl Signature {","highlight_start":1,"highlight_end":25},{"text":"            // sig_infcheck, check for infinity, is a way to avoid going","highlight_start":1,"highlight_end":73},{"text":"            // into resource-consuming verification. Passing 'false' is","highlight_start":1,"highlight_end":72},{"text":"            // always cryptographically safe, but application might want","highlight_start":1,"highlight_end":73},{"text":"            // to guard against obviously bogus individual[!] signatures.","highlight_start":1,"highlight_end":74},{"text":"            pub fn validate(","highlight_start":1,"highlight_end":29},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_infcheck: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":42},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    if sig_infcheck && $sig_is_inf(&self.point) {","highlight_start":1,"highlight_end":66},{"text":"                        return Err(BLST_ERROR::BLST_PK_IS_INFINITY);","highlight_start":1,"highlight_end":69},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    if !$sig_in_group(&self.point) {","highlight_start":1,"highlight_end":53},{"text":"                        return Err(BLST_ERROR::BLST_POINT_NOT_IN_GROUP);","highlight_start":1,"highlight_end":73},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn sig_validate(","highlight_start":1,"highlight_end":33},{"text":"                sig: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                sig_infcheck: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                let sig = Signature::from_bytes(sig)?;","highlight_start":1,"highlight_end":55},{"text":"                sig.validate(sig_infcheck)?;","highlight_start":1,"highlight_end":45},{"text":"                Ok(sig)","highlight_start":1,"highlight_end":24},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn verify(","highlight_start":1,"highlight_end":27},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"                msg: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                aug: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pk: &PublicKey,","highlight_start":1,"highlight_end":32},{"text":"                pk_validate: bool,","highlight_start":1,"highlight_end":35},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                let aug_msg = [aug, msg].concat();","highlight_start":1,"highlight_end":51},{"text":"                self.aggregate_verify(","highlight_start":1,"highlight_end":39},{"text":"                    sig_groupcheck,","highlight_start":1,"highlight_end":36},{"text":"                    &[aug_msg.as_slice()],","highlight_start":1,"highlight_end":43},{"text":"                    dst,","highlight_start":1,"highlight_end":25},{"text":"                    &[pk],","highlight_start":1,"highlight_end":27},{"text":"                    pk_validate,","highlight_start":1,"highlight_end":33},{"text":"                )","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn aggregate_verify(","highlight_start":1,"highlight_end":37},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"                msgs: &[&[u8]],","highlight_start":1,"highlight_end":32},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pks: &[&PublicKey],","highlight_start":1,"highlight_end":36},{"text":"                pks_validate: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                let n_elems = pks.len();","highlight_start":1,"highlight_end":41},{"text":"                if n_elems == 0 || msgs.len() != n_elems {","highlight_start":1,"highlight_end":59},{"text":"                    return BLST_ERROR::BLST_VERIFY_FAIL;","highlight_start":1,"highlight_end":57},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // TODO - check msg uniqueness?","highlight_start":1,"highlight_end":48},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // let pool = da_pool();","highlight_start":1,"highlight_end":41},{"text":"                let (tx, rx) = channel();","highlight_start":1,"highlight_end":42},{"text":"                let counter = Arc::new(AtomicUsize::new(0));","highlight_start":1,"highlight_end":61},{"text":"                let valid = Arc::new(AtomicBool::new(true));","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Bypass 'lifetime limitations by brute force. It works,","highlight_start":1,"highlight_end":74},{"text":"                // because we explicitly join the threads...","highlight_start":1,"highlight_end":61},{"text":"                let raw_pks = unsafe {","highlight_start":1,"highlight_end":39},{"text":"                    transmute::<*const &PublicKey, usize>(pks.as_ptr())","highlight_start":1,"highlight_end":72},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let raw_msgs =","highlight_start":1,"highlight_end":31},{"text":"                    unsafe { transmute::<*const &[u8], usize>(msgs.as_ptr()) };","highlight_start":1,"highlight_end":80},{"text":"                let dst =","highlight_start":1,"highlight_end":26},{"text":"                    unsafe { slice::from_raw_parts(dst.as_ptr(), dst.len()) };","highlight_start":1,"highlight_end":79},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // let n_workers = std::cmp::min(pool.max_count(), n_elems);","highlight_start":1,"highlight_end":77},{"text":"                // for _ in 0..n_workers {","highlight_start":1,"highlight_end":43},{"text":"                    let tx = tx.clone();","highlight_start":1,"highlight_end":41},{"text":"                    let counter = counter.clone();","highlight_start":1,"highlight_end":51},{"text":"                    let valid = valid.clone();","highlight_start":1,"highlight_end":47},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // pool.execute(move || {","highlight_start":1,"highlight_end":46},{"text":"                        let mut pairing = Pairing::new($hash_or_encode, dst);","highlight_start":1,"highlight_end":78},{"text":"                        // reconstruct input slices...","highlight_start":1,"highlight_end":55},{"text":"                        let msgs = unsafe {","highlight_start":1,"highlight_end":44},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &[u8]>(raw_msgs),","highlight_start":1,"highlight_end":76},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                        let pks = unsafe {","highlight_start":1,"highlight_end":43},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &PublicKey>(raw_pks),","highlight_start":1,"highlight_end":80},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        while valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":62},{"text":"                            let work = counter.fetch_add(1, Ordering::Relaxed);","highlight_start":1,"highlight_end":80},{"text":"                            if work >= n_elems {","highlight_start":1,"highlight_end":49},{"text":"                                break;","highlight_start":1,"highlight_end":39},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                            if pairing.aggregate(","highlight_start":1,"highlight_end":50},{"text":"                                &pks[work].point,","highlight_start":1,"highlight_end":50},{"text":"                                pks_validate,","highlight_start":1,"highlight_end":46},{"text":"                                &unsafe { ptr::null::<$sig_aff>().as_ref() },","highlight_start":1,"highlight_end":78},{"text":"                                false,","highlight_start":1,"highlight_end":39},{"text":"                                &msgs[work],","highlight_start":1,"highlight_end":45},{"text":"                                &[],","highlight_start":1,"highlight_end":37},{"text":"                            ) != BLST_ERROR::BLST_SUCCESS","highlight_start":1,"highlight_end":58},{"text":"                            {","highlight_start":1,"highlight_end":30},{"text":"                                valid.store(false, Ordering::Relaxed);","highlight_start":1,"highlight_end":71},{"text":"                                break;","highlight_start":1,"highlight_end":39},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        if valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":59},{"text":"                            pairing.commit();","highlight_start":1,"highlight_end":46},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        tx.send(pairing).expect(\"disaster\");","highlight_start":1,"highlight_end":61},{"text":"                    // });","highlight_start":1,"highlight_end":27},{"text":"                // }","highlight_start":1,"highlight_end":21},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                if sig_groupcheck && valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":69},{"text":"                    match self.validate(false) {","highlight_start":1,"highlight_end":49},{"text":"                        Err(_err) => valid.store(false, Ordering::Relaxed),","highlight_start":1,"highlight_end":76},{"text":"                        _ => (),","highlight_start":1,"highlight_end":33},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut gtsig = blst_fp12::default();","highlight_start":1,"highlight_end":54},{"text":"                if valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":51},{"text":"                    Pairing::aggregated(&mut gtsig, &self.point);","highlight_start":1,"highlight_end":66},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut acc = rx.recv().unwrap();","highlight_start":1,"highlight_end":50},{"text":"                // for _ in 1..n_workers {","highlight_start":1,"highlight_end":43},{"text":"                    // acc.merge(&rx.recv().unwrap());","highlight_start":1,"highlight_end":55},{"text":"                // }","highlight_start":1,"highlight_end":21},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                if valid.load(Ordering::Relaxed)","highlight_start":1,"highlight_end":49},{"text":"                    && acc.finalverify(Some(&gtsig))","highlight_start":1,"highlight_end":53},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    BLST_ERROR::BLST_SUCCESS","highlight_start":1,"highlight_end":45},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    BLST_ERROR::BLST_VERIFY_FAIL","highlight_start":1,"highlight_end":49},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // pks are assumed to be verified for proof of possession,","highlight_start":1,"highlight_end":71},{"text":"            // which implies that they are already group-checked","highlight_start":1,"highlight_end":65},{"text":"            pub fn fast_aggregate_verify(","highlight_start":1,"highlight_end":42},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"                msg: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pks: &[&PublicKey],","highlight_start":1,"highlight_end":36},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                let agg_pk = match AggregatePublicKey::aggregate(pks, false) {","highlight_start":1,"highlight_end":79},{"text":"                    Ok(agg_sig) => agg_sig,","highlight_start":1,"highlight_end":44},{"text":"                    Err(err) => return err,","highlight_start":1,"highlight_end":44},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let pk = agg_pk.to_public_key();","highlight_start":1,"highlight_end":49},{"text":"                self.aggregate_verify(","highlight_start":1,"highlight_end":39},{"text":"                    sig_groupcheck,","highlight_start":1,"highlight_end":36},{"text":"                    &[msg],","highlight_start":1,"highlight_end":28},{"text":"                    dst,","highlight_start":1,"highlight_end":25},{"text":"                    &[&pk],","highlight_start":1,"highlight_end":28},{"text":"                    false,","highlight_start":1,"highlight_end":27},{"text":"                )","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn fast_aggregate_verify_pre_aggregated(","highlight_start":1,"highlight_end":57},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"                msg: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pk: &PublicKey,","highlight_start":1,"highlight_end":32},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                self.aggregate_verify(sig_groupcheck, &[msg], dst, &[pk], false)","highlight_start":1,"highlight_end":81},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // https://ethresear.ch/t/fast-verification-of-multiple-bls-signatures/5407","highlight_start":1,"highlight_end":88},{"text":"            pub fn verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":57},{"text":"                msgs: &[&[u8]],","highlight_start":1,"highlight_end":32},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pks: &[&PublicKey],","highlight_start":1,"highlight_end":36},{"text":"                pks_validate: bool,","highlight_start":1,"highlight_end":36},{"text":"                sigs: &[&Signature],","highlight_start":1,"highlight_end":37},{"text":"                sigs_groupcheck: bool,","highlight_start":1,"highlight_end":39},{"text":"                rands: &[blst_scalar],","highlight_start":1,"highlight_end":39},{"text":"                rand_bits: usize,","highlight_start":1,"highlight_end":34},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                let n_elems = pks.len();","highlight_start":1,"highlight_end":41},{"text":"                if n_elems == 0","highlight_start":1,"highlight_end":32},{"text":"                    || msgs.len() != n_elems","highlight_start":1,"highlight_end":45},{"text":"                    || sigs.len() != n_elems","highlight_start":1,"highlight_end":45},{"text":"                    || rands.len() != n_elems","highlight_start":1,"highlight_end":46},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    return BLST_ERROR::BLST_VERIFY_FAIL;","highlight_start":1,"highlight_end":57},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // TODO - check msg uniqueness?","highlight_start":1,"highlight_end":48},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // let pool = da_pool();","highlight_start":1,"highlight_end":41},{"text":"                let (tx, rx) = channel();","highlight_start":1,"highlight_end":42},{"text":"                let counter = Arc::new(AtomicUsize::new(0));","highlight_start":1,"highlight_end":61},{"text":"                let valid = Arc::new(AtomicBool::new(true));","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Bypass 'lifetime limitations by brute force. It works,","highlight_start":1,"highlight_end":74},{"text":"                // because we explicitly join the threads...","highlight_start":1,"highlight_end":61},{"text":"                let raw_pks = unsafe {","highlight_start":1,"highlight_end":39},{"text":"                    transmute::<*const &PublicKey, usize>(pks.as_ptr())","highlight_start":1,"highlight_end":72},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let raw_sigs = unsafe {","highlight_start":1,"highlight_end":40},{"text":"                    transmute::<*const &Signature, usize>(sigs.as_ptr())","highlight_start":1,"highlight_end":73},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let raw_rands = unsafe {","highlight_start":1,"highlight_end":41},{"text":"                    transmute::<*const blst_scalar, usize>(rands.as_ptr())","highlight_start":1,"highlight_end":75},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let raw_msgs =","highlight_start":1,"highlight_end":31},{"text":"                    unsafe { transmute::<*const &[u8], usize>(msgs.as_ptr()) };","highlight_start":1,"highlight_end":80},{"text":"                let dst =","highlight_start":1,"highlight_end":26},{"text":"                    unsafe { slice::from_raw_parts(dst.as_ptr(), dst.len()) };","highlight_start":1,"highlight_end":79},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // let n_workers = std::cmp::min(pool.max_count(), n_elems);","highlight_start":1,"highlight_end":77},{"text":"                //for _ in 0..n_workers {","highlight_start":1,"highlight_end":42},{"text":"                    let tx = tx.clone();","highlight_start":1,"highlight_end":41},{"text":"                    let counter = counter.clone();","highlight_start":1,"highlight_end":51},{"text":"                    let valid = valid.clone();","highlight_start":1,"highlight_end":47},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // pool.execute(move || {","highlight_start":1,"highlight_end":46},{"text":"                        let mut pairing = Pairing::new($hash_or_encode, dst);","highlight_start":1,"highlight_end":78},{"text":"                        // reconstruct input slices...","highlight_start":1,"highlight_end":55},{"text":"                        let rands = unsafe {","highlight_start":1,"highlight_end":45},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const blst_scalar>(","highlight_start":1,"highlight_end":72},{"text":"                                    raw_rands,","highlight_start":1,"highlight_end":47},{"text":"                                ),","highlight_start":1,"highlight_end":35},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                        let msgs = unsafe {","highlight_start":1,"highlight_end":44},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &[u8]>(raw_msgs),","highlight_start":1,"highlight_end":76},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                        let sigs = unsafe {","highlight_start":1,"highlight_end":44},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &Signature>(raw_sigs),","highlight_start":1,"highlight_end":81},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                        let pks = unsafe {","highlight_start":1,"highlight_end":43},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &PublicKey>(raw_pks),","highlight_start":1,"highlight_end":80},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        // TODO - engage multi-point mul-n-add for larger","highlight_start":1,"highlight_end":74},{"text":"                        // amount of inputs...","highlight_start":1,"highlight_end":47},{"text":"                        while valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":62},{"text":"                            let work = counter.fetch_add(1, Ordering::Relaxed);","highlight_start":1,"highlight_end":80},{"text":"                            if work >= n_elems {","highlight_start":1,"highlight_end":49},{"text":"                                break;","highlight_start":1,"highlight_end":39},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            if pairing.mul_n_aggregate(","highlight_start":1,"highlight_end":56},{"text":"                                &pks[work].point,","highlight_start":1,"highlight_end":50},{"text":"                                pks_validate,","highlight_start":1,"highlight_end":46},{"text":"                                &sigs[work].point,","highlight_start":1,"highlight_end":51},{"text":"                                sigs_groupcheck,","highlight_start":1,"highlight_end":49},{"text":"                                &rands[work].b,","highlight_start":1,"highlight_end":48},{"text":"                                rand_bits,","highlight_start":1,"highlight_end":43},{"text":"                                msgs[work],","highlight_start":1,"highlight_end":44},{"text":"                                &[],","highlight_start":1,"highlight_end":37},{"text":"                            ) != BLST_ERROR::BLST_SUCCESS","highlight_start":1,"highlight_end":58},{"text":"                            {","highlight_start":1,"highlight_end":30},{"text":"                                valid.store(false, Ordering::Relaxed);","highlight_start":1,"highlight_end":71},{"text":"                                break;","highlight_start":1,"highlight_end":39},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        if valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":59},{"text":"                            pairing.commit();","highlight_start":1,"highlight_end":46},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        tx.send(pairing).expect(\"disaster\");","highlight_start":1,"highlight_end":61},{"text":"                    // });","highlight_start":1,"highlight_end":27},{"text":"                //}","highlight_start":1,"highlight_end":20},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut acc = rx.recv().unwrap();","highlight_start":1,"highlight_end":50},{"text":"                //for _ in 1..n_workers {","highlight_start":1,"highlight_end":42},{"text":"                    // acc.merge(&rx.recv().unwrap());","highlight_start":1,"highlight_end":55},{"text":"                //}","highlight_start":1,"highlight_end":20},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                if valid.load(Ordering::Relaxed) && acc.finalverify(None) {","highlight_start":1,"highlight_end":76},{"text":"                    BLST_ERROR::BLST_SUCCESS","highlight_start":1,"highlight_end":45},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    BLST_ERROR::BLST_VERIFY_FAIL","highlight_start":1,"highlight_end":49},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_aggregate(agg_sig: &AggregateSignature) -> Self {","highlight_start":1,"highlight_end":74},{"text":"                let mut sig_aff = <$sig_aff>::default();","highlight_start":1,"highlight_end":57},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_to_aff(&mut sig_aff, &agg_sig.point);","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Self { point: sig_aff }","highlight_start":1,"highlight_end":40},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn compress(&self) -> [u8; $sig_comp_size] {","highlight_start":1,"highlight_end":61},{"text":"                let mut sig_comp = [0; $sig_comp_size];","highlight_start":1,"highlight_end":56},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_comp(sig_comp.as_mut_ptr(), &self.point);","highlight_start":1,"highlight_end":67},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                sig_comp","highlight_start":1,"highlight_end":25},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn serialize(&self) -> [u8; $sig_ser_size] {","highlight_start":1,"highlight_end":61},{"text":"                let mut sig_out = [0; $sig_ser_size];","highlight_start":1,"highlight_end":54},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_ser(sig_out.as_mut_ptr(), &self.point);","highlight_start":1,"highlight_end":65},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                sig_out","highlight_start":1,"highlight_end":24},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn uncompress(sig_comp: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":77},{"text":"                if sig_comp.len() == $sig_comp_size && (sig_comp[0] & 0x80) != 0","highlight_start":1,"highlight_end":81},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    let mut sig = <$sig_aff>::default();","highlight_start":1,"highlight_end":57},{"text":"                    let err =","highlight_start":1,"highlight_end":30},{"text":"                        unsafe { $sig_uncomp(&mut sig, sig_comp.as_ptr()) };","highlight_start":1,"highlight_end":77},{"text":"                    if err != BLST_ERROR::BLST_SUCCESS {","highlight_start":1,"highlight_end":57},{"text":"                        return Err(err);","highlight_start":1,"highlight_end":41},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(Self { point: sig })","highlight_start":1,"highlight_end":44},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Err(BLST_ERROR::BLST_BAD_ENCODING)","highlight_start":1,"highlight_end":55},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn deserialize(sig_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":76},{"text":"                if (sig_in.len() == $sig_ser_size && (sig_in[0] & 0x80) == 0)","highlight_start":1,"highlight_end":78},{"text":"                    || (sig_in.len() == $sig_comp_size","highlight_start":1,"highlight_end":55},{"text":"                        && (sig_in[0] & 0x80) != 0)","highlight_start":1,"highlight_end":52},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    let mut sig = <$sig_aff>::default();","highlight_start":1,"highlight_end":57},{"text":"                    let err = unsafe { $sig_deser(&mut sig, sig_in.as_ptr()) };","highlight_start":1,"highlight_end":80},{"text":"                    if err != BLST_ERROR::BLST_SUCCESS {","highlight_start":1,"highlight_end":57},{"text":"                        return Err(err);","highlight_start":1,"highlight_end":41},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(Self { point: sig })","highlight_start":1,"highlight_end":44},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Err(BLST_ERROR::BLST_BAD_ENCODING)","highlight_start":1,"highlight_end":55},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_bytes(sig_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":75},{"text":"                Signature::deserialize(sig_in)","highlight_start":1,"highlight_end":47},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_bytes(&self) -> [u8; $sig_comp_size] {","highlight_start":1,"highlight_end":61},{"text":"                self.compress()","highlight_start":1,"highlight_end":32},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn subgroup_check(&self) -> bool {","highlight_start":1,"highlight_end":51},{"text":"                unsafe { $sig_in_group(&self.point) }","highlight_start":1,"highlight_end":54},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Trait for equality comparisons which are equivalence relations.","highlight_start":1,"highlight_end":75},{"text":"        //","highlight_start":1,"highlight_end":11},{"text":"        // This means, that in addition to a == b and a != b being strict","highlight_start":1,"highlight_end":74},{"text":"        // inverses, the equality must be reflexive, symmetric and transitive.","highlight_start":1,"highlight_end":79},{"text":"        impl Eq for Signature {}","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl PartialEq for Signature {","highlight_start":1,"highlight_end":39},{"text":"            fn eq(&self, other: &Self) -> bool {","highlight_start":1,"highlight_end":49},{"text":"                unsafe { $sig_eq(&self.point, &other.point) }","highlight_start":1,"highlight_end":62},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[derive(Debug, Clone, Copy)]","highlight_start":1,"highlight_end":38},{"text":"        pub struct AggregateSignature {","highlight_start":1,"highlight_end":40},{"text":"            point: $sig,","highlight_start":1,"highlight_end":25},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl AggregateSignature {","highlight_start":1,"highlight_end":34},{"text":"            pub fn validate(&self) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":63},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    if !$sig_aggr_in_group(&self.point) {","highlight_start":1,"highlight_end":58},{"text":"                        return Err(BLST_ERROR::BLST_POINT_NOT_IN_GROUP);","highlight_start":1,"highlight_end":73},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_signature(sig: &Signature) -> Self {","highlight_start":1,"highlight_end":61},{"text":"                let mut agg_sig = <$sig>::default();","highlight_start":1,"highlight_end":53},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_from_aff(&mut agg_sig, &sig.point);","highlight_start":1,"highlight_end":61},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Self { point: agg_sig }","highlight_start":1,"highlight_end":40},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_signature(&self) -> Signature {","highlight_start":1,"highlight_end":54},{"text":"                let mut sig = <$sig_aff>::default();","highlight_start":1,"highlight_end":53},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_to_aff(&mut sig, &self.point);","highlight_start":1,"highlight_end":56},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Signature { point: sig }","highlight_start":1,"highlight_end":41},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Aggregate","highlight_start":1,"highlight_end":25},{"text":"            pub fn aggregate(","highlight_start":1,"highlight_end":30},{"text":"                sigs: &[&Signature],","highlight_start":1,"highlight_end":37},{"text":"                sigs_groupcheck: bool,","highlight_start":1,"highlight_end":39},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                if sigs.len() == 0 {","highlight_start":1,"highlight_end":37},{"text":"                    return Err(BLST_ERROR::BLST_AGGR_TYPE_MISMATCH);","highlight_start":1,"highlight_end":69},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if sigs_groupcheck {","highlight_start":1,"highlight_end":37},{"text":"                    // We can't actually judge if input is individual or","highlight_start":1,"highlight_end":73},{"text":"                    // aggregated signature, so we can't enforce infinitiy","highlight_start":1,"highlight_end":75},{"text":"                    // check.","highlight_start":1,"highlight_end":30},{"text":"                    sigs[0].validate(false)?;","highlight_start":1,"highlight_end":46},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut agg_sig = AggregateSignature::from_signature(sigs[0]);","highlight_start":1,"highlight_end":79},{"text":"                for s in sigs.iter().skip(1) {","highlight_start":1,"highlight_end":47},{"text":"                    if sigs_groupcheck {","highlight_start":1,"highlight_end":41},{"text":"                        s.validate(false)?;","highlight_start":1,"highlight_end":44},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        $sig_add_or_dbl_aff(","highlight_start":1,"highlight_end":45},{"text":"                            &mut agg_sig.point,","highlight_start":1,"highlight_end":48},{"text":"                            &agg_sig.point,","highlight_start":1,"highlight_end":44},{"text":"                            &s.point,","highlight_start":1,"highlight_end":38},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(agg_sig)","highlight_start":1,"highlight_end":28},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn aggregate_serialized(","highlight_start":1,"highlight_end":41},{"text":"                sigs: &[&[u8]],","highlight_start":1,"highlight_end":32},{"text":"                sigs_groupcheck: bool,","highlight_start":1,"highlight_end":39},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                // TODO - threading","highlight_start":1,"highlight_end":36},{"text":"                if sigs.len() == 0 {","highlight_start":1,"highlight_end":37},{"text":"                    return Err(BLST_ERROR::BLST_AGGR_TYPE_MISMATCH);","highlight_start":1,"highlight_end":69},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut sig = if sigs_groupcheck {","highlight_start":1,"highlight_end":51},{"text":"                    Signature::sig_validate(sigs[0], false)?","highlight_start":1,"highlight_end":61},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Signature::from_bytes(sigs[0])?","highlight_start":1,"highlight_end":52},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut agg_sig = AggregateSignature::from_signature(&sig);","highlight_start":1,"highlight_end":76},{"text":"                for s in sigs.iter().skip(1) {","highlight_start":1,"highlight_end":47},{"text":"                    sig = if sigs_groupcheck {","highlight_start":1,"highlight_end":47},{"text":"                        Signature::sig_validate(s, false)?","highlight_start":1,"highlight_end":59},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        Signature::from_bytes(s)?","highlight_start":1,"highlight_end":50},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        $sig_add_or_dbl_aff(","highlight_start":1,"highlight_end":45},{"text":"                            &mut agg_sig.point,","highlight_start":1,"highlight_end":48},{"text":"                            &agg_sig.point,","highlight_start":1,"highlight_end":44},{"text":"                            &sig.point,","highlight_start":1,"highlight_end":40},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(agg_sig)","highlight_start":1,"highlight_end":28},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn add_aggregate(&mut self, agg_sig: &AggregateSignature) {","highlight_start":1,"highlight_end":76},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_add_or_dbl(","highlight_start":1,"highlight_end":37},{"text":"                        &mut self.point,","highlight_start":1,"highlight_end":41},{"text":"                        &self.point,","highlight_start":1,"highlight_end":37},{"text":"                        &agg_sig.point,","highlight_start":1,"highlight_end":40},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn add_signature(","highlight_start":1,"highlight_end":34},{"text":"                &mut self,","highlight_start":1,"highlight_end":27},{"text":"                sig: &Signature,","highlight_start":1,"highlight_end":33},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"            ) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":42},{"text":"                if sig_groupcheck {","highlight_start":1,"highlight_end":36},{"text":"                    sig.validate(false)?;","highlight_start":1,"highlight_end":42},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_add_or_dbl_aff(","highlight_start":1,"highlight_end":41},{"text":"                        &mut self.point,","highlight_start":1,"highlight_end":41},{"text":"                        &self.point,","highlight_start":1,"highlight_end":37},{"text":"                        &sig.point,","highlight_start":1,"highlight_end":36},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn subgroup_check(&self) -> bool {","highlight_start":1,"highlight_end":51},{"text":"                unsafe { $sig_aggr_in_group(&self.point) }","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[cfg(test)]","highlight_start":1,"highlight_end":21},{"text":"        mod tests {","highlight_start":1,"highlight_end":20},{"text":"            use super::*;","highlight_start":1,"highlight_end":26},{"text":"            use rand::{RngCore, SeedableRng};","highlight_start":1,"highlight_end":46},{"text":"            use rand_chacha::ChaCha20Rng;","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Testing only - do not use for production","highlight_start":1,"highlight_end":56},{"text":"            pub fn gen_random_key(","highlight_start":1,"highlight_end":35},{"text":"                rng: &mut rand_chacha::ChaCha20Rng,","highlight_start":1,"highlight_end":52},{"text":"            ) -> SecretKey {","highlight_start":1,"highlight_end":29},{"text":"                let mut ikm = [0u8; 32];","highlight_start":1,"highlight_end":41},{"text":"                rng.fill_bytes(&mut ikm);","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut sk = <blst_scalar>::default();","highlight_start":1,"highlight_end":55},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    blst_keygen(&mut sk, ikm.as_ptr(), 32, ptr::null(), 0);","highlight_start":1,"highlight_end":76},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                SecretKey { value: sk }","highlight_start":1,"highlight_end":40},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[test]","highlight_start":1,"highlight_end":20},{"text":"            fn test_sign() {","highlight_start":1,"highlight_end":29},{"text":"                let ikm: [u8; 32] = [","highlight_start":1,"highlight_end":38},{"text":"                    0x93, 0xad, 0x7e, 0x65, 0xde, 0xad, 0x05, 0x2a, 0x08, 0x3a,","highlight_start":1,"highlight_end":80},{"text":"                    0x91, 0x0c, 0x8b, 0x72, 0x85, 0x91, 0x46, 0x4c, 0xca, 0x56,","highlight_start":1,"highlight_end":80},{"text":"                    0x60, 0x5b, 0xb0, 0x56, 0xed, 0xfe, 0x2b, 0x60, 0xa6, 0x3c,","highlight_start":1,"highlight_end":80},{"text":"                    0x48, 0x99,","highlight_start":1,"highlight_end":32},{"text":"                ];","highlight_start":1,"highlight_end":19},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sk = SecretKey::key_gen(&ikm, &[]).unwrap();","highlight_start":1,"highlight_end":65},{"text":"                let pk = sk.sk_to_pk();","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let dst = b\"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_\";","highlight_start":1,"highlight_end":74},{"text":"                let msg = b\"hello foo\";","highlight_start":1,"highlight_end":40},{"text":"                let sig = sk.sign(msg, dst, &[]);","highlight_start":1,"highlight_end":50},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let err = sig.verify(true, msg, dst, &[], &pk, true);","highlight_start":1,"highlight_end":70},{"text":"                assert_eq!(err, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[test]","highlight_start":1,"highlight_end":20},{"text":"            fn test_aggregate() {","highlight_start":1,"highlight_end":34},{"text":"                let num_msgs = 10;","highlight_start":1,"highlight_end":35},{"text":"                let dst = b\"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_\";","highlight_start":1,"highlight_end":74},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let seed = [0u8; 32];","highlight_start":1,"highlight_end":38},{"text":"                let mut rng = ChaCha20Rng::from_seed(seed);","highlight_start":1,"highlight_end":60},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sks: Vec<_> =","highlight_start":1,"highlight_end":34},{"text":"                    (0..num_msgs).map(|_| gen_random_key(&mut rng)).collect();","highlight_start":1,"highlight_end":79},{"text":"                let pks =","highlight_start":1,"highlight_end":26},{"text":"                    sks.iter().map(|sk| sk.sk_to_pk()).collect::<Vec<_>>();","highlight_start":1,"highlight_end":76},{"text":"                let pks_refs: Vec<&PublicKey> =","highlight_start":1,"highlight_end":48},{"text":"                    pks.iter().map(|pk| pk).collect();","highlight_start":1,"highlight_end":55},{"text":"                let pks_rev: Vec<&PublicKey> =","highlight_start":1,"highlight_end":47},{"text":"                    pks.iter().rev().map(|pk| pk).collect();","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_comp = pks[0].compress();","highlight_start":1,"highlight_end":49},{"text":"                let pk_uncomp = PublicKey::uncompress(&pk_comp);","highlight_start":1,"highlight_end":65},{"text":"                assert_eq!(pk_uncomp.is_ok(), true);","highlight_start":1,"highlight_end":53},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut msgs: Vec<Vec<u8>> = vec![vec![]; num_msgs];","highlight_start":1,"highlight_end":69},{"text":"                for i in 0..num_msgs {","highlight_start":1,"highlight_end":39},{"text":"                    let msg_len = (rng.next_u64() & 0x3F) + 1;","highlight_start":1,"highlight_end":63},{"text":"                    msgs[i] = vec![0u8; msg_len as usize];","highlight_start":1,"highlight_end":59},{"text":"                    rng.fill_bytes(&mut msgs[i]);","highlight_start":1,"highlight_end":50},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let msgs_refs: Vec<&[u8]> =","highlight_start":1,"highlight_end":44},{"text":"                    msgs.iter().map(|m| m.as_slice()).collect();","highlight_start":1,"highlight_end":65},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sigs = sks","highlight_start":1,"highlight_end":31},{"text":"                    .iter()","highlight_start":1,"highlight_end":28},{"text":"                    .zip(msgs.iter())","highlight_start":1,"highlight_end":38},{"text":"                    .map(|(sk, m)| (sk.sign(m, dst, &[])))","highlight_start":1,"highlight_end":59},{"text":"                    .collect::<Vec<Signature>>();","highlight_start":1,"highlight_end":50},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut errs = sigs","highlight_start":1,"highlight_end":36},{"text":"                    .iter()","highlight_start":1,"highlight_end":28},{"text":"                    .zip(msgs.iter())","highlight_start":1,"highlight_end":38},{"text":"                    .zip(pks.iter())","highlight_start":1,"highlight_end":37},{"text":"                    .map(|((s, m), pk)| (s.verify(true, m, dst, &[], pk, true)))","highlight_start":1,"highlight_end":81},{"text":"                    .collect::<Vec<BLST_ERROR>>();","highlight_start":1,"highlight_end":51},{"text":"                assert_eq!(errs, vec![BLST_ERROR::BLST_SUCCESS; num_msgs]);","highlight_start":1,"highlight_end":76},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Swap message/public key pairs to create bad signature","highlight_start":1,"highlight_end":73},{"text":"                errs = sigs","highlight_start":1,"highlight_end":28},{"text":"                    .iter()","highlight_start":1,"highlight_end":28},{"text":"                    .zip(msgs.iter())","highlight_start":1,"highlight_end":38},{"text":"                    .zip(pks.iter().rev())","highlight_start":1,"highlight_end":43},{"text":"                    .map(|((s, m), pk)| (s.verify(true, m, dst, &[], pk, true)))","highlight_start":1,"highlight_end":81},{"text":"                    .collect::<Vec<BLST_ERROR>>();","highlight_start":1,"highlight_end":51},{"text":"                assert_ne!(errs, vec![BLST_ERROR::BLST_SUCCESS; num_msgs]);","highlight_start":1,"highlight_end":76},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sig_refs =","highlight_start":1,"highlight_end":31},{"text":"                    sigs.iter().map(|s| s).collect::<Vec<&Signature>>();","highlight_start":1,"highlight_end":73},{"text":"                let agg = match AggregateSignature::aggregate(&sig_refs, true) {","highlight_start":1,"highlight_end":81},{"text":"                    Ok(agg) => agg,","highlight_start":1,"highlight_end":36},{"text":"                    Err(err) => panic!(\"aggregate failure: {:?}\", err),","highlight_start":1,"highlight_end":72},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let agg_sig = agg.to_signature();","highlight_start":1,"highlight_end":50},{"text":"                let mut result = agg_sig","highlight_start":1,"highlight_end":41},{"text":"                    .aggregate_verify(false, &msgs_refs, dst, &pks_refs, false);","highlight_start":1,"highlight_end":81},{"text":"                assert_eq!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Swap message/public key pairs to create bad signature","highlight_start":1,"highlight_end":73},{"text":"                result = agg_sig","highlight_start":1,"highlight_end":33},{"text":"                    .aggregate_verify(false, &msgs_refs, dst, &pks_rev, false);","highlight_start":1,"highlight_end":80},{"text":"                assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[test]","highlight_start":1,"highlight_end":20},{"text":"            fn test_multiple_agg_sigs() {","highlight_start":1,"highlight_end":42},{"text":"                let dst = b\"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_\";","highlight_start":1,"highlight_end":74},{"text":"                let num_pks_per_sig = 10;","highlight_start":1,"highlight_end":42},{"text":"                let num_sigs = 10;","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let seed = [0u8; 32];","highlight_start":1,"highlight_end":38},{"text":"                let mut rng = ChaCha20Rng::from_seed(seed);","highlight_start":1,"highlight_end":60},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut msgs: Vec<Vec<u8>> = vec![vec![]; num_sigs];","highlight_start":1,"highlight_end":69},{"text":"                let mut sigs: Vec<Signature> = Vec::with_capacity(num_sigs);","highlight_start":1,"highlight_end":77},{"text":"                let mut pks: Vec<PublicKey> = Vec::with_capacity(num_sigs);","highlight_start":1,"highlight_end":76},{"text":"                let mut rands: Vec<blst_scalar> = Vec::with_capacity(num_sigs);","highlight_start":1,"highlight_end":80},{"text":"                for i in 0..num_sigs {","highlight_start":1,"highlight_end":39},{"text":"                    // Create public keys","highlight_start":1,"highlight_end":42},{"text":"                    let sks_i: Vec<_> = (0..num_pks_per_sig)","highlight_start":1,"highlight_end":61},{"text":"                        .map(|_| gen_random_key(&mut rng))","highlight_start":1,"highlight_end":59},{"text":"                        .collect();","highlight_start":1,"highlight_end":36},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let pks_i = sks_i","highlight_start":1,"highlight_end":38},{"text":"                        .iter()","highlight_start":1,"highlight_end":32},{"text":"                        .map(|sk| sk.sk_to_pk())","highlight_start":1,"highlight_end":49},{"text":"                        .collect::<Vec<_>>();","highlight_start":1,"highlight_end":46},{"text":"                    let pks_refs_i: Vec<&PublicKey> =","highlight_start":1,"highlight_end":54},{"text":"                        pks_i.iter().map(|pk| pk).collect();","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Create random message for pks to all sign","highlight_start":1,"highlight_end":65},{"text":"                    let msg_len = (rng.next_u64() & 0x3F) + 1;","highlight_start":1,"highlight_end":63},{"text":"                    msgs[i] = vec![0u8; msg_len as usize];","highlight_start":1,"highlight_end":59},{"text":"                    rng.fill_bytes(&mut msgs[i]);","highlight_start":1,"highlight_end":50},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Generate signature for each key pair","highlight_start":1,"highlight_end":60},{"text":"                    let sigs_i = sks_i","highlight_start":1,"highlight_end":39},{"text":"                        .iter()","highlight_start":1,"highlight_end":32},{"text":"                        .map(|sk| sk.sign(&msgs[i], dst, &[]))","highlight_start":1,"highlight_end":63},{"text":"                        .collect::<Vec<Signature>>();","highlight_start":1,"highlight_end":54},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Test each current single signature","highlight_start":1,"highlight_end":58},{"text":"                    let errs = sigs_i","highlight_start":1,"highlight_end":38},{"text":"                        .iter()","highlight_start":1,"highlight_end":32},{"text":"                        .zip(pks_i.iter())","highlight_start":1,"highlight_end":43},{"text":"                        .map(|(s, pk)| {","highlight_start":1,"highlight_end":41},{"text":"                            (s.verify(true, &msgs[i], dst, &[], pk, true))","highlight_start":1,"highlight_end":75},{"text":"                        })","highlight_start":1,"highlight_end":27},{"text":"                        .collect::<Vec<BLST_ERROR>>();","highlight_start":1,"highlight_end":55},{"text":"                    assert_eq!(","highlight_start":1,"highlight_end":32},{"text":"                        errs,","highlight_start":1,"highlight_end":30},{"text":"                        vec![BLST_ERROR::BLST_SUCCESS; num_pks_per_sig]","highlight_start":1,"highlight_end":72},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let sig_refs_i =","highlight_start":1,"highlight_end":37},{"text":"                        sigs_i.iter().map(|s| s).collect::<Vec<&Signature>>();","highlight_start":1,"highlight_end":79},{"text":"                    let agg_i =","highlight_start":1,"highlight_end":32},{"text":"                        match AggregateSignature::aggregate(&sig_refs_i, false)","highlight_start":1,"highlight_end":80},{"text":"                        {","highlight_start":1,"highlight_end":26},{"text":"                            Ok(agg_i) => agg_i,","highlight_start":1,"highlight_end":48},{"text":"                            Err(err) => panic!(\"aggregate failure: {:?}\", err),","highlight_start":1,"highlight_end":80},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Test current aggregate signature","highlight_start":1,"highlight_end":56},{"text":"                    sigs.push(agg_i.to_signature());","highlight_start":1,"highlight_end":53},{"text":"                    let mut result = sigs[i].fast_aggregate_verify(","highlight_start":1,"highlight_end":68},{"text":"                        false,","highlight_start":1,"highlight_end":31},{"text":"                        &msgs[i],","highlight_start":1,"highlight_end":34},{"text":"                        dst,","highlight_start":1,"highlight_end":29},{"text":"                        &pks_refs_i,","highlight_start":1,"highlight_end":37},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                    assert_eq!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":66},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // negative test","highlight_start":1,"highlight_end":37},{"text":"                    if i != 0 {","highlight_start":1,"highlight_end":32},{"text":"                        result = sigs[i - 1].fast_aggregate_verify(","highlight_start":1,"highlight_end":68},{"text":"                            false,","highlight_start":1,"highlight_end":35},{"text":"                            &msgs[i],","highlight_start":1,"highlight_end":38},{"text":"                            dst,","highlight_start":1,"highlight_end":33},{"text":"                            &pks_refs_i,","highlight_start":1,"highlight_end":41},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                        assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":70},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // aggregate public keys and push into vec","highlight_start":1,"highlight_end":63},{"text":"                    let agg_pk_i =","highlight_start":1,"highlight_end":35},{"text":"                        match AggregatePublicKey::aggregate(&pks_refs_i, false)","highlight_start":1,"highlight_end":80},{"text":"                        {","highlight_start":1,"highlight_end":26},{"text":"                            Ok(agg_pk_i) => agg_pk_i,","highlight_start":1,"highlight_end":54},{"text":"                            Err(err) => panic!(\"aggregate failure: {:?}\", err),","highlight_start":1,"highlight_end":80},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                    pks.push(agg_pk_i.to_public_key());","highlight_start":1,"highlight_end":56},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Test current aggregate signature with aggregated pks","highlight_start":1,"highlight_end":76},{"text":"                    result = sigs[i].fast_aggregate_verify_pre_aggregated(","highlight_start":1,"highlight_end":75},{"text":"                        false, &msgs[i], dst, &pks[i],","highlight_start":1,"highlight_end":55},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                    assert_eq!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":66},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // negative test","highlight_start":1,"highlight_end":37},{"text":"                    if i != 0 {","highlight_start":1,"highlight_end":32},{"text":"                        result = sigs[i - 1]","highlight_start":1,"highlight_end":45},{"text":"                            .fast_aggregate_verify_pre_aggregated(","highlight_start":1,"highlight_end":67},{"text":"                                false, &msgs[i], dst, &pks[i],","highlight_start":1,"highlight_end":63},{"text":"                            );","highlight_start":1,"highlight_end":31},{"text":"                        assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":70},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // create random values","highlight_start":1,"highlight_end":44},{"text":"                    let mut vals = [0u64; 4];","highlight_start":1,"highlight_end":46},{"text":"                    vals[0] = rng.next_u64();","highlight_start":1,"highlight_end":46},{"text":"                    while vals[0] == 0 {","highlight_start":1,"highlight_end":41},{"text":"                        // Reject zero as it is used for multiplication.","highlight_start":1,"highlight_end":73},{"text":"                        vals[0] = rng.next_u64();","highlight_start":1,"highlight_end":50},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    let mut rand_i =","highlight_start":1,"highlight_end":37},{"text":"                        std::mem::MaybeUninit::<blst_scalar>::uninit();","highlight_start":1,"highlight_end":72},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        blst_scalar_from_uint64(","highlight_start":1,"highlight_end":49},{"text":"                            rand_i.as_mut_ptr(),","highlight_start":1,"highlight_end":49},{"text":"                            vals.as_ptr(),","highlight_start":1,"highlight_end":43},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                        rands.push(rand_i.assume_init());","highlight_start":1,"highlight_end":58},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let msgs_refs: Vec<&[u8]> =","highlight_start":1,"highlight_end":44},{"text":"                    msgs.iter().map(|m| m.as_slice()).collect();","highlight_start":1,"highlight_end":65},{"text":"                let sig_refs =","highlight_start":1,"highlight_end":31},{"text":"                    sigs.iter().map(|s| s).collect::<Vec<&Signature>>();","highlight_start":1,"highlight_end":73},{"text":"                let pks_refs: Vec<&PublicKey> =","highlight_start":1,"highlight_end":48},{"text":"                    pks.iter().map(|pk| pk).collect();","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let msgs_rev: Vec<&[u8]> =","highlight_start":1,"highlight_end":43},{"text":"                    msgs.iter().rev().map(|m| m.as_slice()).collect();","highlight_start":1,"highlight_end":71},{"text":"                let sig_rev =","highlight_start":1,"highlight_end":30},{"text":"                    sigs.iter().rev().map(|s| s).collect::<Vec<&Signature>>();","highlight_start":1,"highlight_end":79},{"text":"                let pks_rev: Vec<&PublicKey> =","highlight_start":1,"highlight_end":47},{"text":"                    pks.iter().rev().map(|pk| pk).collect();","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut result =","highlight_start":1,"highlight_end":33},{"text":"                    Signature::verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":69},{"text":"                        &msgs_refs, dst, &pks_refs, false, &sig_refs, true,","highlight_start":1,"highlight_end":76},{"text":"                        &rands, 64,","highlight_start":1,"highlight_end":36},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                assert_eq!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // negative tests (use reverse msgs, pks, and sigs)","highlight_start":1,"highlight_end":68},{"text":"                result = Signature::verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":74},{"text":"                    &msgs_rev, dst, &pks_refs, false, &sig_refs, true, &rands,","highlight_start":1,"highlight_end":79},{"text":"                    64,","highlight_start":1,"highlight_end":24},{"text":"                );","highlight_start":1,"highlight_end":19},{"text":"                assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                result = Signature::verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":74},{"text":"                    &msgs_refs, dst, &pks_rev, false, &sig_refs, true, &rands,","highlight_start":1,"highlight_end":79},{"text":"                    64,","highlight_start":1,"highlight_end":24},{"text":"                );","highlight_start":1,"highlight_end":19},{"text":"                assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                result = Signature::verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":74},{"text":"                    &msgs_refs, dst, &pks_refs, false, &sig_rev, true, &rands,","highlight_start":1,"highlight_end":79},{"text":"                    64,","highlight_start":1,"highlight_end":24},{"text":"                );","highlight_start":1,"highlight_end":19},{"text":"                assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[test]","highlight_start":1,"highlight_end":20},{"text":"            fn test_serialization() {","highlight_start":1,"highlight_end":38},{"text":"                let seed = [0u8; 32];","highlight_start":1,"highlight_end":38},{"text":"                let mut rng = ChaCha20Rng::from_seed(seed);","highlight_start":1,"highlight_end":60},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sk = gen_random_key(&mut rng);","highlight_start":1,"highlight_end":51},{"text":"                let sk2 = gen_random_key(&mut rng);","highlight_start":1,"highlight_end":52},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk = sk.sk_to_pk();","highlight_start":1,"highlight_end":40},{"text":"                let pk_comp = pk.compress();","highlight_start":1,"highlight_end":45},{"text":"                let pk_ser = pk.serialize();","highlight_start":1,"highlight_end":45},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_uncomp = PublicKey::uncompress(&pk_comp);","highlight_start":1,"highlight_end":65},{"text":"                assert_eq!(pk_uncomp.is_ok(), true);","highlight_start":1,"highlight_end":53},{"text":"                assert_eq!(pk_uncomp.unwrap(), pk);","highlight_start":1,"highlight_end":52},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_deser = PublicKey::deserialize(&pk_ser);","highlight_start":1,"highlight_end":64},{"text":"                assert_eq!(pk_deser.is_ok(), true);","highlight_start":1,"highlight_end":52},{"text":"                assert_eq!(pk_deser.unwrap(), pk);","highlight_start":1,"highlight_end":51},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk2 = sk2.sk_to_pk();","highlight_start":1,"highlight_end":42},{"text":"                let pk_comp2 = pk2.compress();","highlight_start":1,"highlight_end":47},{"text":"                let pk_ser2 = pk2.serialize();","highlight_start":1,"highlight_end":47},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_uncomp2 = PublicKey::uncompress(&pk_comp2);","highlight_start":1,"highlight_end":67},{"text":"                assert_eq!(pk_uncomp2.is_ok(), true);","highlight_start":1,"highlight_end":54},{"text":"                assert_eq!(pk_uncomp2.unwrap(), pk2);","highlight_start":1,"highlight_end":54},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_deser2 = PublicKey::deserialize(&pk_ser2);","highlight_start":1,"highlight_end":66},{"text":"                assert_eq!(pk_deser2.is_ok(), true);","highlight_start":1,"highlight_end":53},{"text":"                assert_eq!(pk_deser2.unwrap(), pk2);","highlight_start":1,"highlight_end":53},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                assert_ne!(pk, pk2);","highlight_start":1,"highlight_end":37},{"text":"                assert_ne!(pk_uncomp.unwrap(), pk2);","highlight_start":1,"highlight_end":53},{"text":"                assert_ne!(pk_deser.unwrap(), pk2);","highlight_start":1,"highlight_end":52},{"text":"                assert_ne!(pk_uncomp2.unwrap(), pk);","highlight_start":1,"highlight_end":53},{"text":"                assert_ne!(pk_deser2.unwrap(), pk);","highlight_start":1,"highlight_end":52},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"remove this `mut`","code":null,"level":"help","spans":[{"file_name":"/home/azureuser/blst/bindings/rust/src/lib.rs","byte_start":31357,"byte_end":31361,"line_start":935,"line_end":935,"column_start":21,"column_end":25,"is_primary":true,"text":[{"text":"                let mut acc = rx.recv().unwrap();","highlight_start":21,"highlight_end":25}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"/home/azureuser/blst/bindings/rust/src/lib.rs","byte_start":53005,"byte_end":54021,"line_start":1516,"line_end":1554,"column_start":5,"column_end":7,"is_primary":false,"text":[{"text":"    sig_variant_impl!(","highlight_start":5,"highlight_end":23},{"text":"        \"MinSig\",","highlight_start":1,"highlight_end":18},{"text":"        blst_p2,","highlight_start":1,"highlight_end":17},{"text":"        blst_p2_affine,","highlight_start":1,"highlight_end":24},{"text":"        blst_p1,","highlight_start":1,"highlight_end":17},{"text":"        blst_p1_affine,","highlight_start":1,"highlight_end":24},{"text":"        blst_sk_to_pk2_in_g2,","highlight_start":1,"highlight_end":30},{"text":"        true,","highlight_start":1,"highlight_end":14},{"text":"        blst_hash_to_g1,","highlight_start":1,"highlight_end":25},{"text":"        blst_sign_pk2_in_g2,","highlight_start":1,"highlight_end":29},{"text":"        blst_p2_affine_is_equal,","highlight_start":1,"highlight_end":33},{"text":"        blst_p1_affine_is_equal,","highlight_start":1,"highlight_end":33},{"text":"        blst_core_verify_pk_in_g2,","highlight_start":1,"highlight_end":35},{"text":"        blst_p2_affine_in_g2,","highlight_start":1,"highlight_end":30},{"text":"        blst_p2_to_affine,","highlight_start":1,"highlight_end":27},{"text":"        blst_p2_from_affine,","highlight_start":1,"highlight_end":29},{"text":"        blst_p2_affine_serialize,","highlight_start":1,"highlight_end":34},{"text":"        blst_p2_affine_compress,","highlight_start":1,"highlight_end":33},{"text":"        blst_p2_deserialize,","highlight_start":1,"highlight_end":29},{"text":"        blst_p2_uncompress,","highlight_start":1,"highlight_end":28},{"text":"        96,","highlight_start":1,"highlight_end":12},{"text":"        192,","highlight_start":1,"highlight_end":13},{"text":"        blst_p1_affine_in_g1,","highlight_start":1,"highlight_end":30},{"text":"        blst_p1_to_affine,","highlight_start":1,"highlight_end":27},{"text":"        blst_p1_from_affine,","highlight_start":1,"highlight_end":29},{"text":"        blst_p1_affine_serialize,","highlight_start":1,"highlight_end":34},{"text":"        blst_p1_affine_compress,","highlight_start":1,"highlight_end":33},{"text":"        blst_p1_deserialize,","highlight_start":1,"highlight_end":29},{"text":"        blst_p1_uncompress,","highlight_start":1,"highlight_end":28},{"text":"        48,","highlight_start":1,"highlight_end":12},{"text":"        96,","highlight_start":1,"highlight_end":12},{"text":"        blst_p2_add_or_double,","highlight_start":1,"highlight_end":31},{"text":"        blst_p2_add_or_double_affine,","highlight_start":1,"highlight_end":38},{"text":"        blst_p1_add_or_double,","highlight_start":1,"highlight_end":31},{"text":"        blst_p1_add_or_double_affine,","highlight_start":1,"highlight_end":38},{"text":"        blst_p2_affine_is_inf,","highlight_start":1,"highlight_end":31},{"text":"        blst_p1_affine_is_inf,","highlight_start":1,"highlight_end":31},{"text":"        blst_p1_in_g1,","highlight_start":1,"highlight_end":23},{"text":"    );","highlight_start":1,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"sig_variant_impl!","def_site_span":{"file_name":"/home/azureuser/blst/bindings/rust/src/lib.rs","byte_start":7790,"byte_end":51903,"line_start":283,"line_end":1467,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! sig_variant_impl {","highlight_start":1,"highlight_end":32},{"text":"    (","highlight_start":1,"highlight_end":6},{"text":"        $name:expr,","highlight_start":1,"highlight_end":20},{"text":"        $pk:ty,","highlight_start":1,"highlight_end":16},{"text":"        $pk_aff:ty,","highlight_start":1,"highlight_end":20},{"text":"        $sig:ty,","highlight_start":1,"highlight_end":17},{"text":"        $sig_aff:ty,","highlight_start":1,"highlight_end":21},{"text":"        $sk_to_pk:ident,","highlight_start":1,"highlight_end":25},{"text":"        $hash_or_encode:expr,","highlight_start":1,"highlight_end":30},{"text":"        $hash_or_encode_to:ident,","highlight_start":1,"highlight_end":34},{"text":"        $sign:ident,","highlight_start":1,"highlight_end":21},{"text":"        $pk_eq:ident,","highlight_start":1,"highlight_end":22},{"text":"        $sig_eq:ident,","highlight_start":1,"highlight_end":23},{"text":"        $verify:ident,","highlight_start":1,"highlight_end":23},{"text":"        $pk_in_group:ident,","highlight_start":1,"highlight_end":28},{"text":"        $pk_to_aff:ident,","highlight_start":1,"highlight_end":26},{"text":"        $pk_from_aff:ident,","highlight_start":1,"highlight_end":28},{"text":"        $pk_ser:ident,","highlight_start":1,"highlight_end":23},{"text":"        $pk_comp:ident,","highlight_start":1,"highlight_end":24},{"text":"        $pk_deser:ident,","highlight_start":1,"highlight_end":25},{"text":"        $pk_uncomp:ident,","highlight_start":1,"highlight_end":26},{"text":"        $pk_comp_size:expr,","highlight_start":1,"highlight_end":28},{"text":"        $pk_ser_size:expr,","highlight_start":1,"highlight_end":27},{"text":"        $sig_in_group:ident,","highlight_start":1,"highlight_end":29},{"text":"        $sig_to_aff:ident,","highlight_start":1,"highlight_end":27},{"text":"        $sig_from_aff:ident,","highlight_start":1,"highlight_end":29},{"text":"        $sig_ser:ident,","highlight_start":1,"highlight_end":24},{"text":"        $sig_comp:ident,","highlight_start":1,"highlight_end":25},{"text":"        $sig_deser:ident,","highlight_start":1,"highlight_end":26},{"text":"        $sig_uncomp:ident,","highlight_start":1,"highlight_end":27},{"text":"        $sig_comp_size:expr,","highlight_start":1,"highlight_end":29},{"text":"        $sig_ser_size:expr,","highlight_start":1,"highlight_end":28},{"text":"        $pk_add_or_dbl:ident,","highlight_start":1,"highlight_end":30},{"text":"        $pk_add_or_dbl_aff:ident,","highlight_start":1,"highlight_end":34},{"text":"        $sig_add_or_dbl:ident,","highlight_start":1,"highlight_end":31},{"text":"        $sig_add_or_dbl_aff:ident,","highlight_start":1,"highlight_end":35},{"text":"        $pk_is_inf:ident,","highlight_start":1,"highlight_end":26},{"text":"        $sig_is_inf:ident,","highlight_start":1,"highlight_end":27},{"text":"        $sig_aggr_in_group:ident,","highlight_start":1,"highlight_end":34},{"text":"    ) => {","highlight_start":1,"highlight_end":11},{"text":"        /// Secret Key","highlight_start":1,"highlight_end":23},{"text":"        #[derive(Default, Debug, Clone, Zeroize)]","highlight_start":1,"highlight_end":50},{"text":"        #[zeroize(drop)]","highlight_start":1,"highlight_end":25},{"text":"        pub struct SecretKey {","highlight_start":1,"highlight_end":31},{"text":"            value: blst_scalar,","highlight_start":1,"highlight_end":32},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl SecretKey {","highlight_start":1,"highlight_end":25},{"text":"            /// Deterministically generate a secret key from key material","highlight_start":1,"highlight_end":74},{"text":"            pub fn key_gen(","highlight_start":1,"highlight_end":28},{"text":"                ikm: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                key_info: &[u8],","highlight_start":1,"highlight_end":33},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                if ikm.len() < 32 {","highlight_start":1,"highlight_end":36},{"text":"                    return Err(BLST_ERROR::BLST_BAD_ENCODING);","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut sk = SecretKey::default();","highlight_start":1,"highlight_end":51},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    blst_keygen(","highlight_start":1,"highlight_end":33},{"text":"                        &mut sk.value,","highlight_start":1,"highlight_end":39},{"text":"                        ikm.as_ptr(),","highlight_start":1,"highlight_end":38},{"text":"                        ikm.len(),","highlight_start":1,"highlight_end":35},{"text":"                        key_info.as_ptr(),","highlight_start":1,"highlight_end":43},{"text":"                        key_info.len(),","highlight_start":1,"highlight_end":40},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(sk)","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // sk_to_pk","highlight_start":1,"highlight_end":24},{"text":"            pub fn sk_to_pk(&self) -> PublicKey {","highlight_start":1,"highlight_end":50},{"text":"                // TODO - would the user like the serialized/compressed pk as well?","highlight_start":1,"highlight_end":84},{"text":"                let mut pk_aff = PublicKey::default();","highlight_start":1,"highlight_end":55},{"text":"                //let mut pk_ser = [0u8; $pk_ser_size];","highlight_start":1,"highlight_end":56},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sk_to_pk(","highlight_start":1,"highlight_end":31},{"text":"                        //pk_ser.as_mut_ptr(),","highlight_start":1,"highlight_end":47},{"text":"                        ptr::null_mut(),","highlight_start":1,"highlight_end":41},{"text":"                        &mut pk_aff.point,","highlight_start":1,"highlight_end":43},{"text":"                        &self.value,","highlight_start":1,"highlight_end":37},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                pk_aff","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Sign","highlight_start":1,"highlight_end":20},{"text":"            pub fn sign(","highlight_start":1,"highlight_end":25},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                msg: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                aug: &[u8],","highlight_start":1,"highlight_end":28},{"text":"            ) -> Signature {","highlight_start":1,"highlight_end":29},{"text":"                // TODO - would the user like the serialized/compressed sig as well?","highlight_start":1,"highlight_end":85},{"text":"                let mut q = <$sig>::default();","highlight_start":1,"highlight_end":47},{"text":"                let mut sig_aff = <$sig_aff>::default();","highlight_start":1,"highlight_end":57},{"text":"                //let mut sig_ser = [0u8; $sig_ser_size];","highlight_start":1,"highlight_end":58},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $hash_or_encode_to(","highlight_start":1,"highlight_end":40},{"text":"                        &mut q,","highlight_start":1,"highlight_end":32},{"text":"                        msg.as_ptr(),","highlight_start":1,"highlight_end":38},{"text":"                        msg.len(),","highlight_start":1,"highlight_end":35},{"text":"                        dst.as_ptr(),","highlight_start":1,"highlight_end":38},{"text":"                        dst.len(),","highlight_start":1,"highlight_end":35},{"text":"                        aug.as_ptr(),","highlight_start":1,"highlight_end":38},{"text":"                        aug.len(),","highlight_start":1,"highlight_end":35},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                    $sign(ptr::null_mut(), &mut sig_aff, &q, &self.value);","highlight_start":1,"highlight_end":75},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Signature { point: sig_aff }","highlight_start":1,"highlight_end":45},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // TODO - formally speaking application is entitled to have","highlight_start":1,"highlight_end":72},{"text":"            // ultimate control over secret key storage, which means that","highlight_start":1,"highlight_end":74},{"text":"            // corresponding serialization/deserialization subroutines","highlight_start":1,"highlight_end":71},{"text":"            // should accept reference to where to store the result, as","highlight_start":1,"highlight_end":72},{"text":"            // opposite to returning one.","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // serialize","highlight_start":1,"highlight_end":25},{"text":"            pub fn serialize(&self) -> [u8; 32] {","highlight_start":1,"highlight_end":50},{"text":"                let mut sk_out = [0; 32];","highlight_start":1,"highlight_end":42},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    blst_bendian_from_scalar(sk_out.as_mut_ptr(), &self.value);","highlight_start":1,"highlight_end":80},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                sk_out","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // deserialize","highlight_start":1,"highlight_end":27},{"text":"            pub fn deserialize(sk_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":75},{"text":"                let mut sk = blst_scalar::default();","highlight_start":1,"highlight_end":53},{"text":"                if sk_in.len() != 32 {","highlight_start":1,"highlight_end":39},{"text":"                    return Err(BLST_ERROR::BLST_BAD_ENCODING);","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    blst_scalar_from_bendian(&mut sk, sk_in.as_ptr());","highlight_start":1,"highlight_end":71},{"text":"                    if !blst_sk_check(&sk) {","highlight_start":1,"highlight_end":45},{"text":"                        return Err(BLST_ERROR::BLST_BAD_ENCODING);","highlight_start":1,"highlight_end":67},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(Self { value: sk })","highlight_start":1,"highlight_end":39},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_bytes(&self) -> [u8; 32] {","highlight_start":1,"highlight_end":49},{"text":"                SecretKey::serialize(&self)","highlight_start":1,"highlight_end":44},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_bytes(sk_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":74},{"text":"                SecretKey::deserialize(sk_in)","highlight_start":1,"highlight_end":46},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[derive(Default, Debug, Clone, Copy)]","highlight_start":1,"highlight_end":47},{"text":"        pub struct PublicKey {","highlight_start":1,"highlight_end":31},{"text":"            point: $pk_aff,","highlight_start":1,"highlight_end":28},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl PublicKey {","highlight_start":1,"highlight_end":25},{"text":"            // Core operations","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // key_validate","highlight_start":1,"highlight_end":28},{"text":"            pub fn validate(&self) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":63},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    if $pk_is_inf(&self.point) {","highlight_start":1,"highlight_end":49},{"text":"                        return Err(BLST_ERROR::BLST_PK_IS_INFINITY);","highlight_start":1,"highlight_end":69},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    if !$pk_in_group(&self.point) {","highlight_start":1,"highlight_end":52},{"text":"                        return Err(BLST_ERROR::BLST_POINT_NOT_IN_GROUP);","highlight_start":1,"highlight_end":73},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn key_validate(key: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":74},{"text":"                let pk = PublicKey::from_bytes(key)?;","highlight_start":1,"highlight_end":54},{"text":"                pk.validate()?;","highlight_start":1,"highlight_end":32},{"text":"                Ok(pk)","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_aggregate(agg_pk: &AggregatePublicKey) -> Self {","highlight_start":1,"highlight_end":73},{"text":"                let mut pk_aff = <$pk_aff>::default();","highlight_start":1,"highlight_end":55},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_to_aff(&mut pk_aff, &agg_pk.point);","highlight_start":1,"highlight_end":60},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Self { point: pk_aff }","highlight_start":1,"highlight_end":39},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Serdes","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn compress(&self) -> [u8; $pk_comp_size] {","highlight_start":1,"highlight_end":60},{"text":"                let mut pk_comp = [0u8; $pk_comp_size];","highlight_start":1,"highlight_end":56},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_comp(pk_comp.as_mut_ptr(), &self.point);","highlight_start":1,"highlight_end":65},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                pk_comp","highlight_start":1,"highlight_end":24},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn serialize(&self) -> [u8; $pk_ser_size] {","highlight_start":1,"highlight_end":60},{"text":"                let mut pk_out = [0u8; $pk_ser_size];","highlight_start":1,"highlight_end":54},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_ser(pk_out.as_mut_ptr(), &self.point);","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                pk_out","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn uncompress(pk_comp: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":76},{"text":"                if pk_comp.len() == $pk_comp_size && (pk_comp[0] & 0x80) != 0 {","highlight_start":1,"highlight_end":80},{"text":"                    let mut pk = <$pk_aff>::default();","highlight_start":1,"highlight_end":55},{"text":"                    let err = unsafe { $pk_uncomp(&mut pk, pk_comp.as_ptr()) };","highlight_start":1,"highlight_end":80},{"text":"                    if err != BLST_ERROR::BLST_SUCCESS {","highlight_start":1,"highlight_end":57},{"text":"                        return Err(err);","highlight_start":1,"highlight_end":41},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(Self { point: pk })","highlight_start":1,"highlight_end":43},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Err(BLST_ERROR::BLST_BAD_ENCODING)","highlight_start":1,"highlight_end":55},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn deserialize(pk_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":75},{"text":"                if (pk_in.len() == $pk_ser_size && (pk_in[0] & 0x80) == 0)","highlight_start":1,"highlight_end":75},{"text":"                    || (pk_in.len() == $pk_comp_size && (pk_in[0] & 0x80) != 0)","highlight_start":1,"highlight_end":80},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    let mut pk = <$pk_aff>::default();","highlight_start":1,"highlight_end":55},{"text":"                    let err = unsafe { $pk_deser(&mut pk, pk_in.as_ptr()) };","highlight_start":1,"highlight_end":77},{"text":"                    if err != BLST_ERROR::BLST_SUCCESS {","highlight_start":1,"highlight_end":57},{"text":"                        return Err(err);","highlight_start":1,"highlight_end":41},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(Self { point: pk })","highlight_start":1,"highlight_end":43},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Err(BLST_ERROR::BLST_BAD_ENCODING)","highlight_start":1,"highlight_end":55},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_bytes(pk_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":74},{"text":"                PublicKey::deserialize(pk_in)","highlight_start":1,"highlight_end":46},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_bytes(&self) -> [u8; $pk_comp_size] {","highlight_start":1,"highlight_end":60},{"text":"                self.compress()","highlight_start":1,"highlight_end":32},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Trait for equality comparisons which are equivalence relations.","highlight_start":1,"highlight_end":75},{"text":"        //","highlight_start":1,"highlight_end":11},{"text":"        // This means, that in addition to a == b and a != b being strict","highlight_start":1,"highlight_end":74},{"text":"        // inverses, the equality must be reflexive, symmetric and transitive.","highlight_start":1,"highlight_end":79},{"text":"        impl Eq for PublicKey {}","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl PartialEq for PublicKey {","highlight_start":1,"highlight_end":39},{"text":"            fn eq(&self, other: &Self) -> bool {","highlight_start":1,"highlight_end":49},{"text":"                unsafe { $pk_eq(&self.point, &other.point) }","highlight_start":1,"highlight_end":61},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[derive(Debug, Clone, Copy)]","highlight_start":1,"highlight_end":38},{"text":"        pub struct AggregatePublicKey {","highlight_start":1,"highlight_end":40},{"text":"            point: $pk,","highlight_start":1,"highlight_end":24},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl AggregatePublicKey {","highlight_start":1,"highlight_end":34},{"text":"            pub fn from_public_key(pk: &PublicKey) -> Self {","highlight_start":1,"highlight_end":61},{"text":"                let mut agg_pk = <$pk>::default();","highlight_start":1,"highlight_end":51},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_from_aff(&mut agg_pk, &pk.point);","highlight_start":1,"highlight_end":58},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Self { point: agg_pk }","highlight_start":1,"highlight_end":39},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_public_key(&self) -> PublicKey {","highlight_start":1,"highlight_end":55},{"text":"                let mut pk = <$pk_aff>::default();","highlight_start":1,"highlight_end":51},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_to_aff(&mut pk, &self.point);","highlight_start":1,"highlight_end":54},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                PublicKey { point: pk }","highlight_start":1,"highlight_end":40},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Aggregate","highlight_start":1,"highlight_end":25},{"text":"            pub fn aggregate(","highlight_start":1,"highlight_end":30},{"text":"                pks: &[&PublicKey],","highlight_start":1,"highlight_end":36},{"text":"                pks_validate: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                if pks.len() == 0 {","highlight_start":1,"highlight_end":36},{"text":"                    return Err(BLST_ERROR::BLST_AGGR_TYPE_MISMATCH);","highlight_start":1,"highlight_end":69},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if pks_validate {","highlight_start":1,"highlight_end":34},{"text":"                    pks[0].validate()?;","highlight_start":1,"highlight_end":40},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut agg_pk = AggregatePublicKey::from_public_key(pks[0]);","highlight_start":1,"highlight_end":78},{"text":"                for s in pks.iter().skip(1) {","highlight_start":1,"highlight_end":46},{"text":"                    if pks_validate {","highlight_start":1,"highlight_end":38},{"text":"                        s.validate()?;","highlight_start":1,"highlight_end":39},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        $pk_add_or_dbl_aff(","highlight_start":1,"highlight_end":44},{"text":"                            &mut agg_pk.point,","highlight_start":1,"highlight_end":47},{"text":"                            &agg_pk.point,","highlight_start":1,"highlight_end":43},{"text":"                            &s.point,","highlight_start":1,"highlight_end":38},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(agg_pk)","highlight_start":1,"highlight_end":27},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn aggregate_serialized(","highlight_start":1,"highlight_end":41},{"text":"                pks: &[&[u8]],","highlight_start":1,"highlight_end":31},{"text":"                pks_validate: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                // TODO - threading","highlight_start":1,"highlight_end":36},{"text":"                if pks.len() == 0 {","highlight_start":1,"highlight_end":36},{"text":"                    return Err(BLST_ERROR::BLST_AGGR_TYPE_MISMATCH);","highlight_start":1,"highlight_end":69},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut pk = if pks_validate {","highlight_start":1,"highlight_end":47},{"text":"                    PublicKey::key_validate(pks[0])?","highlight_start":1,"highlight_end":53},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    PublicKey::from_bytes(pks[0])?","highlight_start":1,"highlight_end":51},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut agg_pk = AggregatePublicKey::from_public_key(&pk);","highlight_start":1,"highlight_end":75},{"text":"                for s in pks.iter().skip(1) {","highlight_start":1,"highlight_end":46},{"text":"                    pk = if pks_validate {","highlight_start":1,"highlight_end":43},{"text":"                        PublicKey::key_validate(s)?","highlight_start":1,"highlight_end":52},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        PublicKey::from_bytes(s)?","highlight_start":1,"highlight_end":50},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        $pk_add_or_dbl_aff(","highlight_start":1,"highlight_end":44},{"text":"                            &mut agg_pk.point,","highlight_start":1,"highlight_end":47},{"text":"                            &agg_pk.point,","highlight_start":1,"highlight_end":43},{"text":"                            &pk.point,","highlight_start":1,"highlight_end":39},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(agg_pk)","highlight_start":1,"highlight_end":27},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn add_aggregate(&mut self, agg_pk: &AggregatePublicKey) {","highlight_start":1,"highlight_end":75},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_add_or_dbl(&mut self.point, &self.point, &agg_pk.point);","highlight_start":1,"highlight_end":81},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn add_public_key(","highlight_start":1,"highlight_end":35},{"text":"                &mut self,","highlight_start":1,"highlight_end":27},{"text":"                pk: &PublicKey,","highlight_start":1,"highlight_end":32},{"text":"                pk_validate: bool,","highlight_start":1,"highlight_end":35},{"text":"            ) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":42},{"text":"                if pk_validate {","highlight_start":1,"highlight_end":33},{"text":"                    pk.validate()?;","highlight_start":1,"highlight_end":36},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $pk_add_or_dbl_aff(&mut self.point, &self.point, &pk.point);","highlight_start":1,"highlight_end":81},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[derive(Debug, Clone, Copy)]","highlight_start":1,"highlight_end":38},{"text":"        pub struct Signature {","highlight_start":1,"highlight_end":31},{"text":"            point: $sig_aff,","highlight_start":1,"highlight_end":29},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl Signature {","highlight_start":1,"highlight_end":25},{"text":"            // sig_infcheck, check for infinity, is a way to avoid going","highlight_start":1,"highlight_end":73},{"text":"            // into resource-consuming verification. Passing 'false' is","highlight_start":1,"highlight_end":72},{"text":"            // always cryptographically safe, but application might want","highlight_start":1,"highlight_end":73},{"text":"            // to guard against obviously bogus individual[!] signatures.","highlight_start":1,"highlight_end":74},{"text":"            pub fn validate(","highlight_start":1,"highlight_end":29},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_infcheck: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":42},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    if sig_infcheck && $sig_is_inf(&self.point) {","highlight_start":1,"highlight_end":66},{"text":"                        return Err(BLST_ERROR::BLST_PK_IS_INFINITY);","highlight_start":1,"highlight_end":69},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    if !$sig_in_group(&self.point) {","highlight_start":1,"highlight_end":53},{"text":"                        return Err(BLST_ERROR::BLST_POINT_NOT_IN_GROUP);","highlight_start":1,"highlight_end":73},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn sig_validate(","highlight_start":1,"highlight_end":33},{"text":"                sig: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                sig_infcheck: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                let sig = Signature::from_bytes(sig)?;","highlight_start":1,"highlight_end":55},{"text":"                sig.validate(sig_infcheck)?;","highlight_start":1,"highlight_end":45},{"text":"                Ok(sig)","highlight_start":1,"highlight_end":24},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn verify(","highlight_start":1,"highlight_end":27},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"                msg: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                aug: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pk: &PublicKey,","highlight_start":1,"highlight_end":32},{"text":"                pk_validate: bool,","highlight_start":1,"highlight_end":35},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                let aug_msg = [aug, msg].concat();","highlight_start":1,"highlight_end":51},{"text":"                self.aggregate_verify(","highlight_start":1,"highlight_end":39},{"text":"                    sig_groupcheck,","highlight_start":1,"highlight_end":36},{"text":"                    &[aug_msg.as_slice()],","highlight_start":1,"highlight_end":43},{"text":"                    dst,","highlight_start":1,"highlight_end":25},{"text":"                    &[pk],","highlight_start":1,"highlight_end":27},{"text":"                    pk_validate,","highlight_start":1,"highlight_end":33},{"text":"                )","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn aggregate_verify(","highlight_start":1,"highlight_end":37},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"                msgs: &[&[u8]],","highlight_start":1,"highlight_end":32},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pks: &[&PublicKey],","highlight_start":1,"highlight_end":36},{"text":"                pks_validate: bool,","highlight_start":1,"highlight_end":36},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                let n_elems = pks.len();","highlight_start":1,"highlight_end":41},{"text":"                if n_elems == 0 || msgs.len() != n_elems {","highlight_start":1,"highlight_end":59},{"text":"                    return BLST_ERROR::BLST_VERIFY_FAIL;","highlight_start":1,"highlight_end":57},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // TODO - check msg uniqueness?","highlight_start":1,"highlight_end":48},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // let pool = da_pool();","highlight_start":1,"highlight_end":41},{"text":"                let (tx, rx) = channel();","highlight_start":1,"highlight_end":42},{"text":"                let counter = Arc::new(AtomicUsize::new(0));","highlight_start":1,"highlight_end":61},{"text":"                let valid = Arc::new(AtomicBool::new(true));","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Bypass 'lifetime limitations by brute force. It works,","highlight_start":1,"highlight_end":74},{"text":"                // because we explicitly join the threads...","highlight_start":1,"highlight_end":61},{"text":"                let raw_pks = unsafe {","highlight_start":1,"highlight_end":39},{"text":"                    transmute::<*const &PublicKey, usize>(pks.as_ptr())","highlight_start":1,"highlight_end":72},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let raw_msgs =","highlight_start":1,"highlight_end":31},{"text":"                    unsafe { transmute::<*const &[u8], usize>(msgs.as_ptr()) };","highlight_start":1,"highlight_end":80},{"text":"                let dst =","highlight_start":1,"highlight_end":26},{"text":"                    unsafe { slice::from_raw_parts(dst.as_ptr(), dst.len()) };","highlight_start":1,"highlight_end":79},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // let n_workers = std::cmp::min(pool.max_count(), n_elems);","highlight_start":1,"highlight_end":77},{"text":"                // for _ in 0..n_workers {","highlight_start":1,"highlight_end":43},{"text":"                    let tx = tx.clone();","highlight_start":1,"highlight_end":41},{"text":"                    let counter = counter.clone();","highlight_start":1,"highlight_end":51},{"text":"                    let valid = valid.clone();","highlight_start":1,"highlight_end":47},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // pool.execute(move || {","highlight_start":1,"highlight_end":46},{"text":"                        let mut pairing = Pairing::new($hash_or_encode, dst);","highlight_start":1,"highlight_end":78},{"text":"                        // reconstruct input slices...","highlight_start":1,"highlight_end":55},{"text":"                        let msgs = unsafe {","highlight_start":1,"highlight_end":44},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &[u8]>(raw_msgs),","highlight_start":1,"highlight_end":76},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                        let pks = unsafe {","highlight_start":1,"highlight_end":43},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &PublicKey>(raw_pks),","highlight_start":1,"highlight_end":80},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        while valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":62},{"text":"                            let work = counter.fetch_add(1, Ordering::Relaxed);","highlight_start":1,"highlight_end":80},{"text":"                            if work >= n_elems {","highlight_start":1,"highlight_end":49},{"text":"                                break;","highlight_start":1,"highlight_end":39},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                            if pairing.aggregate(","highlight_start":1,"highlight_end":50},{"text":"                                &pks[work].point,","highlight_start":1,"highlight_end":50},{"text":"                                pks_validate,","highlight_start":1,"highlight_end":46},{"text":"                                &unsafe { ptr::null::<$sig_aff>().as_ref() },","highlight_start":1,"highlight_end":78},{"text":"                                false,","highlight_start":1,"highlight_end":39},{"text":"                                &msgs[work],","highlight_start":1,"highlight_end":45},{"text":"                                &[],","highlight_start":1,"highlight_end":37},{"text":"                            ) != BLST_ERROR::BLST_SUCCESS","highlight_start":1,"highlight_end":58},{"text":"                            {","highlight_start":1,"highlight_end":30},{"text":"                                valid.store(false, Ordering::Relaxed);","highlight_start":1,"highlight_end":71},{"text":"                                break;","highlight_start":1,"highlight_end":39},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        if valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":59},{"text":"                            pairing.commit();","highlight_start":1,"highlight_end":46},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        tx.send(pairing).expect(\"disaster\");","highlight_start":1,"highlight_end":61},{"text":"                    // });","highlight_start":1,"highlight_end":27},{"text":"                // }","highlight_start":1,"highlight_end":21},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                if sig_groupcheck && valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":69},{"text":"                    match self.validate(false) {","highlight_start":1,"highlight_end":49},{"text":"                        Err(_err) => valid.store(false, Ordering::Relaxed),","highlight_start":1,"highlight_end":76},{"text":"                        _ => (),","highlight_start":1,"highlight_end":33},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut gtsig = blst_fp12::default();","highlight_start":1,"highlight_end":54},{"text":"                if valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":51},{"text":"                    Pairing::aggregated(&mut gtsig, &self.point);","highlight_start":1,"highlight_end":66},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut acc = rx.recv().unwrap();","highlight_start":1,"highlight_end":50},{"text":"                // for _ in 1..n_workers {","highlight_start":1,"highlight_end":43},{"text":"                    // acc.merge(&rx.recv().unwrap());","highlight_start":1,"highlight_end":55},{"text":"                // }","highlight_start":1,"highlight_end":21},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                if valid.load(Ordering::Relaxed)","highlight_start":1,"highlight_end":49},{"text":"                    && acc.finalverify(Some(&gtsig))","highlight_start":1,"highlight_end":53},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    BLST_ERROR::BLST_SUCCESS","highlight_start":1,"highlight_end":45},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    BLST_ERROR::BLST_VERIFY_FAIL","highlight_start":1,"highlight_end":49},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // pks are assumed to be verified for proof of possession,","highlight_start":1,"highlight_end":71},{"text":"            // which implies that they are already group-checked","highlight_start":1,"highlight_end":65},{"text":"            pub fn fast_aggregate_verify(","highlight_start":1,"highlight_end":42},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"                msg: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pks: &[&PublicKey],","highlight_start":1,"highlight_end":36},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                let agg_pk = match AggregatePublicKey::aggregate(pks, false) {","highlight_start":1,"highlight_end":79},{"text":"                    Ok(agg_sig) => agg_sig,","highlight_start":1,"highlight_end":44},{"text":"                    Err(err) => return err,","highlight_start":1,"highlight_end":44},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let pk = agg_pk.to_public_key();","highlight_start":1,"highlight_end":49},{"text":"                self.aggregate_verify(","highlight_start":1,"highlight_end":39},{"text":"                    sig_groupcheck,","highlight_start":1,"highlight_end":36},{"text":"                    &[msg],","highlight_start":1,"highlight_end":28},{"text":"                    dst,","highlight_start":1,"highlight_end":25},{"text":"                    &[&pk],","highlight_start":1,"highlight_end":28},{"text":"                    false,","highlight_start":1,"highlight_end":27},{"text":"                )","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn fast_aggregate_verify_pre_aggregated(","highlight_start":1,"highlight_end":57},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"                msg: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pk: &PublicKey,","highlight_start":1,"highlight_end":32},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                self.aggregate_verify(sig_groupcheck, &[msg], dst, &[pk], false)","highlight_start":1,"highlight_end":81},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // https://ethresear.ch/t/fast-verification-of-multiple-bls-signatures/5407","highlight_start":1,"highlight_end":88},{"text":"            pub fn verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":57},{"text":"                msgs: &[&[u8]],","highlight_start":1,"highlight_end":32},{"text":"                dst: &[u8],","highlight_start":1,"highlight_end":28},{"text":"                pks: &[&PublicKey],","highlight_start":1,"highlight_end":36},{"text":"                pks_validate: bool,","highlight_start":1,"highlight_end":36},{"text":"                sigs: &[&Signature],","highlight_start":1,"highlight_end":37},{"text":"                sigs_groupcheck: bool,","highlight_start":1,"highlight_end":39},{"text":"                rands: &[blst_scalar],","highlight_start":1,"highlight_end":39},{"text":"                rand_bits: usize,","highlight_start":1,"highlight_end":34},{"text":"            ) -> BLST_ERROR {","highlight_start":1,"highlight_end":30},{"text":"                let n_elems = pks.len();","highlight_start":1,"highlight_end":41},{"text":"                if n_elems == 0","highlight_start":1,"highlight_end":32},{"text":"                    || msgs.len() != n_elems","highlight_start":1,"highlight_end":45},{"text":"                    || sigs.len() != n_elems","highlight_start":1,"highlight_end":45},{"text":"                    || rands.len() != n_elems","highlight_start":1,"highlight_end":46},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    return BLST_ERROR::BLST_VERIFY_FAIL;","highlight_start":1,"highlight_end":57},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // TODO - check msg uniqueness?","highlight_start":1,"highlight_end":48},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // let pool = da_pool();","highlight_start":1,"highlight_end":41},{"text":"                let (tx, rx) = channel();","highlight_start":1,"highlight_end":42},{"text":"                let counter = Arc::new(AtomicUsize::new(0));","highlight_start":1,"highlight_end":61},{"text":"                let valid = Arc::new(AtomicBool::new(true));","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Bypass 'lifetime limitations by brute force. It works,","highlight_start":1,"highlight_end":74},{"text":"                // because we explicitly join the threads...","highlight_start":1,"highlight_end":61},{"text":"                let raw_pks = unsafe {","highlight_start":1,"highlight_end":39},{"text":"                    transmute::<*const &PublicKey, usize>(pks.as_ptr())","highlight_start":1,"highlight_end":72},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let raw_sigs = unsafe {","highlight_start":1,"highlight_end":40},{"text":"                    transmute::<*const &Signature, usize>(sigs.as_ptr())","highlight_start":1,"highlight_end":73},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let raw_rands = unsafe {","highlight_start":1,"highlight_end":41},{"text":"                    transmute::<*const blst_scalar, usize>(rands.as_ptr())","highlight_start":1,"highlight_end":75},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let raw_msgs =","highlight_start":1,"highlight_end":31},{"text":"                    unsafe { transmute::<*const &[u8], usize>(msgs.as_ptr()) };","highlight_start":1,"highlight_end":80},{"text":"                let dst =","highlight_start":1,"highlight_end":26},{"text":"                    unsafe { slice::from_raw_parts(dst.as_ptr(), dst.len()) };","highlight_start":1,"highlight_end":79},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // let n_workers = std::cmp::min(pool.max_count(), n_elems);","highlight_start":1,"highlight_end":77},{"text":"                //for _ in 0..n_workers {","highlight_start":1,"highlight_end":42},{"text":"                    let tx = tx.clone();","highlight_start":1,"highlight_end":41},{"text":"                    let counter = counter.clone();","highlight_start":1,"highlight_end":51},{"text":"                    let valid = valid.clone();","highlight_start":1,"highlight_end":47},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // pool.execute(move || {","highlight_start":1,"highlight_end":46},{"text":"                        let mut pairing = Pairing::new($hash_or_encode, dst);","highlight_start":1,"highlight_end":78},{"text":"                        // reconstruct input slices...","highlight_start":1,"highlight_end":55},{"text":"                        let rands = unsafe {","highlight_start":1,"highlight_end":45},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const blst_scalar>(","highlight_start":1,"highlight_end":72},{"text":"                                    raw_rands,","highlight_start":1,"highlight_end":47},{"text":"                                ),","highlight_start":1,"highlight_end":35},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                        let msgs = unsafe {","highlight_start":1,"highlight_end":44},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &[u8]>(raw_msgs),","highlight_start":1,"highlight_end":76},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                        let sigs = unsafe {","highlight_start":1,"highlight_end":44},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &Signature>(raw_sigs),","highlight_start":1,"highlight_end":81},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                        let pks = unsafe {","highlight_start":1,"highlight_end":43},{"text":"                            slice::from_raw_parts(","highlight_start":1,"highlight_end":51},{"text":"                                transmute::<usize, *const &PublicKey>(raw_pks),","highlight_start":1,"highlight_end":80},{"text":"                                n_elems,","highlight_start":1,"highlight_end":41},{"text":"                            )","highlight_start":1,"highlight_end":30},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        // TODO - engage multi-point mul-n-add for larger","highlight_start":1,"highlight_end":74},{"text":"                        // amount of inputs...","highlight_start":1,"highlight_end":47},{"text":"                        while valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":62},{"text":"                            let work = counter.fetch_add(1, Ordering::Relaxed);","highlight_start":1,"highlight_end":80},{"text":"                            if work >= n_elems {","highlight_start":1,"highlight_end":49},{"text":"                                break;","highlight_start":1,"highlight_end":39},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            if pairing.mul_n_aggregate(","highlight_start":1,"highlight_end":56},{"text":"                                &pks[work].point,","highlight_start":1,"highlight_end":50},{"text":"                                pks_validate,","highlight_start":1,"highlight_end":46},{"text":"                                &sigs[work].point,","highlight_start":1,"highlight_end":51},{"text":"                                sigs_groupcheck,","highlight_start":1,"highlight_end":49},{"text":"                                &rands[work].b,","highlight_start":1,"highlight_end":48},{"text":"                                rand_bits,","highlight_start":1,"highlight_end":43},{"text":"                                msgs[work],","highlight_start":1,"highlight_end":44},{"text":"                                &[],","highlight_start":1,"highlight_end":37},{"text":"                            ) != BLST_ERROR::BLST_SUCCESS","highlight_start":1,"highlight_end":58},{"text":"                            {","highlight_start":1,"highlight_end":30},{"text":"                                valid.store(false, Ordering::Relaxed);","highlight_start":1,"highlight_end":71},{"text":"                                break;","highlight_start":1,"highlight_end":39},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        if valid.load(Ordering::Relaxed) {","highlight_start":1,"highlight_end":59},{"text":"                            pairing.commit();","highlight_start":1,"highlight_end":46},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        tx.send(pairing).expect(\"disaster\");","highlight_start":1,"highlight_end":61},{"text":"                    // });","highlight_start":1,"highlight_end":27},{"text":"                //}","highlight_start":1,"highlight_end":20},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut acc = rx.recv().unwrap();","highlight_start":1,"highlight_end":50},{"text":"                //for _ in 1..n_workers {","highlight_start":1,"highlight_end":42},{"text":"                    // acc.merge(&rx.recv().unwrap());","highlight_start":1,"highlight_end":55},{"text":"                //}","highlight_start":1,"highlight_end":20},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                if valid.load(Ordering::Relaxed) && acc.finalverify(None) {","highlight_start":1,"highlight_end":76},{"text":"                    BLST_ERROR::BLST_SUCCESS","highlight_start":1,"highlight_end":45},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    BLST_ERROR::BLST_VERIFY_FAIL","highlight_start":1,"highlight_end":49},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_aggregate(agg_sig: &AggregateSignature) -> Self {","highlight_start":1,"highlight_end":74},{"text":"                let mut sig_aff = <$sig_aff>::default();","highlight_start":1,"highlight_end":57},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_to_aff(&mut sig_aff, &agg_sig.point);","highlight_start":1,"highlight_end":63},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Self { point: sig_aff }","highlight_start":1,"highlight_end":40},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn compress(&self) -> [u8; $sig_comp_size] {","highlight_start":1,"highlight_end":61},{"text":"                let mut sig_comp = [0; $sig_comp_size];","highlight_start":1,"highlight_end":56},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_comp(sig_comp.as_mut_ptr(), &self.point);","highlight_start":1,"highlight_end":67},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                sig_comp","highlight_start":1,"highlight_end":25},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn serialize(&self) -> [u8; $sig_ser_size] {","highlight_start":1,"highlight_end":61},{"text":"                let mut sig_out = [0; $sig_ser_size];","highlight_start":1,"highlight_end":54},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_ser(sig_out.as_mut_ptr(), &self.point);","highlight_start":1,"highlight_end":65},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                sig_out","highlight_start":1,"highlight_end":24},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn uncompress(sig_comp: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":77},{"text":"                if sig_comp.len() == $sig_comp_size && (sig_comp[0] & 0x80) != 0","highlight_start":1,"highlight_end":81},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    let mut sig = <$sig_aff>::default();","highlight_start":1,"highlight_end":57},{"text":"                    let err =","highlight_start":1,"highlight_end":30},{"text":"                        unsafe { $sig_uncomp(&mut sig, sig_comp.as_ptr()) };","highlight_start":1,"highlight_end":77},{"text":"                    if err != BLST_ERROR::BLST_SUCCESS {","highlight_start":1,"highlight_end":57},{"text":"                        return Err(err);","highlight_start":1,"highlight_end":41},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(Self { point: sig })","highlight_start":1,"highlight_end":44},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Err(BLST_ERROR::BLST_BAD_ENCODING)","highlight_start":1,"highlight_end":55},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn deserialize(sig_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":76},{"text":"                if (sig_in.len() == $sig_ser_size && (sig_in[0] & 0x80) == 0)","highlight_start":1,"highlight_end":78},{"text":"                    || (sig_in.len() == $sig_comp_size","highlight_start":1,"highlight_end":55},{"text":"                        && (sig_in[0] & 0x80) != 0)","highlight_start":1,"highlight_end":52},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    let mut sig = <$sig_aff>::default();","highlight_start":1,"highlight_end":57},{"text":"                    let err = unsafe { $sig_deser(&mut sig, sig_in.as_ptr()) };","highlight_start":1,"highlight_end":80},{"text":"                    if err != BLST_ERROR::BLST_SUCCESS {","highlight_start":1,"highlight_end":57},{"text":"                        return Err(err);","highlight_start":1,"highlight_end":41},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(Self { point: sig })","highlight_start":1,"highlight_end":44},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Err(BLST_ERROR::BLST_BAD_ENCODING)","highlight_start":1,"highlight_end":55},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_bytes(sig_in: &[u8]) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":75},{"text":"                Signature::deserialize(sig_in)","highlight_start":1,"highlight_end":47},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_bytes(&self) -> [u8; $sig_comp_size] {","highlight_start":1,"highlight_end":61},{"text":"                self.compress()","highlight_start":1,"highlight_end":32},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn subgroup_check(&self) -> bool {","highlight_start":1,"highlight_end":51},{"text":"                unsafe { $sig_in_group(&self.point) }","highlight_start":1,"highlight_end":54},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Trait for equality comparisons which are equivalence relations.","highlight_start":1,"highlight_end":75},{"text":"        //","highlight_start":1,"highlight_end":11},{"text":"        // This means, that in addition to a == b and a != b being strict","highlight_start":1,"highlight_end":74},{"text":"        // inverses, the equality must be reflexive, symmetric and transitive.","highlight_start":1,"highlight_end":79},{"text":"        impl Eq for Signature {}","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl PartialEq for Signature {","highlight_start":1,"highlight_end":39},{"text":"            fn eq(&self, other: &Self) -> bool {","highlight_start":1,"highlight_end":49},{"text":"                unsafe { $sig_eq(&self.point, &other.point) }","highlight_start":1,"highlight_end":62},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[derive(Debug, Clone, Copy)]","highlight_start":1,"highlight_end":38},{"text":"        pub struct AggregateSignature {","highlight_start":1,"highlight_end":40},{"text":"            point: $sig,","highlight_start":1,"highlight_end":25},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl AggregateSignature {","highlight_start":1,"highlight_end":34},{"text":"            pub fn validate(&self) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":63},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    if !$sig_aggr_in_group(&self.point) {","highlight_start":1,"highlight_end":58},{"text":"                        return Err(BLST_ERROR::BLST_POINT_NOT_IN_GROUP);","highlight_start":1,"highlight_end":73},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn from_signature(sig: &Signature) -> Self {","highlight_start":1,"highlight_end":61},{"text":"                let mut agg_sig = <$sig>::default();","highlight_start":1,"highlight_end":53},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_from_aff(&mut agg_sig, &sig.point);","highlight_start":1,"highlight_end":61},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Self { point: agg_sig }","highlight_start":1,"highlight_end":40},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn to_signature(&self) -> Signature {","highlight_start":1,"highlight_end":54},{"text":"                let mut sig = <$sig_aff>::default();","highlight_start":1,"highlight_end":53},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_to_aff(&mut sig, &self.point);","highlight_start":1,"highlight_end":56},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Signature { point: sig }","highlight_start":1,"highlight_end":41},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Aggregate","highlight_start":1,"highlight_end":25},{"text":"            pub fn aggregate(","highlight_start":1,"highlight_end":30},{"text":"                sigs: &[&Signature],","highlight_start":1,"highlight_end":37},{"text":"                sigs_groupcheck: bool,","highlight_start":1,"highlight_end":39},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                if sigs.len() == 0 {","highlight_start":1,"highlight_end":37},{"text":"                    return Err(BLST_ERROR::BLST_AGGR_TYPE_MISMATCH);","highlight_start":1,"highlight_end":69},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if sigs_groupcheck {","highlight_start":1,"highlight_end":37},{"text":"                    // We can't actually judge if input is individual or","highlight_start":1,"highlight_end":73},{"text":"                    // aggregated signature, so we can't enforce infinitiy","highlight_start":1,"highlight_end":75},{"text":"                    // check.","highlight_start":1,"highlight_end":30},{"text":"                    sigs[0].validate(false)?;","highlight_start":1,"highlight_end":46},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut agg_sig = AggregateSignature::from_signature(sigs[0]);","highlight_start":1,"highlight_end":79},{"text":"                for s in sigs.iter().skip(1) {","highlight_start":1,"highlight_end":47},{"text":"                    if sigs_groupcheck {","highlight_start":1,"highlight_end":41},{"text":"                        s.validate(false)?;","highlight_start":1,"highlight_end":44},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        $sig_add_or_dbl_aff(","highlight_start":1,"highlight_end":45},{"text":"                            &mut agg_sig.point,","highlight_start":1,"highlight_end":48},{"text":"                            &agg_sig.point,","highlight_start":1,"highlight_end":44},{"text":"                            &s.point,","highlight_start":1,"highlight_end":38},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(agg_sig)","highlight_start":1,"highlight_end":28},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn aggregate_serialized(","highlight_start":1,"highlight_end":41},{"text":"                sigs: &[&[u8]],","highlight_start":1,"highlight_end":32},{"text":"                sigs_groupcheck: bool,","highlight_start":1,"highlight_end":39},{"text":"            ) -> Result<Self, BLST_ERROR> {","highlight_start":1,"highlight_end":44},{"text":"                // TODO - threading","highlight_start":1,"highlight_end":36},{"text":"                if sigs.len() == 0 {","highlight_start":1,"highlight_end":37},{"text":"                    return Err(BLST_ERROR::BLST_AGGR_TYPE_MISMATCH);","highlight_start":1,"highlight_end":69},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                let mut sig = if sigs_groupcheck {","highlight_start":1,"highlight_end":51},{"text":"                    Signature::sig_validate(sigs[0], false)?","highlight_start":1,"highlight_end":61},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    Signature::from_bytes(sigs[0])?","highlight_start":1,"highlight_end":52},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                let mut agg_sig = AggregateSignature::from_signature(&sig);","highlight_start":1,"highlight_end":76},{"text":"                for s in sigs.iter().skip(1) {","highlight_start":1,"highlight_end":47},{"text":"                    sig = if sigs_groupcheck {","highlight_start":1,"highlight_end":47},{"text":"                        Signature::sig_validate(s, false)?","highlight_start":1,"highlight_end":59},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        Signature::from_bytes(s)?","highlight_start":1,"highlight_end":50},{"text":"                    };","highlight_start":1,"highlight_end":23},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        $sig_add_or_dbl_aff(","highlight_start":1,"highlight_end":45},{"text":"                            &mut agg_sig.point,","highlight_start":1,"highlight_end":48},{"text":"                            &agg_sig.point,","highlight_start":1,"highlight_end":44},{"text":"                            &sig.point,","highlight_start":1,"highlight_end":40},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(agg_sig)","highlight_start":1,"highlight_end":28},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn add_aggregate(&mut self, agg_sig: &AggregateSignature) {","highlight_start":1,"highlight_end":76},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_add_or_dbl(","highlight_start":1,"highlight_end":37},{"text":"                        &mut self.point,","highlight_start":1,"highlight_end":41},{"text":"                        &self.point,","highlight_start":1,"highlight_end":37},{"text":"                        &agg_sig.point,","highlight_start":1,"highlight_end":40},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn add_signature(","highlight_start":1,"highlight_end":34},{"text":"                &mut self,","highlight_start":1,"highlight_end":27},{"text":"                sig: &Signature,","highlight_start":1,"highlight_end":33},{"text":"                sig_groupcheck: bool,","highlight_start":1,"highlight_end":38},{"text":"            ) -> Result<(), BLST_ERROR> {","highlight_start":1,"highlight_end":42},{"text":"                if sig_groupcheck {","highlight_start":1,"highlight_end":36},{"text":"                    sig.validate(false)?;","highlight_start":1,"highlight_end":42},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    $sig_add_or_dbl_aff(","highlight_start":1,"highlight_end":41},{"text":"                        &mut self.point,","highlight_start":1,"highlight_end":41},{"text":"                        &self.point,","highlight_start":1,"highlight_end":37},{"text":"                        &sig.point,","highlight_start":1,"highlight_end":36},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            pub fn subgroup_check(&self) -> bool {","highlight_start":1,"highlight_end":51},{"text":"                unsafe { $sig_aggr_in_group(&self.point) }","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[cfg(test)]","highlight_start":1,"highlight_end":21},{"text":"        mod tests {","highlight_start":1,"highlight_end":20},{"text":"            use super::*;","highlight_start":1,"highlight_end":26},{"text":"            use rand::{RngCore, SeedableRng};","highlight_start":1,"highlight_end":46},{"text":"            use rand_chacha::ChaCha20Rng;","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Testing only - do not use for production","highlight_start":1,"highlight_end":56},{"text":"            pub fn gen_random_key(","highlight_start":1,"highlight_end":35},{"text":"                rng: &mut rand_chacha::ChaCha20Rng,","highlight_start":1,"highlight_end":52},{"text":"            ) -> SecretKey {","highlight_start":1,"highlight_end":29},{"text":"                let mut ikm = [0u8; 32];","highlight_start":1,"highlight_end":41},{"text":"                rng.fill_bytes(&mut ikm);","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut sk = <blst_scalar>::default();","highlight_start":1,"highlight_end":55},{"text":"                unsafe {","highlight_start":1,"highlight_end":25},{"text":"                    blst_keygen(&mut sk, ikm.as_ptr(), 32, ptr::null(), 0);","highlight_start":1,"highlight_end":76},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                SecretKey { value: sk }","highlight_start":1,"highlight_end":40},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[test]","highlight_start":1,"highlight_end":20},{"text":"            fn test_sign() {","highlight_start":1,"highlight_end":29},{"text":"                let ikm: [u8; 32] = [","highlight_start":1,"highlight_end":38},{"text":"                    0x93, 0xad, 0x7e, 0x65, 0xde, 0xad, 0x05, 0x2a, 0x08, 0x3a,","highlight_start":1,"highlight_end":80},{"text":"                    0x91, 0x0c, 0x8b, 0x72, 0x85, 0x91, 0x46, 0x4c, 0xca, 0x56,","highlight_start":1,"highlight_end":80},{"text":"                    0x60, 0x5b, 0xb0, 0x56, 0xed, 0xfe, 0x2b, 0x60, 0xa6, 0x3c,","highlight_start":1,"highlight_end":80},{"text":"                    0x48, 0x99,","highlight_start":1,"highlight_end":32},{"text":"                ];","highlight_start":1,"highlight_end":19},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sk = SecretKey::key_gen(&ikm, &[]).unwrap();","highlight_start":1,"highlight_end":65},{"text":"                let pk = sk.sk_to_pk();","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let dst = b\"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_\";","highlight_start":1,"highlight_end":74},{"text":"                let msg = b\"hello foo\";","highlight_start":1,"highlight_end":40},{"text":"                let sig = sk.sign(msg, dst, &[]);","highlight_start":1,"highlight_end":50},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let err = sig.verify(true, msg, dst, &[], &pk, true);","highlight_start":1,"highlight_end":70},{"text":"                assert_eq!(err, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":59},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[test]","highlight_start":1,"highlight_end":20},{"text":"            fn test_aggregate() {","highlight_start":1,"highlight_end":34},{"text":"                let num_msgs = 10;","highlight_start":1,"highlight_end":35},{"text":"                let dst = b\"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_\";","highlight_start":1,"highlight_end":74},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let seed = [0u8; 32];","highlight_start":1,"highlight_end":38},{"text":"                let mut rng = ChaCha20Rng::from_seed(seed);","highlight_start":1,"highlight_end":60},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sks: Vec<_> =","highlight_start":1,"highlight_end":34},{"text":"                    (0..num_msgs).map(|_| gen_random_key(&mut rng)).collect();","highlight_start":1,"highlight_end":79},{"text":"                let pks =","highlight_start":1,"highlight_end":26},{"text":"                    sks.iter().map(|sk| sk.sk_to_pk()).collect::<Vec<_>>();","highlight_start":1,"highlight_end":76},{"text":"                let pks_refs: Vec<&PublicKey> =","highlight_start":1,"highlight_end":48},{"text":"                    pks.iter().map(|pk| pk).collect();","highlight_start":1,"highlight_end":55},{"text":"                let pks_rev: Vec<&PublicKey> =","highlight_start":1,"highlight_end":47},{"text":"                    pks.iter().rev().map(|pk| pk).collect();","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_comp = pks[0].compress();","highlight_start":1,"highlight_end":49},{"text":"                let pk_uncomp = PublicKey::uncompress(&pk_comp);","highlight_start":1,"highlight_end":65},{"text":"                assert_eq!(pk_uncomp.is_ok(), true);","highlight_start":1,"highlight_end":53},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut msgs: Vec<Vec<u8>> = vec![vec![]; num_msgs];","highlight_start":1,"highlight_end":69},{"text":"                for i in 0..num_msgs {","highlight_start":1,"highlight_end":39},{"text":"                    let msg_len = (rng.next_u64() & 0x3F) + 1;","highlight_start":1,"highlight_end":63},{"text":"                    msgs[i] = vec![0u8; msg_len as usize];","highlight_start":1,"highlight_end":59},{"text":"                    rng.fill_bytes(&mut msgs[i]);","highlight_start":1,"highlight_end":50},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let msgs_refs: Vec<&[u8]> =","highlight_start":1,"highlight_end":44},{"text":"                    msgs.iter().map(|m| m.as_slice()).collect();","highlight_start":1,"highlight_end":65},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sigs = sks","highlight_start":1,"highlight_end":31},{"text":"                    .iter()","highlight_start":1,"highlight_end":28},{"text":"                    .zip(msgs.iter())","highlight_start":1,"highlight_end":38},{"text":"                    .map(|(sk, m)| (sk.sign(m, dst, &[])))","highlight_start":1,"highlight_end":59},{"text":"                    .collect::<Vec<Signature>>();","highlight_start":1,"highlight_end":50},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut errs = sigs","highlight_start":1,"highlight_end":36},{"text":"                    .iter()","highlight_start":1,"highlight_end":28},{"text":"                    .zip(msgs.iter())","highlight_start":1,"highlight_end":38},{"text":"                    .zip(pks.iter())","highlight_start":1,"highlight_end":37},{"text":"                    .map(|((s, m), pk)| (s.verify(true, m, dst, &[], pk, true)))","highlight_start":1,"highlight_end":81},{"text":"                    .collect::<Vec<BLST_ERROR>>();","highlight_start":1,"highlight_end":51},{"text":"                assert_eq!(errs, vec![BLST_ERROR::BLST_SUCCESS; num_msgs]);","highlight_start":1,"highlight_end":76},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Swap message/public key pairs to create bad signature","highlight_start":1,"highlight_end":73},{"text":"                errs = sigs","highlight_start":1,"highlight_end":28},{"text":"                    .iter()","highlight_start":1,"highlight_end":28},{"text":"                    .zip(msgs.iter())","highlight_start":1,"highlight_end":38},{"text":"                    .zip(pks.iter().rev())","highlight_start":1,"highlight_end":43},{"text":"                    .map(|((s, m), pk)| (s.verify(true, m, dst, &[], pk, true)))","highlight_start":1,"highlight_end":81},{"text":"                    .collect::<Vec<BLST_ERROR>>();","highlight_start":1,"highlight_end":51},{"text":"                assert_ne!(errs, vec![BLST_ERROR::BLST_SUCCESS; num_msgs]);","highlight_start":1,"highlight_end":76},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sig_refs =","highlight_start":1,"highlight_end":31},{"text":"                    sigs.iter().map(|s| s).collect::<Vec<&Signature>>();","highlight_start":1,"highlight_end":73},{"text":"                let agg = match AggregateSignature::aggregate(&sig_refs, true) {","highlight_start":1,"highlight_end":81},{"text":"                    Ok(agg) => agg,","highlight_start":1,"highlight_end":36},{"text":"                    Err(err) => panic!(\"aggregate failure: {:?}\", err),","highlight_start":1,"highlight_end":72},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let agg_sig = agg.to_signature();","highlight_start":1,"highlight_end":50},{"text":"                let mut result = agg_sig","highlight_start":1,"highlight_end":41},{"text":"                    .aggregate_verify(false, &msgs_refs, dst, &pks_refs, false);","highlight_start":1,"highlight_end":81},{"text":"                assert_eq!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Swap message/public key pairs to create bad signature","highlight_start":1,"highlight_end":73},{"text":"                result = agg_sig","highlight_start":1,"highlight_end":33},{"text":"                    .aggregate_verify(false, &msgs_refs, dst, &pks_rev, false);","highlight_start":1,"highlight_end":80},{"text":"                assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[test]","highlight_start":1,"highlight_end":20},{"text":"            fn test_multiple_agg_sigs() {","highlight_start":1,"highlight_end":42},{"text":"                let dst = b\"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_\";","highlight_start":1,"highlight_end":74},{"text":"                let num_pks_per_sig = 10;","highlight_start":1,"highlight_end":42},{"text":"                let num_sigs = 10;","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let seed = [0u8; 32];","highlight_start":1,"highlight_end":38},{"text":"                let mut rng = ChaCha20Rng::from_seed(seed);","highlight_start":1,"highlight_end":60},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut msgs: Vec<Vec<u8>> = vec![vec![]; num_sigs];","highlight_start":1,"highlight_end":69},{"text":"                let mut sigs: Vec<Signature> = Vec::with_capacity(num_sigs);","highlight_start":1,"highlight_end":77},{"text":"                let mut pks: Vec<PublicKey> = Vec::with_capacity(num_sigs);","highlight_start":1,"highlight_end":76},{"text":"                let mut rands: Vec<blst_scalar> = Vec::with_capacity(num_sigs);","highlight_start":1,"highlight_end":80},{"text":"                for i in 0..num_sigs {","highlight_start":1,"highlight_end":39},{"text":"                    // Create public keys","highlight_start":1,"highlight_end":42},{"text":"                    let sks_i: Vec<_> = (0..num_pks_per_sig)","highlight_start":1,"highlight_end":61},{"text":"                        .map(|_| gen_random_key(&mut rng))","highlight_start":1,"highlight_end":59},{"text":"                        .collect();","highlight_start":1,"highlight_end":36},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let pks_i = sks_i","highlight_start":1,"highlight_end":38},{"text":"                        .iter()","highlight_start":1,"highlight_end":32},{"text":"                        .map(|sk| sk.sk_to_pk())","highlight_start":1,"highlight_end":49},{"text":"                        .collect::<Vec<_>>();","highlight_start":1,"highlight_end":46},{"text":"                    let pks_refs_i: Vec<&PublicKey> =","highlight_start":1,"highlight_end":54},{"text":"                        pks_i.iter().map(|pk| pk).collect();","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Create random message for pks to all sign","highlight_start":1,"highlight_end":65},{"text":"                    let msg_len = (rng.next_u64() & 0x3F) + 1;","highlight_start":1,"highlight_end":63},{"text":"                    msgs[i] = vec![0u8; msg_len as usize];","highlight_start":1,"highlight_end":59},{"text":"                    rng.fill_bytes(&mut msgs[i]);","highlight_start":1,"highlight_end":50},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Generate signature for each key pair","highlight_start":1,"highlight_end":60},{"text":"                    let sigs_i = sks_i","highlight_start":1,"highlight_end":39},{"text":"                        .iter()","highlight_start":1,"highlight_end":32},{"text":"                        .map(|sk| sk.sign(&msgs[i], dst, &[]))","highlight_start":1,"highlight_end":63},{"text":"                        .collect::<Vec<Signature>>();","highlight_start":1,"highlight_end":54},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Test each current single signature","highlight_start":1,"highlight_end":58},{"text":"                    let errs = sigs_i","highlight_start":1,"highlight_end":38},{"text":"                        .iter()","highlight_start":1,"highlight_end":32},{"text":"                        .zip(pks_i.iter())","highlight_start":1,"highlight_end":43},{"text":"                        .map(|(s, pk)| {","highlight_start":1,"highlight_end":41},{"text":"                            (s.verify(true, &msgs[i], dst, &[], pk, true))","highlight_start":1,"highlight_end":75},{"text":"                        })","highlight_start":1,"highlight_end":27},{"text":"                        .collect::<Vec<BLST_ERROR>>();","highlight_start":1,"highlight_end":55},{"text":"                    assert_eq!(","highlight_start":1,"highlight_end":32},{"text":"                        errs,","highlight_start":1,"highlight_end":30},{"text":"                        vec![BLST_ERROR::BLST_SUCCESS; num_pks_per_sig]","highlight_start":1,"highlight_end":72},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let sig_refs_i =","highlight_start":1,"highlight_end":37},{"text":"                        sigs_i.iter().map(|s| s).collect::<Vec<&Signature>>();","highlight_start":1,"highlight_end":79},{"text":"                    let agg_i =","highlight_start":1,"highlight_end":32},{"text":"                        match AggregateSignature::aggregate(&sig_refs_i, false)","highlight_start":1,"highlight_end":80},{"text":"                        {","highlight_start":1,"highlight_end":26},{"text":"                            Ok(agg_i) => agg_i,","highlight_start":1,"highlight_end":48},{"text":"                            Err(err) => panic!(\"aggregate failure: {:?}\", err),","highlight_start":1,"highlight_end":80},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Test current aggregate signature","highlight_start":1,"highlight_end":56},{"text":"                    sigs.push(agg_i.to_signature());","highlight_start":1,"highlight_end":53},{"text":"                    let mut result = sigs[i].fast_aggregate_verify(","highlight_start":1,"highlight_end":68},{"text":"                        false,","highlight_start":1,"highlight_end":31},{"text":"                        &msgs[i],","highlight_start":1,"highlight_end":34},{"text":"                        dst,","highlight_start":1,"highlight_end":29},{"text":"                        &pks_refs_i,","highlight_start":1,"highlight_end":37},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                    assert_eq!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":66},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // negative test","highlight_start":1,"highlight_end":37},{"text":"                    if i != 0 {","highlight_start":1,"highlight_end":32},{"text":"                        result = sigs[i - 1].fast_aggregate_verify(","highlight_start":1,"highlight_end":68},{"text":"                            false,","highlight_start":1,"highlight_end":35},{"text":"                            &msgs[i],","highlight_start":1,"highlight_end":38},{"text":"                            dst,","highlight_start":1,"highlight_end":33},{"text":"                            &pks_refs_i,","highlight_start":1,"highlight_end":41},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                        assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":70},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // aggregate public keys and push into vec","highlight_start":1,"highlight_end":63},{"text":"                    let agg_pk_i =","highlight_start":1,"highlight_end":35},{"text":"                        match AggregatePublicKey::aggregate(&pks_refs_i, false)","highlight_start":1,"highlight_end":80},{"text":"                        {","highlight_start":1,"highlight_end":26},{"text":"                            Ok(agg_pk_i) => agg_pk_i,","highlight_start":1,"highlight_end":54},{"text":"                            Err(err) => panic!(\"aggregate failure: {:?}\", err),","highlight_start":1,"highlight_end":80},{"text":"                        };","highlight_start":1,"highlight_end":27},{"text":"                    pks.push(agg_pk_i.to_public_key());","highlight_start":1,"highlight_end":56},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Test current aggregate signature with aggregated pks","highlight_start":1,"highlight_end":76},{"text":"                    result = sigs[i].fast_aggregate_verify_pre_aggregated(","highlight_start":1,"highlight_end":75},{"text":"                        false, &msgs[i], dst, &pks[i],","highlight_start":1,"highlight_end":55},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                    assert_eq!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":66},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // negative test","highlight_start":1,"highlight_end":37},{"text":"                    if i != 0 {","highlight_start":1,"highlight_end":32},{"text":"                        result = sigs[i - 1]","highlight_start":1,"highlight_end":45},{"text":"                            .fast_aggregate_verify_pre_aggregated(","highlight_start":1,"highlight_end":67},{"text":"                                false, &msgs[i], dst, &pks[i],","highlight_start":1,"highlight_end":63},{"text":"                            );","highlight_start":1,"highlight_end":31},{"text":"                        assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":70},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // create random values","highlight_start":1,"highlight_end":44},{"text":"                    let mut vals = [0u64; 4];","highlight_start":1,"highlight_end":46},{"text":"                    vals[0] = rng.next_u64();","highlight_start":1,"highlight_end":46},{"text":"                    while vals[0] == 0 {","highlight_start":1,"highlight_end":41},{"text":"                        // Reject zero as it is used for multiplication.","highlight_start":1,"highlight_end":73},{"text":"                        vals[0] = rng.next_u64();","highlight_start":1,"highlight_end":50},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    let mut rand_i =","highlight_start":1,"highlight_end":37},{"text":"                        std::mem::MaybeUninit::<blst_scalar>::uninit();","highlight_start":1,"highlight_end":72},{"text":"                    unsafe {","highlight_start":1,"highlight_end":29},{"text":"                        blst_scalar_from_uint64(","highlight_start":1,"highlight_end":49},{"text":"                            rand_i.as_mut_ptr(),","highlight_start":1,"highlight_end":49},{"text":"                            vals.as_ptr(),","highlight_start":1,"highlight_end":43},{"text":"                        );","highlight_start":1,"highlight_end":27},{"text":"                        rands.push(rand_i.assume_init());","highlight_start":1,"highlight_end":58},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let msgs_refs: Vec<&[u8]> =","highlight_start":1,"highlight_end":44},{"text":"                    msgs.iter().map(|m| m.as_slice()).collect();","highlight_start":1,"highlight_end":65},{"text":"                let sig_refs =","highlight_start":1,"highlight_end":31},{"text":"                    sigs.iter().map(|s| s).collect::<Vec<&Signature>>();","highlight_start":1,"highlight_end":73},{"text":"                let pks_refs: Vec<&PublicKey> =","highlight_start":1,"highlight_end":48},{"text":"                    pks.iter().map(|pk| pk).collect();","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let msgs_rev: Vec<&[u8]> =","highlight_start":1,"highlight_end":43},{"text":"                    msgs.iter().rev().map(|m| m.as_slice()).collect();","highlight_start":1,"highlight_end":71},{"text":"                let sig_rev =","highlight_start":1,"highlight_end":30},{"text":"                    sigs.iter().rev().map(|s| s).collect::<Vec<&Signature>>();","highlight_start":1,"highlight_end":79},{"text":"                let pks_rev: Vec<&PublicKey> =","highlight_start":1,"highlight_end":47},{"text":"                    pks.iter().rev().map(|pk| pk).collect();","highlight_start":1,"highlight_end":61},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut result =","highlight_start":1,"highlight_end":33},{"text":"                    Signature::verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":69},{"text":"                        &msgs_refs, dst, &pks_refs, false, &sig_refs, true,","highlight_start":1,"highlight_end":76},{"text":"                        &rands, 64,","highlight_start":1,"highlight_end":36},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"                assert_eq!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // negative tests (use reverse msgs, pks, and sigs)","highlight_start":1,"highlight_end":68},{"text":"                result = Signature::verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":74},{"text":"                    &msgs_rev, dst, &pks_refs, false, &sig_refs, true, &rands,","highlight_start":1,"highlight_end":79},{"text":"                    64,","highlight_start":1,"highlight_end":24},{"text":"                );","highlight_start":1,"highlight_end":19},{"text":"                assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                result = Signature::verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":74},{"text":"                    &msgs_refs, dst, &pks_rev, false, &sig_refs, true, &rands,","highlight_start":1,"highlight_end":79},{"text":"                    64,","highlight_start":1,"highlight_end":24},{"text":"                );","highlight_start":1,"highlight_end":19},{"text":"                assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                result = Signature::verify_multiple_aggregate_signatures(","highlight_start":1,"highlight_end":74},{"text":"                    &msgs_refs, dst, &pks_refs, false, &sig_rev, true, &rands,","highlight_start":1,"highlight_end":79},{"text":"                    64,","highlight_start":1,"highlight_end":24},{"text":"                );","highlight_start":1,"highlight_end":19},{"text":"                assert_ne!(result, BLST_ERROR::BLST_SUCCESS);","highlight_start":1,"highlight_end":62},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            #[test]","highlight_start":1,"highlight_end":20},{"text":"            fn test_serialization() {","highlight_start":1,"highlight_end":38},{"text":"                let seed = [0u8; 32];","highlight_start":1,"highlight_end":38},{"text":"                let mut rng = ChaCha20Rng::from_seed(seed);","highlight_start":1,"highlight_end":60},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let sk = gen_random_key(&mut rng);","highlight_start":1,"highlight_end":51},{"text":"                let sk2 = gen_random_key(&mut rng);","highlight_start":1,"highlight_end":52},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk = sk.sk_to_pk();","highlight_start":1,"highlight_end":40},{"text":"                let pk_comp = pk.compress();","highlight_start":1,"highlight_end":45},{"text":"                let pk_ser = pk.serialize();","highlight_start":1,"highlight_end":45},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_uncomp = PublicKey::uncompress(&pk_comp);","highlight_start":1,"highlight_end":65},{"text":"                assert_eq!(pk_uncomp.is_ok(), true);","highlight_start":1,"highlight_end":53},{"text":"                assert_eq!(pk_uncomp.unwrap(), pk);","highlight_start":1,"highlight_end":52},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_deser = PublicKey::deserialize(&pk_ser);","highlight_start":1,"highlight_end":64},{"text":"                assert_eq!(pk_deser.is_ok(), true);","highlight_start":1,"highlight_end":52},{"text":"                assert_eq!(pk_deser.unwrap(), pk);","highlight_start":1,"highlight_end":51},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk2 = sk2.sk_to_pk();","highlight_start":1,"highlight_end":42},{"text":"                let pk_comp2 = pk2.compress();","highlight_start":1,"highlight_end":47},{"text":"                let pk_ser2 = pk2.serialize();","highlight_start":1,"highlight_end":47},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_uncomp2 = PublicKey::uncompress(&pk_comp2);","highlight_start":1,"highlight_end":67},{"text":"                assert_eq!(pk_uncomp2.is_ok(), true);","highlight_start":1,"highlight_end":54},{"text":"                assert_eq!(pk_uncomp2.unwrap(), pk2);","highlight_start":1,"highlight_end":54},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let pk_deser2 = PublicKey::deserialize(&pk_ser2);","highlight_start":1,"highlight_end":66},{"text":"                assert_eq!(pk_deser2.is_ok(), true);","highlight_start":1,"highlight_end":53},{"text":"                assert_eq!(pk_deser2.unwrap(), pk2);","highlight_start":1,"highlight_end":53},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                assert_ne!(pk, pk2);","highlight_start":1,"highlight_end":37},{"text":"                assert_ne!(pk_uncomp.unwrap(), pk2);","highlight_start":1,"highlight_end":53},{"text":"                assert_ne!(pk_deser.unwrap(), pk2);","highlight_start":1,"highlight_end":52},{"text":"                assert_ne!(pk_uncomp2.unwrap(), pk);","highlight_start":1,"highlight_end":53},{"text":"                assert_ne!(pk_deser2.unwrap(), pk);","highlight_start":1,"highlight_end":52},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: variable does not need to be mutable\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/azureuser/blst/bindings/rust/src/lib.rs:935:21\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m935\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m                let mut acc = rx.recv().unwrap();\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: remove this `mut`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1516\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    sig_variant_impl!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1517\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"MinSig\",\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1518\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        blst_p2,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1519\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        blst_p2_affine,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1553\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        blst_p1_in_g1,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1554\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    );\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|______-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this warning originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"5 warnings emitted","code":null,"level":"warning","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: 5 warnings emitted\u001b[0m\n\n"}
